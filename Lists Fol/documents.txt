given string string char distinct charact integ array val length char cost substr sum valu charact substr cost empti string consid 0 valu charact defin follow way charact string char valu correspond posit 1index alphabet exampl valu 1 valu b 2 valu z 26 otherwis assum index charact occur string char valu valsi return maximum cost among substr string exampl 1 input adaa char val 1000 output 2 explan valu charact 1 1000 respect substr maximum cost aa cost 1 1 2 proven 2 maximum cost exampl 2 input abc char abc val 111 output 0 explan valu charact b c 1 1 1 respect substr maximum cost empti substr cost 0 proven 0 maximum cost constraint 1 slength 105 consist lowercas english letter 1 charslength 26 char consist distinct lowercas english letter valslength charslength 1000 valsi 1000 findthesubstringwithmaximumcost
given 0index string pattern length n consist charact mean increas mean decreas 0index string num length n 1 creat use follow condit num consist digit 1 9 digit use patterni numi numi 1 patterni numi numi 1 return lexicograph smallest possibl string num meet condit exampl 1 input pattern iiididdd output 123549876 explan indic 0 1 2 4 must numi numi1 indic 3 5 6 7 must numi numi1 possibl valu num 245639871 135749862 123849765 proven 123549876 smallest possibl num meet condit note 123414321 possibl digit 1 use exampl 2 input pattern ddd output 4321 explan possibl valu num 9876 7321 8742 proven 4321 smallest possibl num meet condit constraint 1 patternlength 8 pattern consist letter constructsmallestnumberfromdistr
given head link list remov everi node node strictli greater valu anywher right side return head modifi link list exampl 1 input head 521338 output 138 explan node remov 5 2 3 node 13 right node 5 node 13 right node 2 node 8 right node 3 exampl 2 input head 1111 output 1111 explan everi node valu 1 node remov constraint number node given list rang 1 105 1 nodev 105 removenodesfromlinkedlist
given coordin string repres coordin squar chessboard chessboard refer return true squar white fals squar black coordin alway repres valid chessboard squar coordin alway letter first number second exampl 1 input coordin a1 output fals explan chessboard squar coordin a1 black return fals exampl 2 input coordin h3 output true explan chessboard squar coordin h3 white return true exampl 3 input coordin c7 output fals constraint coordinateslength 2 coordinates0 h 1 coordinates1 8 determinecolorofachessboardsquar
sql schema tabl price column name type productid int startdat date enddat date price int productid startdat enddat primari key tabl row tabl indic price productid period startdat enddat productid two overlap period mean two intersect period productid tabl unitssold column name type productid int purchased date unit int primari key tabl may contain duplic row tabl indic date unit productid product sold write sql queri find averag sell price product averagepric round 2 decim place return result tabl order queri result format follow exampl exampl 1 input price tabl productid startdat enddat price 1 20190217 20190228 5 1 20190301 20190322 20 2 20190201 20190220 15 2 20190221 20190331 30 unitssold tabl productid purchased unit 1 20190225 100 1 20190301 15 2 20190210 200 2 20190322 30 output productid averagepric 1 696 2 1696 explan averag sell price total price product number product sold averag sell price product 1 100 5 15 20 115 696 averag sell price product 2 200 15 30 30 230 1696 averagesellingpric
given x n integ matrix grid cell either 0 empti 1 obstacl move left right empti cell one step return minimum number step walk upper left corner 0 0 lower right corner 1 n 1 given elimin k obstacl possibl find walk return 1 exampl 1 input grid 000110000011000 k 1 output 6 explan shortest path without elimin obstacl 10 shortest path one obstacl elimin posit 32 6 path 00 01 02 12 22 32 42 exampl 2 input grid 011111100 k 1 output 1 explan need elimin least two obstacl find walk constraint gridlength n gridilength 1 n 40 1 k n gridij either 0 1 grid00 gridm 1n 1 0 shortestpathinagridwithobstacleselimin
play simplifi pacman game infinit 2d grid start point 0 0 given destin point target xtarget ytarget tri get sever ghost map start posit given 2d array ghost ghostsi xi yi repres start posit ith ghost input integr coordin turn ghost may independ choos either move 1 unit four cardin direct north east south west stay still action happen simultan escap reach target ghost reach reach squar includ target time ghost count escap return true possibl escap regardless ghost move otherwis return fals exampl 1 input ghost 1003 target 01 output true explan reach destin 0 1 1 turn ghost locat 1 0 0 3 catch exampl 2 input ghost 10 target 20 output fals explan need reach destin 2 0 ghost 1 0 lie destin exampl 3 input ghost 20 target 10 output fals explan ghost reach target time constraint 1 ghostslength 100 ghostsilength 2 104 xi yi 104 multipl ghost locat targetlength 2 104 xtarget ytarget 104 escapetheghost
sql schema tabl person column name type personid int lastnam varchar firstnam varchar personid primari key column tabl tabl contain inform id person first last name tabl address column name type addressid int personid int citi varchar state varchar addressid primari key column tabl row tabl contain inform citi state one person id personid write sql queri report first name last name citi state person person tabl address personid present address tabl report null instead return result tabl order queri result format follow exampl exampl 1 input person tabl personid lastnam firstnam 1 wang allen 2 alic bob address tabl addressid personid citi state 1 2 new york citi new york 2 3 leetcod california output firstnam lastnam citi state allen wang null null bob alic new york citi new york explan address address tabl personid 1 return null citi state addressid 1 contain inform address personid 2 combinetwot
given charact array task repres task cpu need letter repres differ task task could done order task done one unit time unit time cpu could complet either one task idl howev nonneg integ n repres cooldown period two task letter array must least n unit time two task return least number unit time cpu take finish given task exampl 1 input task aaabbb n 2 output 8 explan b idl b idl b least 2 unit time two task exampl 2 input task aaabbb n 0 output 6 explan case permut size 6 would work sinc n 0 aaabbb ababab bbbaaa exampl 3 input task aaaaaabcdefg n 2 output 16 explan one possibl solut b c e f g idl idl idl idl constraint 1 tasklength 104 tasksi uppercas english letter integ n rang 0 100 taskschedul
given 0index 2d integ array event eventsi starttimei endtimei valuei ith event start starttimei end endtimei attend event receiv valu valuei choos two nonoverlap event attend sum valu maxim return maximum sum note start time end time inclus attend two event one start end time specif attend event end time next event must start 1 exampl 1 input event 132452243 output 4 explan choos green event 0 1 sum 2 2 4 exampl 2 input event 132452155 output 5 explan choos event 2 sum 5 exampl 3 input event 153151665 output 8 explan choos event 0 2 sum 3 5 8 constraint 2 eventslength 105 eventsilength 3 1 starttimei endtimei 109 1 valuei 106 twobestnonoverlappingev
given root binari tree return zigzag level order travers node valu ie left right right left next level altern exampl 1 input root 3920nullnull157 output 3209157 exampl 2 input root 1 output 1 exampl 3 input root output constraint number node tree rang 0 2000 100 nodev 100 binarytreezigzaglevelordertravers
given integ array num contain n integ find beauti subarray size k beauti subarray xth smallest integ subarray neg 0 fewer x neg integ return integ array contain n k 1 integ denot beauti subarray order first index array subarray contigu nonempti sequenc element within array exampl 1 input num 11323 k 3 x 2 output 122 explan 3 subarray size k 3 first subarray 1 1 3 2nd smallest neg integ 1 second subarray 1 3 2 2nd smallest neg integ 2 third subarray 3 2 3 2nd smallest neg integ 2 exampl 2 input num 12345 k 2 x 2 output 1234 explan 4 subarray size k 2 1 2 2nd smallest neg integ 1 2 3 2nd smallest neg integ 2 3 4 2nd smallest neg integ 3 4 5 2nd smallest neg integ 4 exampl 3 input num 312303 k 2 x 1 output 30333 explan 5 subarray size k 2 3 1 1st smallest neg integ 3 1 2 neg integ beauti 0 2 3 1st smallest neg integ 3 3 0 1st smallest neg integ 3 0 3 1st smallest neg integ 3 constraint n numslength 1 n 105 1 k n 1 x k 50 numsi 50 slidingsubarraybeauti
given two string length integ maxcost want chang chang ith charact ith charact cost si ti ie absolut differ ascii valu charact return maximum length substr chang correspond substr cost less equal maxcost substr chang correspond substr return 0 exampl 1 input abcd bcdf maxcost 3 output 3 explan abc chang bcd cost 3 maximum length 3 exampl 2 input abcd cdef maxcost 3 output 1 explan charact cost 2 chang charact maximum length 1 exampl 3 input abcd acd maxcost 0 output 1 explan make chang maximum length 1 constraint 1 slength 105 tlength slength 0 maxcost 106 consist lowercas english letter getequalsubstringswithinbudget
beauti string differ frequenc frequent least frequent charact exampl beauti abaacc 3 1 2 given string return sum beauti substr exampl 1 input aabcb output 5 explan substr nonzero beauti aabaabcaabcbabcbbcb beauti equal 1 exampl 2 input aabcbaa output 17 constraint 1 slength 500 consist lowercas english letter sumofbeautyofallsubstr
given 0index integ array num index 1 numslength 2 beauti numsi equal 2 numsj numsi numsk 0 j k numslength 1 1 numsi 1 numsi numsi 1 previou condit satisfi 0 none previou condit hold return sum beauti numsi 1 numslength 2 exampl 1 input num 123 output 2 explan index rang 1 1 beauti nums1 equal 2 exampl 2 input num 2464 output 1 explan index rang 1 2 beauti nums1 equal 1 beauti nums2 equal 0 exampl 3 input num 321 output 0 explan index rang 1 1 beauti nums1 equal 0 constraint 3 numslength 105 1 numsi 105 sumofbeautyinthearray
given string num repres larg integ integ good meet follow condit substr num length 3 consist one uniqu digit return maximum good integ string empti string integ exist note substr contigu sequenc charact within string may lead zero num good integ exampl 1 input num 6777133339 output 777 explan two distinct good integ 777 333 777 largest return 777 exampl 2 input num 2300019 output 000 explan 000 good integ exampl 3 input num 42352338 output explan substr length 3 consist one uniqu digit therefor good integ constraint 3 numlength 1000 num consist digit largest3samedigitnumberinstr
given array integ preorder repres preorder travers bst ie binari search tree construct tree return root guarante alway possibl find binari search tree given requir given test case binari search tree binari tree everi node descend nodeleft valu strictli less nodev descend noderight valu strictli greater nodev preorder travers binari tree display valu node first travers nodeleft travers noderight exampl 1 input preorder 85171012 output 851017null12 exampl 2 input preorder 13 output 1null3 constraint 1 preorderlength 100 1 preorderi 1000 valu preorder uniqu constructbinarysearchtreefrompreordertravers
n car go destin along onelan road destin target mile away given two integ array posit speed length n positioni posit ith car speedi speed ith car mile per hour car never pass anoth car ahead catch drive bumper bumper speed faster car slow match slower car speed distanc two car ignor ie assum posit car fleet nonempti set car drive posit speed note singl car also car fleet car catch car fleet right destin point still consid one car fleet return number car fleet arriv destin exampl 1 input target 12 posit 108053 speed 24113 output 3 explan car start 10 speed 2 8 speed 4 becom fleet meet 12 car start 0 catch car fleet car start 5 speed 1 3 speed 3 becom fleet meet 6 fleet move speed 1 reach target note car meet fleet destin answer 3 exampl 2 input target 10 posit 3 speed 3 output 1 explan one car henc one fleet exampl 3 input target 100 posit 024 speed 421 output 1 explan car start 0 speed 4 2 speed 2 becom fleet meet 4 fleet move speed 2 fleet speed 2 car start 4 speed 1 becom one fleet meet 6 fleet move speed 1 reach target constraint n positionlength speedlength 1 n 105 0 target 106 0 positioni target valu posit uniqu 0 speedi 106 carfleet
given list string word string pattern return list wordsi match pattern may return answer order word match pattern exist permut letter p replac everi letter x pattern px get desir word recal permut letter biject letter letter everi letter map anoth letter two letter map letter exampl 1 input word abcdeqmeeaqqdkdccc pattern abb output meeaqq explan mee match pattern permut b e ccc match pattern c b c permut sinc b map letter exampl 2 input word abc pattern output abc constraint 1 patternlength 20 1 wordslength 50 wordsilength patternlength pattern wordsi lowercas english letter findandreplacepattern
given integ array num contain distinct number perform follow oper array empti first element smallest valu remov otherwis put first element end array return integ denot number oper take make num empti exampl 1 input num 341 output 5 oper array 1 4 1 3 2 1 3 4 3 3 4 4 4 5 exampl 2 input num 1243 output 5 oper array 1 2 4 3 2 4 3 3 3 4 4 4 5 exampl 3 input num 123 output 3 oper array 1 2 3 2 3 3 constraint 1 numslength 105 109 numsi 109 valu num distinct makearrayempti
given integ n 0index integ array num length n 1 gener follow way nums0 0 nums1 1 nums2 numsi 2 2 n nums2 1 numsi numsi 1 2 2 1 n return maximum integ array num exampl 1 input n 7 output 3 explan accord given rule nums0 0 nums1 1 nums1 2 2 nums1 1 nums1 2 1 3 nums1 nums2 1 1 2 nums2 2 4 nums2 1 nums2 2 1 5 nums2 nums3 1 2 3 nums3 2 6 nums3 2 nums3 2 1 7 nums3 nums4 2 1 3 henc num 01121323 maximum max01121323 3 exampl 2 input n 2 output 1 explan accord given rule num 011 maximum max011 1 exampl 3 input n 3 output 2 explan accord given rule num 0112 maximum max0112 2 constraint 0 n 100 getmaximumingeneratedarray
given array num n integ return array uniqu quadruplet numsa numsb numsc numsd 0 b c n b c distinct numsa numsb numsc numsd target may return answer order exampl 1 input num 101022 target 0 output 211220021001 exampl 2 input num 22222 target 8 output 2222 constraint 1 numslength 200 109 numsi 109 109 target 109 4sum
given 0index integ array num size n contain number 1 n return number increas quadruplet quadruplet j k l increas 0 j k l n numsi numsk numsj numsl exampl 1 input num 13245 output 2 explan 0 j 1 k 2 l 3 numsi numsk numsj numsl 0 j 1 k 2 l 4 numsi numsk numsj numsl quadruplet return 2 exampl 2 input num 1234 output 0 explan exist one quadruplet 0 j 1 k 2 l 3 sinc numsj numsk return 0 constraint 4 numslength 4000 1 numsi numslength integ num uniqu num permut countincreasingquadruplet
malfunct keyboard letter key work key keyboard work properli given string text word separ singl space lead trail space string brokenlett distinct letter key broken return number word text fulli type use keyboard exampl 1 input text hello world brokenlett ad output 1 explan type world key broken exampl 2 input text leet code brokenlett lt output 1 explan type leet l key broken exampl 3 input text leet code brokenlett e output 0 explan type either word e key broken constraint 1 textlength 104 0 brokenletterslength 26 text consist word separ singl space without lead trail space word consist lowercas english letter brokenlett consist distinct lowercas english letter maximumnumberofwordsyoucantyp
given two string word1 word2 return minimum number step requir make word1 word2 one step delet exactli one charact either string exampl 1 input word1 sea word2 eat output 2 explan need one step make sea ea anoth step make eat ea exampl 2 input word1 leetcod word2 etco output 4 constraint 1 word1length word2length 500 word1 word2 consist lowercas english letter deleteoperationfortwostr
frog cross river river divid number unit unit may may exist stone frog jump stone must jump water given list stone posit unit sort ascend order determin frog cross river land last stone initi frog first stone assum first jump must 1 unit frog last jump k unit next jump must either k 1 k k 1 unit frog jump forward direct exampl 1 input stone 0135681217 output true explan frog jump last stone jump 1 unit 2nd stone 2 unit 3rd stone 2 unit 4th stone 3 unit 6th stone 4 unit 7th stone 5 unit 8th stone exampl 2 input stone 012348911 output fals explan way jump last stone gap 5th 6th stone larg constraint 2 stoneslength 2000 0 stonesi 231 1 stones0 0 stone sort strictli increas order frogjump
given array integ arr find sum minb b rang everi contigu subarray arr sinc answer may larg return answer modulo 109 7 exampl 1 input arr 3124 output 17 explan subarray 3 1 2 4 31 12 24 312 124 3124 minimum 3 1 2 4 1 1 2 1 1 1 sum 17 exampl 2 input arr 118194433 output 444 constraint 1 arrlength 3 104 1 arri 3 104 sumofsubarrayminimum
sql schema tabl user column name type userid int joindat date favoritebrand varchar userid primari key tabl tabl info user onlin shop websit user sell buy item tabl order column name type orderid int orderd date itemid int buyerid int sellerid int orderid primari key tabl itemid foreign key item tabl buyerid sellerid foreign key user tabl tabl item column name type itemid int itembrand varchar itemid primari key tabl write sql queri find user join date number order made buyer 2019 return result tabl order queri result format follow exampl exampl 1 input user tabl userid joindat favoritebrand 1 20180101 lenovo 2 20180209 samsung 3 20180119 lg 4 20180521 hp order tabl orderid orderd itemid buyerid sellerid 1 20190801 4 1 2 2 20180802 2 1 3 3 20190803 3 2 3 4 20180804 1 4 2 5 20180804 1 3 4 6 20190805 2 2 4 item tabl itemid itembrand 1 samsung 2 lenovo 3 lg 4 hp output buyerid joindat ordersin2019 1 20180101 1 2 20180209 2 3 20180119 0 4 20180521 0 marketanalysisi
given array integ num start initi posit valu startvalu iter calcul step step sum startvalu plu element num left right return minimum posit valu startvalu step step sum never less 1 exampl 1 input num 32342 output 5 explan choos startvalu 4 third iter step step sum less 1 step step sum startvalu 4 startvalu 5 num 4 3 1 5 3 2 3 1 2 3 2 2 4 2 3 3 0 4 3 1 3 0 4 4 1 4 5 4 4 2 6 5 2 7 2 exampl 2 input num 12 output 1 explan minimum start valu posit exampl 3 input num 123 output 5 constraint 1 numslength 100 100 numsi 100 minimumvaluetogetpositivestepbystepsum
given integ n return number structur uniqu bst binari search tree exactli n node uniqu valu 1 n exampl 1 input n 3 output 5 exampl 2 input n 1 output 1 constraint 1 n 19 uniquebinarysearchtre
given 0index 1dimension 1d integ array origin two integ n task creat 2dimension 2d array row n column use element origin element indic 0 n 1 inclus origin form first row construct 2d array element indic n 2 n 1 inclus form second row construct 2d array return x n 2d array construct accord procedur empti 2d array imposs exampl 1 input origin 1234 2 n 2 output 1234 explan construct 2d array contain 2 row 2 column first group n2 element origin 12 becom first row construct 2d array second group n2 element origin 34 becom second row construct 2d array exampl 2 input origin 123 1 n 3 output 123 explan construct 2d array contain 1 row 3 column put three element origin first row construct 2d array exampl 3 input origin 12 1 n 1 output explan 2 element origin imposs fit 2 element 1x1 2d array return empti 2d array constraint 1 originallength 5 104 1 originali 105 1 n 4 104 convert1darrayinto2darray
given 2d integ array interv intervalsi lefti righti repres inclus interv lefti righti divid interv one group interv exactli one group two interv group intersect return minimum number group need make two interv intersect least one common number exampl interv 1 5 5 8 intersect exampl 1 input interv 510681523110 output 3 explan divid interv follow group group 1 1 5 6 8 group 2 2 3 5 10 group 3 1 10 proven possibl divid interv fewer 3 group exampl 2 input interv 13568101113 output 1 explan none interv overlap put one group constraint 1 intervalslength 105 intervalsilength 2 1 lefti righti 106 divideintervalsintominimumnumberofgroup
given array integ arr two integ k threshold return number subarray size k averag greater equal threshold exampl 1 input arr 22225558 k 3 threshold 4 output 3 explan subarray 255555 558 averag 4 5 6 respect subarray size 3 averag less 4 threshold exampl 2 input arr 1113172329317523 k 3 threshold 5 output 6 explan first 6 subarray size 3 averag greater 5 note averag integ constraint 1 arrlength 105 1 arri 104 1 k arrlength 0 threshold 104 numberofsubarraysofsizekandaveragegreaterthanorequaltothreshold
wiggl sequenc sequenc differ success number strictli altern posit neg first differ one exist may either posit neg sequenc one element sequenc two nonequ element trivial wiggl sequenc exampl 1 7 4 9 2 5 wiggl sequenc differ 6 3 5 7 3 altern posit neg contrast 1 4 7 2 5 1 7 4 5 5 wiggl sequenc first first two differ posit second last differ zero subsequ obtain delet element possibl zero origin sequenc leav remain element origin order given integ array num return length longest wiggl subsequ num exampl 1 input num 174925 output 6 explan entir sequenc wiggl sequenc differ 6 3 5 7 3 exampl 2 input num 1175101315105168 output 7 explan sever subsequ achiev length one 1 17 10 13 10 16 8 differ 16 7 3 3 6 8 exampl 3 input num 123456789 output 2 constraint 1 numslength 1000 0 numsi 1000 follow could solv time wigglesubsequ
given posit integ primefactor ask construct posit integ n satisfi follow condit number prime factor n necessarili distinct primefactor number nice divisor n maxim note divisor n nice divis everi prime factor n exampl n 12 prime factor 223 6 12 nice divisor 3 4 return number nice divisor n sinc number larg return modulo 109 7 note prime number natur number greater 1 product two smaller natur number prime factor number n list prime number product equal n exampl 1 input primefactor 5 output 6 explan 200 valid valu n 5 prime factor 22255 6 nice divisor 10204050100200 valu n 5 prime factor nice divisor exampl 2 input primefactor 8 output 18 constraint 1 primefactor 109 maximizenumberofnicedivisor
given 0index integ array pile pilesi repres number stone ith pile integ k appli follow oper exactli k time choos pilesi remov floorpilesi 2 stone notic appli oper pile return minimum possibl total number stone remain appli k oper floorx greatest integ smaller equal x ie round x exampl 1 input pile 549 k 2 output 12 explan step possibl scenario appli oper pile 2 result pile 545 appli oper pile 0 result pile 345 total number stone 345 12 exampl 2 input pile 4367 k 3 output 12 explan step possibl scenario appli oper pile 2 result pile 4337 appli oper pile 3 result pile 4334 appli oper pile 0 result pile 2334 total number stone 2334 12 constraint 1 pileslength 105 1 pilesi 104 1 k 105 removestonestominimizethetot
sever squar drop onto xaxi 2d plane given 2d integ array posit positionsi lefti sidelengthi repres ith squar side length sidelengthi drop left edg align xcoordin lefti squar drop one time height land squar fall downward neg direct either land top side anoth squar xaxi squar brush leftright side anoth squar count land land freez place move squar drop must record height current tallest stack squar return integ array an ansi repres height describ drop ith squar exampl 1 input posit 122361 output 255 explan first drop tallest stack squar 1 height 2 second drop tallest stack squar 1 2 height 5 third drop tallest stack still squar 1 2 height 5 thu return answer 2 5 5 exampl 2 input posit 100100200100 output 100100 explan first drop tallest stack squar 1 height 100 second drop tallest stack either squar 1 squar 2 height 100 thu return answer 100 100 note squar 2 brush right side squar 1 count land constraint 1 positionslength 1000 1 lefti 108 1 sidelengthi 106 fallingsquar
given integ finalsum split sum maximum number uniqu posit even integ exampl given finalsum 12 follow split valid uniqu posit even integ sum finalsum 12 2 10 2 4 6 4 8 among 2 4 6 contain maximum number integ note finalsum split 2 2 4 4 number uniqu return list integ repres valid split contain maximum number integ valid split exist finalsum return empti list may return integ order exampl 1 input finalsum 12 output 246 explan follow valid split 12 2 10 2 4 6 4 8 2 4 6 maximum number integ 3 thu return 246 note 264 624 etc also accept exampl 2 input finalsum 7 output explan valid split given finalsum thu return empti array exampl 3 input finalsum 28 output 68212 explan follow valid split 2 26 6 8 2 12 4 24 6 8 2 12 maximum number integ 4 thu return 68212 note 102412 62416 etc also accept constraint 1 finalsum 1010 maximumsplitofpositiveeveninteg
given integ array num two integ firstlen secondlen return maximum sum element two nonoverlap subarray length firstlen secondlen array length firstlen could occur array length secondlen nonoverlap subarray contigu part array exampl 1 input num 065225194 firstlen 1 secondlen 2 output 20 explan one choic subarray 9 length 1 65 length 2 exampl 2 input num 381321890 firstlen 3 secondlen 2 output 29 explan one choic subarray 381 length 3 89 length 2 exampl 3 input num 2156095038 firstlen 4 secondlen 3 output 31 explan one choic subarray 5609 length 4 038 length 3 constraint 1 firstlen secondlen 1000 2 firstlen secondlen 1000 firstlen secondlen numslength 1000 0 numsi 1000 maximumsumoftwononoverlappingsubarray
given array n integ num 50 uniqu valu array also given array custom order quantiti quantiti quantityi amount integ ith custom order determin possibl distribut num ith custom get exactli quantityi integ integ ith custom get equal everi custom satisfi return true possibl distribut num accord condit exampl 1 input num 1234 quantiti 2 output fals explan 0th custom given two differ integ exampl 2 input num 1233 quantiti 2 output true explan 0th custom given 33 integ 12 use exampl 3 input num 1122 quantiti 22 output true explan 0th custom given 11 1st custom given 22 constraint n numslength 1 n 105 1 numsi 1000 quantitylength 1 10 1 quantityi 105 50 uniqu valu num distributerepeatinginteg
given array string str group anagram togeth return answer order anagram word phrase form rearrang letter differ word phrase typic use origin letter exactli exampl 1 input str eatteatanatenatbat output batnattanateeattea exampl 2 input str output exampl 3 input str output constraint 1 strslength 104 0 strsilength 100 strsi consist lowercas english letter groupanagram
given integ array num posit integ return averag valu even integ divis 3 note averag n element sum n element divid n round nearest integ exampl 1 input num 136101215 output 9 explan 6 12 even number divis 3 6 12 2 9 exampl 2 input num 124710 output 0 explan singl number satisfi requir return 0 constraint 1 numslength 1000 1 numsi 1000 averagevalueofevennumbersthataredivisiblebythre
write function createhelloworld return new function alway return hello world exampl 1 input arg output hello world explan const f createhelloworld f hello world function return createhelloworld alway return hello world exampl 2 input arg null42 output hello world explan const f createhelloworld f null 42 hello world argument could pass function still alway return hello world constraint 0 argslength 10 createhelloworldfunct
given two array nums1 nums2 return maximum dot product nonempti subsequ nums1 nums2 length subsequ array new array form origin array delet none charact without disturb rel posit remain charact ie 235 subsequ 12345 153 exampl 1 input nums1 2125 nums2 306 output 18 explan take subsequ 22 nums1 subsequ 36 nums2 dot product 23 26 18 exampl 2 input nums1 32 nums2 267 output 21 explan take subsequ 3 nums1 subsequ 7 nums2 dot product 37 21 exampl 3 input nums1 11 nums2 11 output 1 explan take subsequ 1 nums1 subsequ 1 nums2 dot product 1 constraint 1 nums1length nums2length 500 1000 nums1i nums2i 1000 maxdotproductoftwosubsequ
given array integ arr want select three indic j k 0 j k arrlength let defin b follow arri arri 1 arrj 1 b arrj arrj 1 arrk note denot bitwisexor oper return number triplet j k b exampl 1 input arr 23167 output 4 explan triplet 012 022 234 244 exampl 2 input arr 11111 output 10 constraint 1 arrlength 300 1 arri 108 counttripletsthatcanformtwoarraysofequalxor
k server number 0 k1 use handl multipl request simultan server infinit comput capac handl one request time request assign server accord specif algorithm ith 0index request arriv server busi request drop handl kth server avail assign request server otherwis assign request next avail server wrap around list server start 0 necessari exampl ith server busi tri assign request i1th server i2th server given strictli increas array arriv posit integ arrivali repres arriv time ith request anoth array load loadi repres load ith request time take complet goal find busiest server server consid busiest handl number request success among server return list contain id 0index busiest server may return id order exampl 1 input k 3 arriv 12345 load 52333 output 1 explan server start avail first 3 request handl first 3 server order request 3 come server 0 busi assign next avail server 1 request 4 come handl sinc server busi drop server 0 2 handl one request server 1 handl two request henc server 1 busiest server exampl 2 input k 3 arriv 1234 load 1212 output 0 explan first 3 request handl first 3 server request 3 come handl server 0 sinc server avail server 0 handl two request server 1 2 handl one request henc server 0 busiest server exampl 3 input k 3 arriv 123 load 101211 output 012 explan server handl singl request consid busiest constraint 1 k 105 1 arrivallength loadlength 105 arrivallength loadlength 1 arrivali loadi 109 arriv strictli increas findserversthathandledmostnumberofrequest
k bag given 0index integ array weight weightsi weight ith marbl also given integ k divid marbl k bag accord follow rule bag empti ith marbl jth marbl bag marbl index ith jth indic also bag bag consist marbl index j inclus cost bag weightsi weightsj score distribut marbl sum cost k bag return differ maximum minimum score among marbl distribut exampl 1 input weight 1351 k 2 output 4 explan distribut 1351 result minim score 11 31 6 distribut 1351 result maxim score 13 51 10 thu return differ 10 6 4 exampl 2 input weight 1 3 k 2 output 0 explan distribut possibl 13 sinc maxim minim score return 0 constraint 1 k weightslength 105 1 weightsi 109 putmarblesinbag
given integ array arr integ differ return length longest subsequ arr arithmet sequenc differ adjac element subsequ equal differ subsequ sequenc deriv arr delet element without chang order remain element exampl 1 input arr 1234 differ 1 output 4 explan longest arithmet subsequ 1234 exampl 2 input arr 1357 differ 1 output 1 explan longest arithmet subsequ singl element exampl 3 input arr 157853421 differ 2 output 4 explan longest arithmet subsequ 7531 constraint 1 arrlength 105 104 arri differ 104 longestarithmeticsubsequenceofgivendiffer
implement class subrectanglequeri receiv row x col rectangl matrix integ constructor support two method 1 updatesubrectangleint row1 int col1 int row2 int col2 int newvalu updat valu newvalu subrectangl whose upper left coordin row1col1 bottom right coordin row2col2 2 getvalueint row int col return current valu coordin rowcol rectangl exampl 1 input subrectanglequeriesgetvalueupdatesubrectanglegetvaluegetvalueupdatesubrectanglegetvaluegetvalu 121434321111020032502313032103102 output null1null55null105 explan subrectanglequeri subrectanglequeri new subrectanglequeries121434321111 initi rectangl 4x3 look like 1 2 1 4 3 4 3 2 1 1 1 1 subrectanglequeriesgetvalue0 2 return 1 subrectanglequeriesupdatesubrectangle0 0 3 2 5 updat rectangl look like 5 5 5 5 5 5 5 5 5 5 5 5 subrectanglequeriesgetvalue0 2 return 5 subrectanglequeriesgetvalue3 1 return 5 subrectanglequeriesupdatesubrectangle3 0 3 2 10 updat rectangl look like 5 5 5 5 5 5 5 5 5 10 10 10 subrectanglequeriesgetvalue3 1 return 10 subrectanglequeriesgetvalue0 2 return 5 exampl 2 input subrectanglequeriesgetvalueupdatesubrectanglegetvaluegetvalueupdatesubrectanglegetvalu 111222333000022100002211222022 output null1null100100null20 explan subrectanglequeri subrectanglequeri new subrectanglequeries111222333 subrectanglequeriesgetvalue0 0 return 1 subrectanglequeriesupdatesubrectangle0 0 2 2 100 subrectanglequeriesgetvalue0 0 return 100 subrectanglequeriesgetvalue2 2 return 100 subrectanglequeriesupdatesubrectangle1 1 2 2 20 subrectanglequeriesgetvalue2 2 return 20 constraint 500 oper consid method updatesubrectangl getvalu 1 row col 100 row rectanglelength col rectangleilength 0 row1 row2 row 0 col1 col2 col 1 newvalu rectangleij 109 0 row row 0 col col subrectanglequeri
given 0index integ array num one step remov element numsi numsi 1 numsi 0 numslength return number step perform num becom nondecreas array exampl 1 input num 5344736118511 output 3 explan follow step perform step 1 5344736118511 becom 544761111 step 2 544761111 becom 5471111 step 3 5471111 becom 571111 571111 nondecreas array therefor return 3 exampl 2 input num 457713 output 0 explan num alreadi nondecreas array therefor return 0 constraint 1 numslength 105 1 numsi 109 stepstomakearraynondecreas
creat class arraywrapp accept array integ constructor class two featur two instanc class ad togeth oper result valu sum element array string function call instanc return comma separ string surround bracket exampl 123 exampl 1 input num 1234 oper add output 10 explan const obj1 new arraywrapper12 const obj2 new arraywrapper34 obj1 obj2 10 exampl 2 input num 23984270 oper string output 23984270 explan const obj new arraywrapper23984270 stringobj 23984270 exampl 3 input num oper add output 0 explan const obj1 new arraywrapp const obj2 new arraywrapp obj1 obj2 0 constraint 0 numslength 1000 0 numsi 1000 note num array pass constructor arraywrapp
room n bulb label 1 n turn initi four button wall four button differ function button 1 flip statu bulb button 2 flip statu bulb even label ie 2 4 button 3 flip statu bulb odd label ie 1 3 button 4 flip statu bulb label j 3k 1 k 0 1 2 ie 1 4 7 10 must make exactli press button press total press may pick four button press given two integ n press return number differ possibl status perform press button press exampl 1 input n 1 press 1 output 2 explan statu press button 1 press button 2 exampl 2 input n 2 press 1 output 3 explan statu press button 1 press button 2 press button 3 exampl 3 input n 3 press 1 output 4 explan statu press button 1 press button 2 press button 3 press button 4 constraint 1 n 1000 0 press 1000 bulbswitcherii
given two integ array arr1 arr2 return minimum number oper possibl zero need make arr1 strictli increas one oper choos two indic 0 arr1length 0 j arr2length assign arr1i arr2j way make arr1 strictli increas return 1 exampl 1 input arr1 15367 arr2 1324 output 1 explan replac 5 2 arr1 1 2 3 6 7 exampl 2 input arr1 15367 arr2 431 output 2 explan replac 5 3 replac 3 4 arr1 1 3 4 6 7 exampl 3 input arr1 15367 arr2 1633 output 1 explan cant make arr1 strictli increas constraint 1 arr1length arr2length 2000 0 arr1i arr2i 109 makearraystrictlyincreas
given binari tree struct node int val node left node right node next popul next pointer point next right node next right node next pointer set null initi next pointer set null exampl 1 input root 12345null7 output 123457 explan given binari tree figur function popul next pointer point next right node like figur b serial output level order connect next pointer signifi end level exampl 2 input root output constraint number node tree rang 0 6000 100 nodev 100 followup may use constant extra space recurs approach fine may assum implicit stack space count extra space problem populatingnextrightpointersineachnodeii
given x n matrix return element matrix spiral order exampl 1 input matrix 123456789 output 123698745 exampl 2 input matrix 123456789101112 output 123481211109567 constraint matrixlength n matrixilength 1 n 10 100 matrixij 100 spiralmatrix
given root binari tree construct string consist parenthesi integ binari tree preorder travers way return omit empti parenthesi pair affect onetoon map relationship string origin binari tree exampl 1 input root 1234 output 1243 explan origin need 1243 need omit unnecessari empti parenthesi pair 1243 exampl 2 input root 123null4 output 1243 explan almost first exampl except omit first parenthesi pair break onetoon map relationship input output constraint number node tree rang 1 104 1000 nodev 1000 constructstringfrombinarytre
given integ array price pricesi price ith item shop special discount item shop buy ith item receiv discount equival pricesj j minimum index j pricesj pricesi otherwis receiv discount return integ array answer answeri final price pay ith item shop consid special discount exampl 1 input price 84623 output 42423 explan item 0 price08 receiv discount equival prices14 therefor final price pay 8 4 4 item 1 price14 receiv discount equival prices32 therefor final price pay 4 2 2 item 2 price26 receiv discount equival prices32 therefor final price pay 6 2 4 item 3 4 receiv discount exampl 2 input price 12345 output 12345 explan case item receiv discount exampl 3 input price 10116 output 9016 constraint 1 priceslength 500 1 pricesi 1000 finalpriceswithaspecialdiscountinashop
given array restaur restaurantsi idi ratingi veganfriendlyi pricei distancei filter restaur use three filter veganfriendli filter either true mean includ restaur veganfriendlyi set true fals mean includ restaur addit filter maxpric maxdist maximum valu price distanc restaur consid respect return array restaur id filter order rate highest lowest restaur rate order id highest lowest simplic veganfriendlyi veganfriendli take valu 1 true 0 fals exampl 1 input restaur 14140102805053813044100103511151 veganfriendli 1 maxpric 50 maxdist 10 output 315 explan restaur restaur 1 id1 rating4 veganfriendly1 price40 distance10 restaur 2 id2 rating8 veganfriendly0 price50 distance5 restaur 3 id3 rating8 veganfriendly1 price30 distance4 restaur 4 id4 rating10 veganfriendly0 price10 distance3 restaur 5 id5 rating1 veganfriendly1 price15 distance1 filter restaur veganfriendli 1 maxpric 50 maxdist 10 restaur 3 restaur 1 restaur 5 order rate highest lowest exampl 2 input restaur 14140102805053813044100103511151 veganfriendli 0 maxpric 50 maxdist 10 output 43215 explan restaur exampl 1 case filter veganfriendli 0 therefor restaur consid exampl 3 input restaur 14140102805053813044100103511151 veganfriendli 0 maxpric 30 maxdist 3 output 45 constraint 1 restaurantslength 104 restaurantsilength 5 1 idi ratingi pricei distancei 105 1 maxpric maxdist 105 veganfriendlyi veganfriendli 0 1 idi distinct filterrestaurantsbyveganfriendlypriceanddist
given string consist charact b return true everi appear everi b string otherwis return fals exampl 1 input aaabbb output true explan indic 0 1 2 bs indic 3 4 5 henc everi appear everi b return true exampl 2 input abab output fals explan index 2 b index 1 henc everi appear everi b return fals exampl 3 input bbb output true explan henc everi appear everi b return true constraint 1 slength 100 si either b checkifallasappearsbeforeallb
given 0index integ array num repres content pile nums0 topmost element pile one move perform either follow pile empti remov topmost element pile one remov element add one back onto pile element becom new topmost element also given integ k denot total number move made return maximum valu topmost element pile possibl exactli k move case possibl obtain nonempti pile k move return 1 exampl 1 input num 522406 k 4 output 5 explan one way end 5 top pile 4 move follow step 1 remov topmost element 5 pile becom 22406 step 2 remov topmost element 2 pile becom 2406 step 3 remov topmost element 2 pile becom 406 step 4 add 5 back onto pile pile becom 5406 note way end 5 top pile shown 5 largest answer possibl 4 move exampl 2 input num 2 k 1 output 1 explan first move option pop topmost element pile sinc possibl obtain nonempti pile one move return 1 constraint 1 numslength 105 0 numsi k 109 maximizethetopmostelementafterkmov
given root binari tree return sum everi tree node tilt tilt tree node absolut differ sum left subtre node valu right subtre node valu node left child sum left subtre node valu treat 0 rule similar node right child exampl 1 input root 123 output 1 explan tilt node 2 00 0 children tilt node 3 00 0 children tilt node 1 23 1 left subtre left child sum 2 right subtre right child sum 3 sum everi tilt 0 0 1 1 exampl 2 input root 42935null7 output 15 explan tilt node 3 00 0 children tilt node 5 00 0 children tilt node 7 00 0 children tilt node 2 35 2 left subtre left child sum 3 right subtre right child sum 5 tilt node 9 07 7 left child sum 0 right subtre right child sum 7 tilt node 4 35297 1016 6 left subtre valu 3 5 2 sum 10 right subtre valu 9 7 sum 16 sum everi tilt 0 0 0 2 7 6 15 exampl 3 input root 21714112233 output 9 constraint number node tree rang 0 104 1000 nodev 1000 binarytreetilt
given two nonneg integ num1 num2 one oper num1 num2 must subtract num2 num1 otherwis subtract num1 num2 exampl num1 5 num2 4 subtract num2 num1 thu obtain num1 1 num2 4 howev num1 4 num2 5 one oper num1 4 num2 1 return number oper requir make either num1 0 num2 0 exampl 1 input num1 2 num2 3 output 3 explan oper 1 num1 2 num2 3 sinc num1 num2 subtract num1 num2 get num1 2 num2 3 2 1 oper 2 num1 2 num2 1 sinc num1 num2 subtract num2 num1 oper 3 num1 1 num2 1 sinc num1 num2 subtract num2 num1 num1 0 num2 1 sinc num1 0 need perform oper total number oper requir 3 exampl 2 input num1 10 num2 10 output 1 explan oper 1 num1 10 num2 10 sinc num1 num2 subtract num2 num1 get num1 10 10 0 num1 0 num2 10 sinc num1 0 done total number oper requir 1 constraint 0 num1 num2 105 countoperationstoobtainzero
group n peopl label 0 n 1 person differ amount money differ level quiet given array richer richeri ai bi indic ai money bi integ array quiet quieti quiet ith person given data richer logic correct ie data lead situat x richer richer x time return integ array answer answerx least quiet person person smallest valu quieti among peopl definit equal money person x exampl 1 input richer 10213137435363 quiet 32546170 output 55254567 explan answer0 5 person 5 money 3 money 1 money 0 person quieter lower quietx person 7 clear money person 0 answer7 7 among peopl definit equal money person 7 could person 3 4 5 6 7 person quietest lower quietx person 7 answer fill similar reason exampl 2 input richer quiet 0 output 0 constraint n quietlength 1 n 500 0 quieti n valu quiet uniqu 0 richerlength n n 1 2 0 ai bi n ai bi pair richer uniqu observ richer logic consist loudandrich
rang modul modul track rang number design data structur track rang repres halfopen interv queri halfopen interv left right denot real number x left x right implement rangemodul class rangemodul initi object data structur void addrangeint left int right add halfopen interv left right track everi real number interv ad interv partial overlap current track number add number interv left right alreadi track boolean queryrangeint left int right return true everi real number interv left right current track fals otherwis void removerangeint left int right stop track everi real number current track halfopen interv left right exampl 1 input rangemodul addrang removerang queryrang queryrang queryrang 10 20 14 16 10 14 13 15 16 17 output null null null true fals true explan rangemodul rangemodul new rangemodul rangemoduleaddrange10 20 rangemoduleremoverange14 16 rangemodulequeryrange10 14 return trueeveri number 10 14 track rangemodulequeryrange13 15 return falsenumb like 14 1403 1417 13 15 track rangemodulequeryrange16 17 return true number 16 16 17 still track despit remov oper constraint 1 left right 109 104 call made addrang queryrang removerang rangemodul
given string find length longest substr without repeat charact exampl 1 input abcabcbb output 3 explan answer abc length 3 exampl 2 input bbbbb output 1 explan answer b length 1 exampl 3 input pwwkew output 3 explan answer wke length 3 notic answer must substr pwke subsequ substr constraint 0 slength 5 104 consist english letter digit symbol space longestsubstringwithoutrepeatingcharact
given string num repres larg integ return largestvalu odd integ string nonempti substr num empti string odd integ exist substr contigu sequenc charact within string exampl 1 input num 52 output 5 explan nonempti substr 5 2 52 5 odd number exampl 2 input num 4206 output explan odd number 4206 exampl 3 input num 35427 output 35427 explan 35427 alreadi odd number constraint 1 numlength 105 num consist digit contain lead zero largestoddnumberinstr
integ array call arithmet consist least three element differ two consecut element exampl 13579 7777 3159 arithmet sequenc given integ array num return number arithmet subarray num subarray contigu subsequ array exampl 1 input num 1234 output 3 explan 3 arithmet slice num 1 2 3 2 3 4 1234 exampl 2 input num 1 output 0 constraint 1 numslength 5000 1000 numsi 1000 arithmeticslic
given two string word1 word2 merg string ad letter altern order start word1 string longer append addit letter onto end merg string return merg string exampl 1 input word1 abc word2 pqr output apbqcr explan merg string merg word1 b c word2 p q r merg p b q c r exampl 2 input word1 ab word2 pqr output apbqr explan notic word2 longer rs append end word1 b word2 p q r merg p b q r exampl 3 input word1 abcd word2 pq output apbqcd explan notic word1 longer cd append end word1 b c word2 p q merg p b q c constraint 1 word1length word2length 100 word1 word2 consist lowercas english letter mergestringsaltern
given 2d grid consist 0s land 1s water island maxim 4direct connect group 0s close island island total left top right bottom surround 1s return number close island exampl 1 input grid 1111111010000110101011101000010111111110 output 2 explan island gray close complet surround water group 1s exampl 2 input grid 001000101001110 output 1 exampl 3 input grid 1111111 1000001 1011101 1010101 1011101 1000001 1111111 output 2 constraint 1 gridlength grid0length 100 0 gridij 1 numberofclosedisland
width x height grid xyplan bottomleft cell 0 0 topright cell width 1 height 1 grid align four cardin direct north east south west robot initi cell 0 0 face direct east robot instruct move specif number step step follow attempt move forward one cell direct face cell robot move bound robot instead turn 90 degre counterclockwis retri step robot finish move number step requir stop await next instruct implement robot class robotint width int height initi width x height grid robot 0 0 face east void stepint num instruct robot move forward num step int getpo return current cell robot array length 2 x string getdir return current direct robot north east south west exampl 1 input robot step step getpo getdir step step step getpo getdir 6 3 2 2 2 1 4 output null null null 4 0 east null null null 1 2 west explan robot robot new robot6 3 initi grid robot 0 0 face east robotstep2 move two step east 2 0 face east robotstep2 move two step east 4 0 face east robotgetpo return 4 0 robotgetdir return east robotstep2 move one step east 5 0 face east move next step east would bound turn face north move one step north 5 1 face north robotstep1 move one step north 5 2 face north west robotstep4 move next step north would bound turn face west move four step west 1 2 face west robotgetpo return 1 2 robotgetdir return west constraint 2 width height 100 1 num 105 104 call total made step getpo getdir walkingrobotsimulationii
sql schema tabl login column name type userid int timestamp datetim userid timestamp primari key tabl row contain inform login time user id userid write sql queri report latest login user year 2020 includ user login 2020 return result tabl order queri result format follow exampl exampl 1 input login tabl userid timestamp 6 20200630 150607 6 20210421 140606 6 20190307 001815 8 20200201 051053 8 20201230 004650 2 20200116 024950 2 20190825 075908 14 20190714 090000 14 20210106 115959 output userid laststamp 6 20200630 150607 8 20201230 004650 2 20200116 024950 explan user 6 log account 3 time 2020 includ login result tabl user 8 log account 2 time 2020 februari decemb includ latest one decemb result tabl user 2 log account 2 time 2020 includ login result tabl user 14 login 2020 includ result tabl thelatestloginin2020
given root nari tree return preorder travers node valu narytre input serial repres level order travers group children separ null valu see exampl exampl 1 input root 1null324null56 output 135624 exampl 2 input root 1null2345nullnull67null8null910nullnull11null12null13nullnull14 output 1236711144812591310 constraint number node tree rang 0 104 0 nodev 104 height nari tree less equal 1000 follow recurs solut trivial could iter narytreepreordertravers
given head link list rotat list right k place exampl 1 input head 12345 k 2 output 45123 exampl 2 input head 012 k 4 output 201 constraint number node list rang 0 500 100 nodev 100 0 k 2 109 rotatelist
given 0index string task find two nonintersect palindrom substr odd length product length maxim formal want choos four integ j k l 0 j k l slength substr sij skl palindrom odd length sij denot substr index index j inclus return maximum possibl product length two nonintersect palindrom substr palindrom string forward backward substr contigu sequenc charact string exampl 1 input ababbb output 9 explan substr aba bbb palindrom odd length product 3 3 9 exampl 2 input zaaaxbbbi output 9 explan substr aaa bbb palindrom odd length product 3 3 9 constraint 2 slength 105 consist lowercas english letter maximumproductofthelengthoftwopalindromicsubstr
given three integ x z x string equal aa string equal bb z string equal ab want choos possibl none string concacten order form new string new string must contain aaa bbb substr return maximum possibl length new string substr contigu nonempti sequenc charact within string exampl 1 input x 2 5 z 1 output 12 explan concacten string bb aa bb aa bb ab order new string bbaabbaabbab string length 12 show imposs construct string longer length exampl 2 input x 3 2 z 2 output 14 explan concacten string ab ab aa bb aa bb aa order new string ababaabbaabbaa string length 14 show imposs construct string longer length constraint 1 x z 50 constructthelongestnewstr
given array peopl peopl attribut peopl queue necessarili order peoplei hi ki repres ith person height hi exactli ki peopl front height greater equal hi reconstruct return queue repres input array peopl return queue format array queue queuej hj kj attribut jth person queue queue0 person front queue exampl 1 input peopl 704471506152 output 507052614471 explan person 0 height 5 peopl taller height front person 1 height 7 peopl taller height front person 2 height 5 two person taller height front person 0 1 person 3 height 6 one person taller height front person 1 person 4 height 4 four peopl taller height front peopl 0 1 2 3 person 5 height 7 one person taller height front person 1 henc 507052614471 reconstruct queue exampl 2 input peopl 605040322214 output 405022321460 constraint 1 peoplelength 2000 0 hi 106 0 ki peoplelength guarante queue reconstruct queuereconstructionbyheight
alic bob continu game pile stone number pile arrang row pile posit integ number stone pilesi object game end stone alic bob take turn alic start first initi 1 player turn player take stone first x remain pile 1 x 2m set maxm x game continu stone taken assum alic bob play optim return maximum number stone alic get exampl 1 input pile 27944 output 10 explan alic take one pile begin bob take two pile alic take 2 pile alic get 2 4 4 10 pile total alic take two pile begin bob take three pile left case alic get 2 7 9 pile total return 10 sinc larger exampl 2 input pile 12345100 output 104 constraint 1 pileslength 100 1 pilesi 104 stonegameii
given string find longest palindrom subsequ length subsequ sequenc deriv anoth sequenc delet element without chang order remain element exampl 1 input bbbab output 4 explan one possibl longest palindrom subsequ bbbb exampl 2 input cbbd output 2 explan one possibl longest palindrom subsequ bb constraint 1 slength 1000 consist lowercas english letter longestpalindromicsubsequ
given x n binari matrix grid 0 repres sea cell 1 repres land cell move consist walk one land cell anoth adjac 4direct land cell walk boundari grid return number land cell grid walk boundari grid number move exampl 1 input grid 0000101001100000 output 3 explan three 1s enclos 0s one 1 enclos boundari exampl 2 input grid 0110001000100000 output 0 explan 1s either boundari reach boundari constraint gridlength n gridilength 1 n 500 gridij either 0 1 numberofenclav
distinct string string present array given array string arr integ k return kth distinct string present arr fewer k distinct string return empti string note string consid order appear array exampl 1 input arr dbcbca k 2 output explan distinct string arr appear 1st 1st distinct string appear 2nd 2nd distinct string sinc k 2 return exampl 2 input arr aaaaaa k 1 output aaa explan string arr distinct 1st string aaa return exampl 3 input arr aba k 3 output explan distinct string b sinc fewer 3 distinct string return empti string constraint 1 k arrlength 1000 1 arrilength 5 arri consist lowercas english letter kthdistinctstringinanarray
given two 0index integ array num divisor divis score divisorsi number indic j numsj divis divisorsi return integ divisorsi maximum divis score one integ maximum score return minimum exampl 1 input num 47939 divisor 523 output 3 explan divis score everi element divisor divis score divisors0 0 sinc number num divis 5 divis score divisors1 1 sinc nums0 divis 2 divis score divisors2 3 sinc nums2 nums3 nums4 divis 3 sinc divisors2 maximum divis score return exampl 2 input num 20142110 divisor 575 output 5 explan divis score everi element divisor divis score divisors0 2 sinc nums0 nums3 divis 5 divis score divisors1 2 sinc nums1 nums2 divis 7 divis score divisors2 2 sinc nums0 nums3 divis 5 sinc divisors0 divisors1 divisors2 maximum divis score return minimum ie divisors2 exampl 3 input num 12 divisor 1016 output 10 explan divis score everi element divisor divis score divisors0 0 sinc number num divis 10 divis score divisors1 0 sinc number num divis 16 sinc divisors0 divisors1 maximum divis score return minimum ie divisors0 constraint 1 numslength divisorslength 1000 1 numsi divisorsi 109 findthemaximumdivisibilityscor
leetcod compani worker use keycard unlock offic door time worker use keycard secur system save worker name time use system emit alert worker use keycard three time onehour period given list string keynam keytim keynamei keytimei correspond person name time keycard use singl day access time given 24hour time format hhmm 2351 0949 return list uniqu worker name receiv alert frequent keycard use sort name ascend order alphabet notic 1000 1100 consid within onehour period 2251 2352 consid within onehour period exampl 1 input keynam danieldanieldanielluisluisluislui keytim 1000104011000900110013001500 output daniel explan daniel use keycard 3 time onehour period 10001040 1100 exampl 2 input keynam alicealicealicebobbobbobbob keytim 1201120018002100212021302300 output bob explan bob use keycard 3 time onehour period 21002120 2130 constraint 1 keynamelength keytimelength 105 keynamelength keytimelength keytimei format hhmm keynamei keytimei uniqu 1 keynameilength 10 keynamei contain lowercas english letter alertusingsamekeycardthreeormoretimesinaonehourperiod
given 0index binari string two integ minjump maxjump begin stand index 0 equal 0 move index index j follow condit fulfil minjump j mini maxjump slength 1 sj 0 return true reach index slength 1 fals otherwis exampl 1 input 011010 minjump 2 maxjump 3 output true explan first step move index 0 index 3 second step move index 3 index 5 exampl 2 input 01101110 minjump 2 maxjump 3 output fals constraint 2 slength 105 si either 0 1 s0 0 1 minjump maxjump slength jumpgamevii
given string posit integ k select set nonoverlap substr string satisfi follow condit length substr least k substr palindrom return maximum number substr optim select substr contigu sequenc charact within string exampl 1 input abaccdbbd k 3 output 2 explan select substr underlin abaccdbbd aba dbbd palindrom length least k 3 shown find select two valid substr exampl 2 input adbcda k 2 output 0 explan palindrom substr length least 2 string constraint 1 k slength 2000 consist lowercas english letter maximumnumberofnonoverlappingpalindromesubstr
given two posit 0index integ array nums1 nums2 length n sum squar differ array nums1 nums2 defin sum nums1i nums2i2 0 n also given two posit integ k1 k2 modifi element nums1 1 1 k1 time similarli modifi element nums2 1 1 k2 time return minimum sum squar differ modifi array nums1 k1 time modifi array nums2 k2 time note allow modifi array element becom neg integ exampl 1 input nums1 1234 nums2 2102019 k1 0 k2 0 output 579 explan element nums1 nums2 modifi k1 0 k2 0 sum squar differ 1 22 2 102 3 202 4 192 579 exampl 2 input nums1 141012 nums2 5869 k1 1 k2 1 output 43 explan one way obtain minimum sum squar differ increas nums10 increas nums22 minimum sum squar differ 2 52 4 82 10 72 12 92 43 note way obtain minimum sum squar differ way obtain sum smaller 43 constraint n nums1length nums2length 1 n 105 0 nums1i nums2i 105 0 k1 k2 109 minimumsumofsquareddiffer
given integ n return true power three otherwis return fals integ n power three exist integ x n 3x exampl 1 input n 27 output true explan 27 33 exampl 2 input n 0 output fals explan x 3x 0 exampl 3 input n 1 output fals explan x 3x 1 constraint 231 n 231 1 follow could solv without loopsrecurs powerofthre
given array integ num integ k continu subarray call nice k odd number return number nice subarray exampl 1 input num 11211 k 3 output 2 explan subarray 3 odd number 1121 1211 exampl 2 input num 246 k 1 output 0 explan odd number array exampl 3 input num 2221221222 k 2 output 16 constraint 1 numslength 50000 1 numsi 105 1 k numslength countnumberofnicesubarray
given palindrom string lowercas english letter palindrom replac exactli one charact lowercas english letter result string palindrom lexicograph smallest one possibl return result string way replac charact make palindrom return empti string string lexicograph smaller string b length first posit b differ charact strictli smaller correspond charact b exampl abcc lexicograph smaller abcd first posit differ fourth charact c smaller exampl 1 input palindrom abccba output aaccba explan mani way make abccba palindrom zbccba aaccba abacba way aaccba lexicograph smallest exampl 2 input palindrom output explan way replac singl charact make palindrom return empti string constraint 1 palindromelength 1000 palindrom consist lowercas english letter breakapalindrom
given two integ n k two integ array speed effici length n n engin number 1 n speedi efficiencyi repres speed effici ith engin respect choos k differ engin n engin form team maximum perform perform team sum engin speed multipli minimum effici among engin return maximum perform team sinc answer huge number return modulo 109 7 exampl 1 input n 6 speed 2103158 effici 543972 k 2 output 60 explan maximum perform team select engin 2 speed10 efficiency4 engin 5 speed5 efficiency7 perform 10 5 min4 7 60 exampl 2 input n 6 speed 2103158 effici 543972 k 3 output 68 explan exampl first k 3 select engin 1 engin 2 engin 5 get maximum perform team perform 2 10 5 min5 4 7 68 exampl 3 input n 6 speed 2103158 effici 543972 k 4 output 72 constraint 1 k n 105 speedlength n efficiencylength n 1 speedi 105 1 efficiencyi 108 maximumperformanceofateam
one way serial binari tree use preorder travers encount nonnul node record node valu null node record use sentinel valu exampl binari tree serial string 934126 repres null node given string commasepar valu preorder return true correct preorder travers serial binari tree guarante commasepar valu string must either integ charact repres null pointer may assum input format alway valid exampl could never contain two consecut comma 13 note allow reconstruct tree exampl 1 input preorder 934126 output true exampl 2 input preorder 1 output fals exampl 3 input preorder 91 output fals constraint 1 preorderlength 104 preorder consist integ rang 0 100 separ comma verifypreorderserializationofabinarytre
given x n integ matrix point 0index start 0 point want maxim number point get matrix gain point must pick one cell row pick cell coordin r c add pointsrc score howev lose point pick cell far cell pick previou row everi two adjac row r r 1 0 r 1 pick cell coordin r c1 r 1 c2 subtract absc1 c2 score return maximum number point achiev absx defin x x 0 x x 0 exampl 1 input point 123151311 output 9 explan blue cell denot optim cell pick coordin 0 2 1 1 2 0 add 3 5 3 11 score howev must subtract abs2 1 abs1 0 2 score final score 11 2 9 exampl 2 input point 152342 output 11 explan blue cell denot optim cell pick coordin 0 1 1 1 2 0 add 5 3 4 12 score howev must subtract abs1 1 abs1 0 1 score final score 12 1 11 constraint pointslength n pointsrlength 1 n 105 1 n 105 0 pointsrc 105 maximumnumberofpointswithcost
given 0index 2d grid size x n find matrix answer size x n valu cell r c matrix answer calcul follow way let topleftrc number distinct valu topleft diagon cell r c matrix grid let bottomrightrc number distinct valu bottomright diagon cell r c matrix grid answerrc topleftrc bottomrightrc return matrix answer matrix diagon diagon line cell start cell either topmost row leftmost column go bottomright direct reach matrix end cell r1 c1 belong topleft diagon cell r c belong diagon r1 r similarli defin bottomright diagon exampl 1 input grid 123315321 output 110101011 explan 1st diagram denot initi grid 2nd diagram denot grid cell 00 bluecolor cell cell bottomright diagon 3rd diagram denot grid cell 12 redcolor cell cell topleft diagon 4th diagram denot grid cell 11 bluecolor cell cell bottomright diagon redcolor cell cell topleft diagon cell 00 contain 11 bottomright diagon topleft diagon answer 1 0 1 cell 12 contain bottomright diagon 2 topleft diagon answer 0 1 1 cell 11 contain 1 bottomright diagon 1 topleft diagon answer 1 1 0 answer cell similarli calcul exampl 2 input grid 1 output 0 explan cell 00 contain bottomright diagon topleft diagon answer 0 0 0 constraint gridlength n gridilength 1 n gridij 50 differenceofnumberofdistinctvaluesondiagon
given string num repres digit larg integ integ k allow swap two adjac digit integ k time return minimum integ obtain also string exampl 1 input num 4321 k 4 output 1342 explan step obtain minimum integ 4321 4 adjac swap shown exampl 2 input num 100 k 1 output 010 explan ok output lead zero input guarante lead zero exampl 3 input num 36789 k 1000 output 36789 explan keep number without swap constraint 1 numlength 3 104 num consist digit contain lead zero 1 k 109 minimumpossibleintegerafteratmostkadjacentswapsondigit
given integ array num integ k want find subsequ num length k largest sum return subsequ integ array length k subsequ array deriv anoth array delet element without chang order remain element exampl 1 input num 2133 k 2 output 33 explan subsequ largest sum 3 3 6 exampl 2 input num 1234 k 3 output 134 explan subsequ largest sum 1 3 4 6 exampl 3 input num 3433 k 2 output 34 explan subsequ largest sum 3 4 7 anoth possibl subsequ 4 3 constraint 1 numslength 1000 105 numsi 105 1 k numslength findsubsequenceoflengthkwiththelargestsum
given integ n indic n peopl number 0 n 1 also given 0index 2d integ array meet meetingsi xi yi timei indic person xi person yi meet timei person may attend multipl meet time final given integ firstperson person 0 secret initi share secret person firstperson time 0 secret share everi time meet take place person secret formal everi meet person xi secret timei share secret person yi vice versa secret share instantan person may receiv secret share peopl meet within time frame return list peopl secret meet taken place may return answer order exampl 1 input n 6 meet 1252381510 firstperson 1 output 01235 explan time 0 person 0 share secret person 1 time 5 person 1 share secret person 2 time 8 person 2 share secret person 3 time 10 person 1 share secret person 5 thu peopl 0 1 2 3 5 know secret meet exampl 2 input n 4 meet 313122033 firstperson 3 output 013 explan time 0 person 0 share secret person 3 time 2 neither person 1 person 2 know secret time 3 person 3 share secret person 0 person 1 thu peopl 0 1 3 know secret meet exampl 3 input n 5 meet 342121231 firstperson 1 output 01234 explan time 0 person 0 share secret person 1 time 1 person 1 share secret person 2 person 2 share secret person 3 note person 2 share secret time receiv time 2 person 3 share secret person 4 thu peopl 0 1 2 3 4 know secret meet constraint 2 n 105 1 meetingslength 105 meetingsilength 3 0 xi yi n 1 xi yi 1 timei 105 1 firstperson n 1 findallpeoplewithsecret
given array distinct integ candid target integ target return list uniqu combin candid chosen number sum target may return combin order number may chosen candid unlimit number time two combin uniqu frequenc least one chosen number differ test case gener number uniqu combin sum target less 150 combin given input exampl 1 input candid 2367 target 7 output 2237 explan 2 3 candid 2 2 3 7 note 2 use multipl time 7 candid 7 7 two combin exampl 2 input candid 235 target 8 output 222223335 exampl 3 input candid 2 target 1 output constraint 1 candidateslength 30 2 candidatesi 40 element candid distinct 1 target 40 combinationsum
given x n integ matrix return length longest increas path matrix cell either move four direct left right may move diagon move outsid boundari ie wraparound allow exampl 1 input matrix 994668211 output 4 explan longest increas path 1 2 6 9 exampl 2 input matrix 345326221 output 4 explan longest increas path 3 4 5 6 move diagon allow exampl 3 input matrix 1 output 1 constraint matrixlength n matrixilength 1 n 200 0 matrixij 231 1 longestincreasingpathinamatrix
call posit integ special digit distinct given posit integ n return number special integ belong interv 1 n exampl 1 input n 20 output 19 explan integ 1 20 except 11 special thu 19 special integ exampl 2 input n 5 output 5 explan integ 1 5 special exampl 3 input n 135 output 110 explan 110 integ 1 135 special integ special 22 114 131 constraint 1 n 2 109 countspecialinteg
minproduct array equal minimum valu array multipli array sum exampl array 325 minimum valu 2 minproduct 2 325 2 10 20 given array integ num return maximum minproduct nonempti subarray num sinc answer may larg return modulo 109 7 note minproduct maxim perform modulo oper testcas gener maximum minproduct without modulo fit 64bit sign integ subarray contigu part array exampl 1 input num 1232 output 14 explan maximum minproduct achiev subarray 232 minimum valu 2 2 232 2 7 14 exampl 2 input num 23312 output 18 explan maximum minproduct achiev subarray 33 minimum valu 3 3 33 3 6 18 exampl 3 input num 315642 output 60 explan maximum minproduct achiev subarray 564 minimum valu 4 4 564 4 15 60 constraint 1 numslength 105 1 numsi 107 maximumsubarrayminproduct
given array num distinct integ return possibl permut return answer order exampl 1 input num 123 output 123132213231312321 exampl 2 input num 01 output 0110 exampl 3 input num 1 output 1 constraint 1 numslength 6 10 numsi 10 integ num uniqu permut
given two string goal return true becom goal number shift shift consist move leftmost charact rightmost posit exampl abcd bcdea one shift exampl 1 input abcd goal cdeab output true exampl 2 input abcd goal abc output fals constraint 1 slength goallength 100 goal consist lowercas english letter rotatestr
alic bob play game pile stone even number pile arrang row pile posit integ number stone pilesi object game end stone total number stone across pile odd tie alic bob take turn alic start first turn player take entir pile stone either begin end row continu pile left point person stone win assum alic bob play optim return true alic win game fals bob win exampl 1 input pile 5345 output true explan alic start first take first 5 last 5 say take first 5 row becom 3 4 5 bob take 3 board 4 5 alic take 5 win 10 point bob take last 5 board 3 4 alic take 4 win 9 point demonstr take first 5 win move alic return true exampl 2 input pile 3723 output true constraint 2 pileslength 500 pileslength even 1 pilesi 500 sumpilesi odd stonegam
given 0index string array word wordsi consist lowercas english letter one oper select index 0 wordslength wordsi 1 wordsi anagram delet wordsi word keep perform oper long select index satisfi condit return word perform oper shown select indic oper arbitrari order lead result anagram word phrase form rearrang letter differ word phrase use origin letter exactli exampl dacb anagram abdc exampl 1 input word abbabababbaacdcd output abbacd explan one way obtain result array use follow oper sinc words2 bbaa words1 baba anagram choos index 2 delet words2 word abbababacdcd sinc words1 baba words0 abba anagram choos index 1 delet words1 word abbacdcd sinc words2 cd words1 cd anagram choos index 2 delet words2 word abbacd longer perform oper abbacd final answer exampl 2 input word abcd output abcd explan two adjac string word anagram oper perform constraint 1 wordslength 100 1 wordsilength 10 wordsi consist lowercas english letter findresultantarrayafterremovinganagram
given array start start startx starti repres initi posit startx starti 2d space also given array target target targetx targeti repres target posit targetx targeti cost go posit x1 y1 posit space x2 y2 x2 x1 y2 y1 also special road given 2d array specialroad specialroadsi x1i y1i x2i y2i costi indic ith special road take x1i y1i x2i y2i cost equal costi use special road number time return minimum cost requir go startx starti targetx targeti exampl 1 input start 11 target 45 specialroad 1233234451 output 5 explan optim path 11 45 follow 11 12 move cost 1 1 2 1 1 12 33 move use first special edg cost 2 33 34 move cost 3 3 4 3 1 34 45 move use second special edg cost 1 total cost 1 2 1 1 5 shown achiev smaller total cost 5 exampl 2 input start 32 target 57 specialroad 323443355534566 output 7 explan optim use special edg go directli start end posit cost 5 3 7 2 7 constraint startlength targetlength 2 1 startx targetx 105 1 starti targeti 105 1 specialroadslength 200 specialroadsilength 5 startx x1i x2i targetx starti y1i y2i targeti 1 costi 105 minimumcostofapathwithspecialroad
n job everi job schedul done starttimei endtimei obtain profit profiti your given starttim endtim profit array return maximum profit take two job subset overlap time rang choos job end time x abl start anoth job start time x exampl 1 input starttim 1233 endtim 3456 profit 50104070 output 120 explan subset chosen first fourth job time rang 1336 get profit 120 50 70 exampl 2 input starttim 12346 endtim 351069 profit 20201007060 output 150 explan subset chosen first fourth fifth job profit obtain 150 20 70 60 exampl 3 input starttim 111 endtim 234 profit 564 output 6 constraint 1 starttimelength endtimelength profitlength 5 104 1 starttimei endtimei 109 1 profiti 104 maximumprofitinjobschedul
given 0index string even length n string consist exactli n 2 open bracket n 2 close bracket string call balanc empti string written ab b balanc string written c c balanc string may swap bracket two indic number time return minimum number swap make balanc exampl 1 input output 1 explan make string balanc swap index 0 index 3 result string exampl 2 input output 2 explan follow make string balanc swap index 0 index 4 swap index 1 index 5 result string exampl 3 input output 0 explan string alreadi balanc constraint n slength 2 n 106 n even si either number open bracket equal n 2 number close bracket equal n 2 minimumnumberofswapstomakethestringbalanc
given two number hour minut return smaller angl degre form hour minut hand answer within 105 actual valu accept correct exampl 1 input hour 12 minut 30 output 165 exampl 2 input hour 3 minut 30 output 75 exampl 3 input hour 3 minut 15 output 75 constraint 1 hour 12 0 minut 59 anglebetweenhandsofaclock
given integ array arr target valu target return integ valu chang integ larger valu given array equal valu sum array get close possibl absolut differ target case tie return minimum integ notic answer neccesarilli number arr exampl 1 input arr 493 target 10 output 3 explan use 3 arr convert 3 3 3 sum 9 that optim answer exampl 2 input arr 235 target 10 output 5 exampl 3 input arr 6086425176272492129620204 target 56803 output 11361 constraint 1 arrlength 104 1 arri target 105 sumofmutatedarrayclosesttotarget
given root binari search tree integ k return true exist two element bst sum equal k fals otherwis exampl 1 input root 53624null7 k 9 output true exampl 2 input root 53624null7 k 28 output fals constraint number node tree rang 1 104 104 nodev 104 root guarante valid binari search tree 105 k 105 twosumivinputisabst
write algorithm determin number n happi happi number number defin follow process start posit integ replac number sum squar digit repeat process number equal 1 stay loop endlessli cycl includ 1 number process end 1 happi return true n happi number fals exampl 1 input n 19 output true explan 12 92 82 82 22 68 62 82 100 12 02 02 1 exampl 2 input n 2 output fals constraint 1 n 231 1 happynumb
given integ array num integ k return number nonempti subarray sum divis k subarray contigu part array exampl 1 input num 450231 k 5 output 7 explan 7 subarray sum divis k 5 4 5 0 2 3 1 5 5 0 5 0 2 3 0 0 2 3 2 3 exampl 2 input num 5 k 9 output 0 constraint 1 numslength 3 104 104 numsi 104 2 k 104 subarraysumsdivisiblebyk
given 0index integ array num length n perform follow oper mani time want pick index ’ pick pick prime p strictli less numsi subtract p numsi return true make num strictli increas array use oper fals otherwis strictli increas array array whose element strictli greater preced element exampl 1 input num 49610 output true explan first oper pick 0 p 3 subtract 3 nums0 num becom 19610 second oper 1 p 7 subtract 7 nums1 num becom equal 12610 second oper num sort strictli increas order answer true exampl 2 input num 681112 output true explan initi num sort strictli increas order dont need make oper exampl 3 input num 583 output fals explan proven way perform oper make num sort strictli increas order answer fals constraint 1 numslength 1000 1 numsi 1000 numslength n primesubtractionoper
sql schema tabl employe column name type id int name varchar salari int departmentid int id primari key column tabl departmentid foreign key id depart tabl row tabl indic id name salari employe also contain id depart tabl depart column name type id int name varchar id primari key column tabl row tabl indic id depart name compani execut interest see earn money compani depart high earner depart employe salari top three uniqu salari depart write sql queri find employe high earner depart return result tabl order queri result format follow exampl exampl 1 input employe tabl id name salari departmentid 1 joe 85000 1 2 henri 80000 2 3 sam 60000 2 4 max 90000 1 5 janet 69000 1 6 randi 85000 1 7 70000 1 depart tabl id name 1 2 sale output depart employe salari max 90000 joe 85000 randi 85000 70000 sale henri 80000 sale sam 60000 explan depart max earn highest uniqu salari randi joe earn secondhighest uniqu salari earn thirdhighest uniqu salari sale depart henri earn highest salari sam earn secondhighest salari thirdhighest salari two employe departmenttopthreesalari
undirect star graph consist n node label 1 n star graph graph one center node exactli n 1 edg connect center node everi node given 2d integ array edg edgesi ui vi indic edg node ui vi return center given star graph exampl 1 input edg 122342 output 2 explan shown figur node 2 connect everi node 2 center exampl 2 input edg 12511314 output 1 constraint 3 n 105 edgeslength n 1 edgesilength 2 1 ui vi n ui vi given edg repres valid star graph findcenterofstargraph
given even integ n initi permut perm size n permi 0index one oper creat new array arr 2 0 arri permi 2 2 1 arri permn 2 1 2 assign arr perm return minimum nonzero number oper need perform perm return permut initi valu exampl 1 input n 2 output 1 explan perm 01 initi 1st oper perm 01 take 1 oper exampl 2 input n 4 output 2 explan perm 0123 initi 1st oper perm 0213 2nd oper perm 0123 take 2 oper exampl 3 input n 6 output 4 constraint 2 n 1000 n even minimumnumberofoperationstoreinitializeapermut
given integ num know danni mittal sneakili remap one 10 possibl digit 0 9 anoth digit return differ maximum minimum valu danni make remap exactli one digit num note danni remap digit d1 anoth digit d2 danni replac occurr d1 num d2 danni remap digit case num chang danni remap differ digit obtain minimum maximum valu respect result number remap contain lead zero mention danni mittal congratul top 10 weekli contest 326 exampl 1 input num 11891 output 99009 explan achiev maximum valu danni remap digit 1 digit 9 yield 99899 achiev minimum valu danni remap digit 1 digit 0 yield 890 differ two number 99009 exampl 2 input num 90 output 99 explan maximum valu return function 99 0 replac 9 minimum valu return function 0 9 replac 0 thu return 99 constraint 1 num 108 maximumdifferencebyremappingadigit
observ n 6side dice roll face number 1 6 n observ went miss observ roll fortun also calcul averag valu n roll given integ array roll length rollsi valu ith observ also given two integ mean n return array length n contain miss observ averag valu n roll exactli mean multipl valid answer return array exist return empti array averag valu set k number sum number divid k note mean integ sum n roll divis n exampl 1 input roll 3243 mean 4 n 2 output 66 explan mean n roll 3 2 4 3 6 6 6 4 exampl 2 input roll 156 mean 3 n 4 output 2322 explan mean n roll 1 5 6 2 3 2 2 7 3 exampl 3 input roll 1234 mean 6 n 4 output explan imposs mean 6 matter 4 miss roll constraint rollslength 1 n 105 1 rollsi mean 6 findmissingobserv
given two string goal convert k move less ith 1 k move choos index j 1index 1 j slength j chosen previou move shift charact index time noth shift charact mean replac next letter alphabet wrap around z becom shift charact mean appli shift oper time rememb index j pick return true possibl convert k move otherwis return fals exampl 1 input input ouput k 9 output true explan 6th move shift 6 time get 7th move shift n get u exampl 2 input abc bcd k 10 output fals explan need shift charact one time convert shift b 1st move howev way shift charact remain move obtain exampl 3 input aab bbb k 27 output true explan 1st move shift first 1 time get b 27th move shift second 27 time get b constraint 1 slength tlength 105 0 k 109 contain lowercas english letter canconvertstringinkmov
given wordlist want implement spellcheck convert queri word correct word given queri word spell checker handl two categori spell mistak capit queri match word wordlist caseinsensit queri word return case case wordlist exampl wordlist yellow queri yellow correct yellow exampl wordlist yellow queri yellow correct yellow exampl wordlist yellow queri yellow correct yellow vowel error replac vowel e u queri word vowel individu match word wordlist caseinsensit queri word return case match wordlist exampl wordlist yellow queri yollow correct yellow exampl wordlist yellow queri yeellow correct match exampl wordlist yellow queri yllw correct match addit spell checker oper follow preced rule queri exactli match word wordlist casesensit return word back queri match word capitl return first match wordlist queri match word vowel error return first match wordlist queri match wordlist return empti string given queri return list word answer answeri correct word queri queriesi exampl 1 input wordlist kitekiteharehar queri kitekitekitehareharehearhearketikeetketo output kitekitekitehareharekitekit exampl 2 input wordlist yellow queri yellow output yellow constraint 1 wordlistlength querieslength 5000 1 wordlistilength queriesilength 7 wordlisti queriesi consist english letter vowelspellcheck
given array string length word one move swap two even index charact two odd index charact string wordsi two string wordsi wordsj specialequival number move wordsi wordsj exampl wordsi zzxi wordsj xyzz specialequival may make move zzxi xzzi xyzz group specialequival string word nonempti subset word everi pair string group special equival group largest size possibl ie string wordsi group wordsi specialequival everi string group return number group specialequival string word exampl 1 input word abcdcdabcbadxyzzzzxyzzyx output 3 explan one group abcd cdab cbad sinc pairwis special equival none string pairwis special equival two group xyzz zzxi zzyx note particular zzxi special equival zzyx exampl 2 input word abcacbbacbcacabcba output 3 constraint 1 wordslength 1000 1 wordsilength 20 wordsi consist lowercas english letter string length groupsofspecialequivalentstr
given 2d grid size x n integ k need shift grid k time one shift oper element gridij move gridij 1 element gridin 1 move gridi 10 element gridm 1n 1 move grid00 return 2d grid appli shift oper k time exampl 1 input grid 123456789 k 1 output 912345678 exampl 2 input grid 3819197254611101202113 k 4 output 1202113381919725461110 exampl 3 input grid 123456789 k 9 output 123456789 constraint gridlength n gridilength 1 50 1 n 50 1000 gridij 1000 0 k 100 shift2dgrid
given integ numrow return first numrow pascal triangl pascal triangl number sum two number directli shown exampl 1 input numrow 5 output 111121133114641 exampl 2 input numrow 1 output 1 constraint 1 numrow 30 pascalstriangl
ramp integ array num pair j j numsi numsj width ramp j given integ array num return maximum width ramp num ramp num return 0 exampl 1 input num 608215 output 4 explan maximum width ramp achiev j 1 5 nums1 0 nums5 5 exampl 2 input num 9810194041 output 7 explan maximum width ramp achiev j 2 9 nums2 1 nums9 1 constraint 2 numslength 5 104 0 numsi 5 104 maximumwidthramp
given n differ type sticker sticker lowercas english word would like spell given string target cut individu letter collect sticker rearrang use sticker want infinit quantiti sticker return minimum number sticker need spell target task imposs return 1 note test case word chosen randomli 1000 common us english word target chosen concaten two random word exampl 1 input sticker withexamplesci target thehat output 3 explan use 2 sticker 1 exampl sticker cut rearrang letter sticker form target thehat also minimum number sticker necessari form target string exampl 2 input sticker noticeposs target basicbas output 1 explan form target basicbas cut letter given sticker constraint n stickerslength 1 n 50 1 stickersilength 10 1 targetlength 15 stickersi target consist lowercas english letter stickerstospellword
0index 8 x 8 chessboard multipl black queen ad one white king given 2d integ array queen queensi xqueeni yqueeni repres posit ith black queen chessboard also given integ array king length 2 king xking yking repres posit white king return coordin black queen directli attack king may return answer order exampl 1 input queen 011040043324 king 00 output 011033 explan diagram show three queen directli attack king three queen attack king ie mark red dash exampl 2 input queen 00112234354445 king 33 output 223444 explan diagram show three queen directli attack king three queen attack king ie mark red dash constraint 1 queenslength 64 queensilength kinglength 2 0 xqueeni yqueeni xking yking 8 given posit uniqu queensthatcanattackthek
scenic locat repres name attract score name uniqu string among locat score integ locat rank best worst higher score better locat score two locat equal locat lexicograph smaller name better build system track rank locat system initi start locat support ad scenic locat one time queri ith best locat locat alreadi ad number time system queri includ current queri exampl system queri 4th time return 4th best locat locat alreadi ad note test data gener time number queri exceed number locat ad system implement sortrack class sortrack initi tracker system void addstr name int score add scenic locat name score system string get queri return ith best locat number time method invok includ invoc exampl 1 input sortrack add add get add get add get add get add get get bradford 2 branford 3 alp 2 orland 2 orlando 3 alpin 2 output null null null branford null alp null bradford null bradford null bradford orland explan sortrack tracker new sortrack initi tracker system trackeraddbradford 2 add locat namebradford score2 system trackeraddbranford 3 add locat namebranford score3 system trackerget sort locat best worst branford bradford note branford preced bradford due higher score 3 2 1st time get call return best locat branford trackeraddalp 2 add locat namealp score2 system trackerget sort locat branford alp bradford note alp preced bradford even though score 2 alp lexicograph smaller bradford return 2nd best locat alp 2nd time get call trackeraddorland 2 add locat nameorland score2 system trackerget sort locat branford alp bradford orland return bradford 3rd time get call trackeraddorlando 3 add locat nameorlando score3 system trackerget sort locat branford orlando alp bradford orland return bradford trackeraddalpin 2 add locat namealpin score2 system trackerget sort locat branford orlando alpin alp bradford orland return bradford trackerget sort locat branford orlando alpin alp bradford orland return orland constraint name consist lowercas english letter uniqu among locat 1 namelength 10 1 score 105 time number call get exceed number call add 4 104 call total made add get sequentiallyordinalranktrack
given binari tree find lowest common ancestor lca two given node tree accord definit lca wikipedia “ lowest common ancestor defin two node p q lowest node p q descend allow node descend ” exampl 1 input root 3516208nullnull74 p 5 q 1 output 3 explan lca node 5 1 3 exampl 2 input root 3516208nullnull74 p 5 q 4 output 5 explan lca node 5 4 5 sinc node descend accord lca definit exampl 3 input root 12 p 1 q 2 output 1 constraint number node tree rang 2 105 109 nodev 109 nodev uniqu p q p q exist tree lowestcommonancestorofabinarytre
given integ array num uniqu element return possibl subset power set solut set must contain duplic subset return solut order exampl 1 input num 123 output 121231323123 exampl 2 input num 0 output 0 constraint 1 numslength 10 10 numsi 10 number num uniqu subset
given string return true good string fals otherwis string good charact appear number occurr ie frequenc exampl 1 input abacbc output true explan charact appear b c charact occur 2 time exampl 2 input aaabb output fals explan charact appear b occur 3 time b occur 2 time number time constraint 1 slength 1000 consist lowercas english letter checkifallcharactershaveequalnumberofoccurr
pangram sentenc everi letter english alphabet appear least given string sentenc contain lowercas english letter return true sentenc pangram fals otherwis exampl 1 input sentenc thequickbrownfoxjumpsoverthelazydog output true explan sentenc contain least one everi letter english alphabet exampl 2 input sentenc leetcod output fals constraint 1 sentencelength 1000 sentenc consist lowercas english letter checkifthesentenceispangram
given x n 2d binari grid grid repres map 1s land 0s water return number island island surround water form connect adjac land horizont vertic may assum four edg grid surround water exampl 1 input grid 11110 11010 11000 00000 output 1 exampl 2 input grid 11000 11000 00100 00011 output 3 constraint gridlength n gridilength 1 n 300 gridij 0 1 numberofisland
sql schema tabl custom column name type customerid int productkey int primari key tabl may contain duplic customerid null productkey foreign key product tabl tabl product column name type productkey int productkey primari key column tabl write sql queri report custom id custom tabl bought product product tabl return result tabl order queri result format follow exampl exampl 1 input custom tabl customerid productkey 1 5 2 6 3 5 3 6 1 6 product tabl productkey 5 6 output customerid 1 3 explan custom bought product 5 6 custom id 1 3 customerswhoboughtallproduct
given rectangular pizza repres row x col matrix contain follow charact appl empti cell given integ k cut pizza k piec use k1 cut cut choos direct vertic horizont choos cut posit cell boundari cut pizza two piec cut pizza vertic give left part pizza person cut pizza horizont give upper part pizza person give last piec pizza last person return number way cut pizza piec contain least one appl sinc answer huge number return modulo 109 7 exampl 1 input pizza aaaa k 3 output 3 explan figur show three way cut pizza note piec must contain least one appl exampl 2 input pizza aaa k 3 output 1 exampl 3 input pizza aa k 1 output 1 constraint 1 row col 50 row pizzalength col pizzailength 1 k 10 pizza consist charact numberofwaysofcuttingapizza
given string return true palindrom delet one charact exampl 1 input aba output true exampl 2 input abca output true explan could delet charact c exampl 3 input abc output fals constraint 1 slength 105 consist lowercas english letter validpalindromeii
given x n integ array grid gridij could 1 repres start squar exactli one start squar 2 repres end squar exactli one end squar 0 repres empti squar walk 1 repres obstacl walk return number 4direct walk start squar end squar walk everi nonobstacl squar exactli exampl 1 input grid 100000000021 output 2 explan follow two path 1 0001020313121110202122 2 0010202111010203131222 exampl 2 input grid 100000000002 output 4 explan follow four path 1 000102031312111020212223 2 000111102021221202031323 3 001020212212110102031323 4 001020211101020313122223 exampl 3 input grid 0120 output 0 explan path walk everi empti squar exactli note start end squar anywher grid constraint gridlength n gridilength 1 n 20 1 n 20 1 gridij 2 exactli one start cell one end cell uniquepathsiii
given 2d integ array rang rangesi starti endi denot integ starti endi inclus contain ith rang split rang two possibl empti group rang belong exactli one group two overlap rang must belong group two rang said overlap exist least one integ present rang exampl 1 3 2 5 overlap 2 3 occur rang return total number way split rang two group sinc answer may larg return modulo 109 7 exampl 1 input rang 610515 output 2 explan two rang overlap must group thu two possibl way put rang togeth group 1 put rang togeth group 2 exampl 2 input rang 1310202548 output 4 explan rang 13 25 overlap must group rang 25 48 also overlap must also group thu four possibl way group rang group 1 rang group 2 rang 13 25 48 group 1 1020 group 2 rang 13 25 48 group 2 1020 group 1 constraint 1 rangeslength 105 rangesilength 2 0 starti endi 109 countwaystogroupoverlappingrang
given nonneg integ c decid whether therer two integ b a2 b2 c exampl 1 input c 5 output true explan 1 1 2 2 5 exampl 2 input c 3 output fals constraint 0 c 231 1 sumofsquarenumb
given k ident egg access build n floor label 1 n know exist floor f 0 f n egg drop floor higher f break egg drop floor f break move may take unbroken egg drop floor x 1 x n egg break longer use howev egg break may reus futur move return minimum number move need determin certainti valu f exampl 1 input k 1 n 2 output 2 explan drop egg floor 1 break know f 0 otherwis drop egg floor 2 break know f 1 break know f 2 henc need minimum 2 move determin certainti valu f exampl 2 input k 2 n 6 output 3 exampl 3 input k 3 n 14 output 4 constraint 1 k 100 1 n 104 supereggdrop
given array integ num integ threshold choos posit integ divisor divid array sum divis result find smallest divisor result mention less equal threshold result divis round nearest integ greater equal element exampl 73 3 102 5 test case gener answer exampl 1 input num 1259 threshold 6 output 5 explan get sum 17 1259 divisor 1 divisor 4 get sum 7 1123 divisor 5 sum 5 1112 exampl 2 input num 442233111 threshold 5 output 44 constraint 1 numslength 5 104 1 numsi 106 numslength threshold 106 findthesmallestdivisorgivenathreshold
matlab handi function call reshap reshap x n matrix new one differ size r x c keep origin data given x n matrix mat two integ r c repres number row number column want reshap matrix reshap matrix fill element origin matrix rowtravers order reshap oper given paramet possibl legal output new reshap matrix otherwis output origin matrix exampl 1 input mat 1234 r 1 c 4 output 1234 exampl 2 input mat 1234 r 2 c 4 output 1234 constraint matlength n matilength 1 n 100 1000 matij 1000 1 r c 300 reshapethematrix
sql schema tabl employe column name type employeeid int name varchar employeeid primari key tabl row tabl indic name employe whose id employeeid tabl salari column name type employeeid int salari int employeeid primari key tabl row tabl indic salari employe whose id employeeid write sql queri report id employe miss inform inform employe miss employe name miss employe salari miss return result tabl order employeeid ascend order queri result format follow exampl exampl 1 input employe tabl employeeid name 2 crew 4 5 kristian salari tabl employeeid salari 5 76071 1 22517 4 63539 output employeeid 1 2 explan employe 1 2 4 5 work compani name employe 1 miss salari employe 2 miss employeeswithmissinginform
given x n grid charact board string word return true word exist grid word construct letter sequenti adjac cell adjac cell horizont vertic neighbor letter cell may use exampl 1 input board abcesfcsade word abc output true exampl 2 input board abcesfcsade word see output true exampl 3 input board abcesfcsade word abcb output fals constraint boardlength n boardilength 1 n 6 1 wordlength 15 board word consist lowercas uppercas english letter follow could use search prune make solut faster larger board wordsearch
implement program use calendar add new event ad event caus doubl book doubl book happen two event nonempti intersect ie moment common event event repres pair integ start end repres book halfopen interv start end rang real number x start x end implement mycalendar class mycalendar initi calendar object boolean bookint start int end return true event ad calendar success without caus doubl book otherwis return fals add event calendar exampl 1 input mycalendar book book book 10 20 15 25 20 30 output null true fals true explan mycalendar mycalendar new mycalendar mycalendarbook10 20 return true mycalendarbook15 25 return fals book time 15 alreadi book anoth event mycalendarbook20 30 return true event book first event take everi time less 20 includ 20 constraint 0 start end 109 1000 call made book mycalendari
0index array deriv length n deriv comput bitwis xor ⊕ adjac valu binari array origin length n specif index rang 0 n 1 n 1 derivedi originali ⊕ original0 otherwis derivedi originali ⊕ originali 1 given array deriv task determin whether exist valid binari array origin could form deriv return true array exist fals otherwis binari array array contain 0s 1s exampl 1 input deriv 110 output true explan valid origin array give deriv 010 derived0 original0 ⊕ original1 0 ⊕ 1 1 derived1 original1 ⊕ original2 1 ⊕ 0 1 derived2 original2 ⊕ original0 0 ⊕ 0 0 exampl 2 input deriv 11 output true explan valid origin array give deriv 01 derived0 original0 ⊕ original1 1 derived1 original1 ⊕ original0 1 exampl 3 input deriv 10 output fals explan valid origin array give deriv constraint n derivedlength 1 n 105 valu deriv either 0s 1s neighboringbitwisexor
profession robber plan rob hous along street hous certain amount money stash constraint stop rob adjac hous secur system connect automat contact polic two adjac hous broken night given integ array num repres amount money hous return maximum amount money rob tonight without alert polic exampl 1 input num 1231 output 4 explan rob hous 1 money 1 rob hous 3 money 3 total amount rob 1 3 4 exampl 2 input num 27931 output 12 explan rob hous 1 money 2 rob hous 3 money 9 rob hous 5 money 1 total amount rob 2 9 1 12 constraint 1 numslength 100 0 numsi 400 houserobb
given nari tree return level order travers node valu narytre input serial repres level order travers group children separ null valu see exampl exampl 1 input root 1null324null56 output 132456 exampl 2 input root 1null2345nullnull67null8null910nullnull11null12null13nullnull14 output 1234567891011121314 constraint height nari tree less equal 1000 total number node 0 104 narytreelevelordertravers
alic bob continu game stone row n stone stone associ valu given integ array stone stonesi valu ith stone alic bob take turn alic start first turn player may remov stone stone player remov stone lose sum valu remov stone divis 3 bob win automat remain stone even alic turn assum player play optim return true alic win fals bob win exampl 1 input stone 21 output true explan game play follow turn 1 alic remov either stone turn 2 bob remov remain stone sum remov stone 1 2 3 divis 3 therefor bob lose alic win game exampl 2 input stone 2 output fals explan alic remov stone sum valu remov stone 2 sinc stone remov sum valu divis 3 bob win game exampl 3 input stone 51243 output fals explan bob alway win one possibl way bob win shown turn 1 alic remov second stone valu 1 sum remov stone 1 turn 2 bob remov fifth stone valu 3 sum remov stone 1 3 4 turn 3 alic remov fourth stone valu 4 sum remov stone 1 3 4 8 turn 4 bob remov third stone valu 2 sum remov stone 1 3 4 2 10 turn 5 alic remov first stone valu 5 sum remov stone 1 3 4 2 5 15 alic lose game sum remov stone 15 divis 3 bob win game constraint 1 stoneslength 105 1 stonesi 104 stonegameix
design simplifi version twitter user post tweet followunfollow anoth user abl see 10 recent tweet user news feed implement twitter class twitter initi twitter object void posttweetint userid int tweetid compos new tweet id tweetid user userid call function made uniqu tweetid listinteg getnewsfeedint userid retriev 10 recent tweet id user news feed item news feed must post user user follow user themself tweet must order recent least recent void followint followerid int followeeid user id followerid start follow user id followeeid void unfollowint followerid int followeeid user id followerid start unfollow user id followeeid exampl 1 input twitter posttweet getnewsfe follow posttweet getnewsfe unfollow getnewsfe 1 5 1 1 2 2 6 1 1 2 1 output null null 5 null null 6 5 null 5 explan twitter twitter new twitter twitterposttweet1 5 user 1 post new tweet id 5 twittergetnewsfeed1 user 1s news feed return list 1 tweet id 5 return 5 twitterfollow1 2 user 1 follow user 2 twitterposttweet2 6 user 2 post new tweet id 6 twittergetnewsfeed1 user 1s news feed return list 2 tweet id 6 5 tweet id 6 preced tweet id 5 post tweet id 5 twitterunfollow1 2 user 1 unfollow user 2 twittergetnewsfeed1 user 1s news feed return list 1 tweet id 5 sinc user 1 longer follow user 2 constraint 1 userid followerid followeeid 500 0 tweetid 104 tweet uniqu id 3 104 call made posttweet getnewsfe follow unfollow designtwitt
given array n pair pair pairsi lefti righti lefti righti pair p2 c follow pair p1 b b c chain pair form fashion return length longest chain form need use given interv select pair order exampl 1 input pair 122334 output 2 explan longest chain 12 34 exampl 2 input pair 127845 output 3 explan longest chain 12 45 78 constraint n pairslength 1 n 1000 1000 lefti righti 1000 maximumlengthofpairchain
authent system work authent token session user receiv new authent token expir timetol second currenttim token renew expiri time extend expir timetol second potenti differ currenttim implement authenticationmanag class authenticationmanagerint timetol construct authenticationmanag set timetol generatestr tokenid int currenttim gener new token given tokenid given currenttim second renewstr tokenid int currenttim renew unexpir token given tokenid given currenttim second unexpir token given tokenid request ignor noth happen countunexpiredtokensint currenttim return number unexpir token given currenttim note token expir time anoth action happen time renew countunexpiredtoken expir take place action exampl 1 input authenticationmanag renew gener countunexpiredtoken gener renew renew countunexpiredtoken 5 aaa 1 aaa 2 6 bbb 7 aaa 8 bbb 10 15 output null null null 1 null null null 0 explan authenticationmanag authenticationmanag new authenticationmanager5 construct authenticationmanag timetol 5 second authenticationmanagerrenewaaa 1 token exist tokenid aaa time 1 noth happen authenticationmanagergenerateaaa 2 gener new token tokenid aaa time 2 authenticationmanagercountunexpiredtokens6 token tokenid aaa unexpir one time 6 return 1 authenticationmanagergeneratebbb 7 gener new token tokenid bbb time 7 authenticationmanagerrenewaaa 8 token tokenid aaa expir time 7 8 7 time 8 renew request ignor noth happen authenticationmanagerrenewbbb 10 token tokenid bbb unexpir time 10 renew request fulfil token expir time 15 authenticationmanagercountunexpiredtokens15 token tokenid bbb expir time 15 token tokenid aaa expir time 7 current token unexpir return 0 constraint 1 timetol 108 1 currenttim 108 1 tokenidlength 5 tokenid consist lowercas letter call gener contain uniqu valu tokenid valu currenttim across function call strictli increas 2000 call made function combin designauthenticationmanag
given two binari search tree root1 root2 return list contain integ tree sort ascend order exampl 1 input root1 214 root2 103 output 011234 exampl 2 input root1 1null8 root2 81 output 1188 constraint number node tree rang 0 5000 105 nodev 105 allelementsintwobinarysearchtre
given list nonneg integ num arrang form largest number return sinc result may larg need return string instead integ exampl 1 input num 102 output 210 exampl 2 input num 3303459 output 9534330 constraint 1 numslength 100 0 numsi 109 largestnumb
given integ num swap two digit get maximum valu number return maximum valu number get exampl 1 input num 2736 output 7236 explan swap number 2 number 7 exampl 2 input num 9973 output 9973 explan swap constraint 0 num 108 maximumswap
given express express e 8 5 evalu map e 1 given term evalvar e evalint 1 return list token repres simplifi express 1a14 express altern chunk symbol space separ chunk symbol chunk either express parenthes variabl nonneg integ variabl string lowercas letter includ digit note variabl multipl letter note variabl never lead coeffici unari oper like 2x x express evalu usual order bracket first multipl addit subtract exampl express 1 2 3 answer 7 format output follow term free variabl nonzero coeffici write free variabl within term sort order lexicograph exampl would never write term like bac abc term degre equal number free variabl multipli count multipl write largest degre term answer first break tie lexicograph order ignor lead coeffici term exampl aabc degre 4 lead coeffici term place directli left asterisk separ variabl exist lead coeffici 1 still print exampl wellformat answer 2aaa 3aab 3bb 4a 5c 6 term includ constant term coeffici 0 includ exampl express 0 output note may assum given express alway valid intermedi result rang 231 231 1 exampl 1 input express e 8 5 evalvar e evalint 1 output 1a14 exampl 2 input express e 8 temperatur pressur evalvar e temperatur evalint 1 12 output 1pressure5 exampl 3 input express e 8 e 8 evalvar evalint output 1ee64 constraint 1 expressionlength 250 express consist lowercas english letter digit express contain lead trail space token express separ singl space 0 evalvarslength 100 1 evalvarsilength 20 evalvarsi consist lowercas english letter evalintslength evalvarslength 100 evalintsi 100 basiccalculatoriv
given 0index integ array num concaten two number number form concaten numer exampl concaten 15 49 1549 concaten valu num initi equal 0 perform oper num becom empti exist one number num pick first element last element num respect add valu concaten concaten valu num delet first last element num one element exist add valu concaten valu num delet return concaten valu num exampl 1 input num 75224 output 596 explan perform oper num 75224 concaten valu 0 first oper pick first element 7 last element 4 concaten 74 add concaten valu becom equal 74 delet num num becom equal 522 second oper pick first element 52 last element 2 concaten 522 add concaten valu becom equal 596 delet num num becom empti sinc concaten valu 596 answer 596 exampl 2 input num 51413812 output 673 explan perform oper num 51413812 concaten valu 0 first oper pick first element 5 last element 12 concaten 512 add concaten valu becom equal 512 delet num num becom equal 14138 second oper pick first element 14 last element 8 concaten 148 add concaten valu becom equal 660 delet num num becom equal 13 third oper num one element pick 13 add concaten valu becom equal 673 delet num num becom empti sinc concaten valu 673 answer 673 constraint 1 numslength 1000 1 numsi 104 findthearrayconcatenationvalu
bag consist item item number 1 0 1 written given four nonneg integ numon numzero numnegon k bag initi contain numon item 1s written numzero item 0s written numnegon item 1s written want pick exactli k item among avail item return maximum possibl sum number written item exampl 1 input numon 3 numzero 2 numnegon 0 k 2 output 2 explan bag item number written 1 1 1 0 0 take 2 item 1 written get sum total 2 proven 2 maximum possibl sum exampl 2 input numon 3 numzero 2 numnegon 0 k 4 output 3 explan bag item number written 1 1 1 0 0 take 3 item 1 written 1 item 0 written get sum total 3 proven 3 maximum possibl sum constraint 0 numon numzero numnegon 50 0 k numon numzero numnegon kitemswiththemaximumsum
given integ n indic n cours label 1 n also given 2d integ array relat relationsj prevcoursej nextcoursej denot cours prevcoursej complet cours nextcoursej prerequisit relationship furthermor given 0index integ array time timei denot mani month take complet i1th cours must find minimum number month need complet cours follow rule may start take cours time prerequisit met number cours taken time return minimum number month need complet cours note test case gener possibl complet everi cours ie graph direct acycl graph exampl 1 input n 3 relat 1323 time 325 output 8 explan figur repres given graph time requir complet cours start cours 1 cours 2 simultan month 0 cours 1 take 3 month cours 2 take 2 month complet respect thu earliest time start cours 3 month 3 total time requir 3 5 8 month exampl 2 input n 5 relat 1525353445 time 12345 output 12 explan figur repres given graph time requir complet cours start cours 1 2 3 month 0 complet 1 2 3 month respect cours 4 taken cours 3 complet ie 3 month complet 3 4 7 month cours 5 taken cours 1 2 3 4 complet ie max1237 7 month thu minimum time need complet cours 7 5 12 month constraint 1 n 5 104 0 relationslength minn n 1 2 5 104 relationsjlength 2 1 prevcoursej nextcoursej n prevcoursej nextcoursej pair prevcoursej nextcoursej uniqu timelength n 1 timei 104 given graph direct acycl graph parallelcoursesiii
given root binari tree return level order travers node valu ie left right level level exampl 1 input root 3920nullnull157 output 3920157 exampl 2 input root 1 output 1 exampl 3 input root output constraint number node tree rang 0 2000 1000 nodev 1000 binarytreelevelordertravers
given triangl array return minimum path sum top bottom step may move adjac number row formal index current row may move either index index 1 next row exampl 1 input triangl 2346574183 output 11 explan triangl look like 2 3 4 6 5 7 4 1 8 3 minimum path sum top bottom 2 3 5 1 11 underlin exampl 2 input triangl 10 output 10 constraint 1 trianglelength 200 triangle0length 1 triangleilength trianglei 1length 1 104 triangleij 104 follow could use extra space n total number row triangl triangl
given integ array num contain distinct posit integ find return number array neither minimum maximum valu array 1 number return select integ exampl 1 input num 3214 output 2 explan exampl minimum valu 1 maximum valu 4 therefor either 2 3 valid answer exampl 2 input num 12 output 1 explan sinc number num neither maximum minimum select number satisfi given condit therefor answer exampl 3 input num 213 output 2 explan sinc 2 neither maximum minimum valu num valid answer constraint 1 numslength 100 1 numsi 100 valu num distinct neitherminimumnormaximum
integ array num invers pair pair integ j 0 j numslength numsi numsj given two integ n k return number differ array consist number 1 n exactli k invers pair sinc answer huge return modulo 109 7 exampl 1 input n 3 k 0 output 1 explan array 123 consist number 1 3 exactli 0 invers pair exampl 2 input n 3 k 1 output 2 explan array 132 213 exactli 1 invers pair constraint 1 n 1000 0 k 1000 kinversepairsarray
given head link list remov nth node end list return head exampl 1 input head 12345 n 2 output 1235 exampl 2 input head 1 n 1 output exampl 3 input head 12 n 1 output 1 constraint number node list sz 1 sz 30 0 nodev 100 1 n sz follow could one pass removenthnodefromendoflist
given integ array num return maximum possibl sum element array divis three exampl 1 input num 36518 output 18 explan pick number 3 6 1 8 sum 18 maximum sum divis 3 exampl 2 input num 4 output 0 explan sinc 4 divis 3 pick number exampl 3 input num 12344 output 12 explan pick number 1 3 4 4 sum 12 maximum sum divis 3 constraint 1 numslength 4 104 1 numsi 104 greatestsumdivisiblebythre
given integ n number team tournament strang rule current number team even team get pair anoth team total n 2 match play n 2 team advanc next round current number team odd one team randomli advanc tournament rest get pair total n 1 2 match play n 1 2 1 team advanc next round return number match play tournament winner decid exampl 1 input n 7 output 6 explan detail tournament 1st round team 7 match 3 4 team advanc 2nd round team 4 match 2 2 team advanc 3rd round team 2 match 1 1 team declar winner total number match 3 2 1 6 exampl 2 input n 14 output 13 explan detail tournament 1st round team 14 match 7 7 team advanc 2nd round team 7 match 3 4 team advanc 3rd round team 4 match 2 2 team advanc 4th round team 2 match 1 1 team declar winner total number match 7 3 2 1 13 constraint 1 n 200 countofmatchesintourna
given integ array num partit two contigu subarray left right everi element left less equal everi element right left right nonempti left smallest possibl size return length left partit test case gener partit exist exampl 1 input num 50386 output 3 explan left 503 right 86 exampl 2 input num 1110612 output 4 explan left 1110 right 612 constraint 2 numslength 105 0 numsi 106 least one valid answer given input partitionarrayintodisjointinterv
alic undirect tree n node label 0 n 1 tree repres 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree alic want bob find root tree allow bob make sever guess tree one guess follow choos two distinct integ u v exist edg u v tree tell alic u parent v tree bob guess repres 2d integ array guess guessesj uj vj indic bob guess uj parent vj alic lazi repli bob guess say least k guess true given 2d integ array edg guess integ k return number possibl node root alic tree tree return 0 exampl 1 input edg 01121342 guess 13011024 k 3 output 3 explan root 0 correct guess 13 01 24 root 1 correct guess 13 10 24 root 2 correct guess 13 10 24 root 3 correct guess 10 24 root 4 correct guess 13 10 consid 0 1 2 root node lead 3 correct guess exampl 2 input edg 01122334 guess 10342132 k 1 output 5 explan root 0 correct guess 34 root 1 correct guess 10 34 root 2 correct guess 10 21 34 root 3 correct guess 10 21 32 34 root 4 correct guess 10 21 32 consid node root give least 1 correct guess constraint edgeslength n 1 2 n 105 1 guesseslength 105 0 ai bi uj vj n 1 ai bi uj vj edg repres valid tree guessesj edg tree guess uniqu 0 k guesseslength countnumberofpossiblerootnod
given 0index integ array num allow permut num new array perm choos defin great num number indic 0 numslength permi numsi return maximum possibl great achiev permut num exampl 1 input num 1352131 output 4 explan one optim rearrang perm 2513311 indic 0 1 3 4 permi numsi henc return 4 exampl 2 input num 1234 output 3 explan prove optim perm 2341 indic 0 1 2 permi numsi henc return 3 constraint 1 numslength 105 0 numsi 109 maximizegreatnessofanarray
given array integ num perform follow step find two adjac number num noncoprim number found stop process otherwis delet two number replac lcm least common multipl repeat process long keep find two adjac noncoprim number return final modifi array shown replac adjac noncoprim number arbitrari order lead result test case gener valu final array less equal 108 two valu x noncoprim gcdx 1 gcdx greatest common divisor x exampl 1 input num 6432762 output 1276 explan 6 4 noncoprim lcm6 4 12 num 1232762 12 3 noncoprim lcm12 3 12 num 122762 12 2 noncoprim lcm12 2 12 num 12762 6 2 noncoprim lcm6 2 6 num 1276 adjac noncoprim number num thu final modifi array 1276 note way obtain result array exampl 2 input num 2211333 output 2113 explan 3 3 noncoprim lcm3 3 3 num 221133 3 3 noncoprim lcm3 3 3 num 22113 2 2 noncoprim lcm2 2 2 num 2113 adjac noncoprim number num thu final modifi array 2113 note way obtain result array constraint 1 numslength 105 1 numsi 105 test case gener valu final array less equal 108 replacenoncoprimenumbersinarray
given root binari tree depth node shortest distanc root return smallest subtre contain deepest node origin tree node call deepest largest depth possibl among node entir tree subtre node tree consist node plu set descend node exampl 1 input root 3516208nullnull74 output 274 explan return node valu 2 color yellow diagram node colour blue deepest node tree notic node 5 3 2 contain deepest node tree node 2 smallest subtre among return exampl 2 input root 1 output 1 explan root deepest node tree exampl 3 input root 013null2 output 2 explan deepest node tree 2 valid subtre subtre node 2 1 0 subtre node 2 smallest constraint number node tree rang 1 500 0 nodev 500 valu node tree uniqu note question 1123 httpsleetcodecomproblemslowestcommonancestorofdeepestleav smallestsubtreewithallthedeepestnod
ruler kingdom armi wizard command given 0index integ array strength strengthi denot strength ith wizard contigu group wizard ie wizard strength form subarray strength total strength defin product follow two valu strength weakest wizard group total individu strength wizard group return sum total strength contigu group wizard sinc answer may larg return modulo 109 7 subarray contigu nonempti sequenc element within array exampl 1 input strength 1312 output 44 explan follow contigu group wizard 1 1312 total strength min1 sum1 1 1 1 3 1312 total strength min3 sum3 3 3 9 1 1312 total strength min1 sum1 1 1 1 2 1312 total strength min2 sum2 2 2 4 13 1312 total strength min13 sum13 1 4 4 31 1312 total strength min31 sum31 1 4 4 12 1312 total strength min12 sum12 1 3 3 131 1312 total strength min131 sum131 1 5 5 312 1312 total strength min312 sum312 1 6 6 1312 1312 total strength min1312 sum1312 1 7 7 sum total strength 1 9 1 4 4 4 3 5 6 7 44 exampl 2 input strength 546 output 213 explan follow contigu group wizard 5 546 total strength min5 sum5 5 5 25 4 546 total strength min4 sum4 4 4 16 6 546 total strength min6 sum6 6 6 36 54 546 total strength min54 sum54 4 9 36 46 546 total strength min46 sum46 4 10 40 546 546 total strength min546 sum546 4 15 60 sum total strength 25 16 36 36 40 60 213 constraint 1 strengthlength 105 1 strengthi 109 sumoftotalstrengthofwizard
given array integ arr integ one step jump index index x x arrlength 0 x x x 0 0 x addit jump index index j arri arrj arri arrk indic k j formal mini j k maxi j choos index array start jump return maximum number indic visit notic jump outsid array time exampl 1 input arr 641468139710612 2 output 4 explan start index 10 jump 10 8 6 7 shown note start index 6 jump index 7 jump index 5 13 9 jump index 4 index 5 index 4 6 13 9 similarli jump index 3 index 2 index 1 exampl 2 input arr 33333 3 output 1 explan start index alway jump index exampl 3 input arr 7654321 1 output 7 explan start index 0 visit indici constraint 1 arrlength 1000 1 arri 105 1 arrlength jumpgamev
chess knight uniqu movement may move two squar vertic one squar horizont two squar horizont one squar vertic form shape l possibl movement chess knight shown diagaram chess knight move indic chess diagram chess knight phone pad shown knight stand numer cell ie blue cell given integ n return mani distinct phone number length n dial allow place knight numer cell initi perform n 1 jump dial number length n jump valid knight jump answer may larg return answer modulo 109 7 exampl 1 input n 1 output 10 explan need dial number length 1 place knight numer cell 10 cell suffici exampl 2 input n 2 output 20 explan valid number dial 04 06 16 18 27 29 34 38 40 43 49 60 61 67 72 76 81 83 92 94 exampl 3 input n 3131 output 136006598 explan pleas take care mod constraint 1 n 5000 knightdial
super ugli number posit integ whose prime factor array prime given integ n array integ prime return nth super ugli number nth super ugli number guarante fit 32bit sign integ exampl 1 input n 12 prime 271319 output 32 explan 1247813141619262832 sequenc first 12 super ugli number given prime 271319 exampl 2 input n 1 prime 235 output 1 explan 1 prime factor therefor prime factor array prime 235 constraint 1 n 105 1 primeslength 100 2 primesi 1000 primesi guarante prime number valu prime uniqu sort ascend order superuglynumb
particip onlin chess tournament chess round start everi 15 minut first round day start 0000 everi 15 minut new round start exampl second round start 0015 fourth round start 0045 seventh round start 0130 given two string logintim logouttim logintim time login game logouttim time logout game logouttim earlier logintim mean play logintim midnight midnight logouttim return number full chess round play tournament note given time follow 24hour clock mean first round day start 0000 last round day start 2345 exampl 1 input logintim 0931 logouttim 1014 output 1 explan play one full round 0945 1000 play full round 0930 0945 log 0931 began play full round 1000 1015 log 1014 end exampl 2 input logintim 2130 logouttim 0300 output 22 explan play 10 full round 2130 0000 12 full round 0000 0300 10 12 22 constraint logintim logouttim format hhmm 00 hh 23 00 mm 59 logintim logouttim equal thenumberoffullroundsyouhaveplay
given larg integ n repres string integ digit x digit n digit x inclus rang 1 9 n may repres neg number want maxim ns numer valu insert x anywher decim represent n insert x left neg sign exampl n 73 x 6 would best insert 7 3 make n 763 n 55 x 2 would best insert first 5 make n 255 return string repres maximum valu n insert exampl 1 input n 99 x 9 output 999 explan result regardless insert 9 exampl 2 input n 13 x 2 output 123 explan make n one 213 123 132 largest three 123 constraint 1 nlength 105 1 x 9 digit n rang 1 9 n valid represent integ case neg n begin maximumvalueafterinsert
given string path absolut path start slash file directori unixstyl file system convert simplifi canon path unixstyl file system period refer current directori doubl period refer directori level multipl consecut slash ie treat singl slash problem format period treat filedirectori name canon path follow format path start singl slash two directori separ singl slash path end trail path contain directori path root directori target file directori ie period doubl period return simplifi canon path exampl 1 input path home output home explan note trail slash last directori name exampl 2 input path output explan go one level root directori noop root level highest level go exampl 3 input path homefoo output homefoo explan canon path multipl consecut slash replac singl one constraint 1 pathlength 3000 path consist english letter digit period slash path valid absolut unix path simplifypath
given rectangl size n x return minimum number integersid squar tile rectangl exampl 1 input n 2 3 output 3 explan 3 squar necessari cover rectangl 2 squar 1x1 1 squar 2x2 exampl 2 input n 5 8 output 5 exampl 3 input n 11 13 output 6 constraint 1 n 13 tilingarectanglewiththefewestsquar
sql schema tabl stock column name type stocknam varchar oper enum operationday int price int stocknam operationday primari key tabl oper column enum type sell buy row tabl indic stock stocknam oper day operationday price guarante sell oper stock correspond buy oper previou day also guarante buy oper stock correspond sell oper upcom day write sql queri report capit gainloss stock capit gainloss stock total gain loss buy sell stock one mani time return result tabl order queri result format follow exampl exampl 1 input stock tabl stocknam oper operationday price leetcod buy 1 1000 corona mask buy 2 10 leetcod sell 5 9000 handbag buy 17 30000 corona mask sell 3 1010 corona mask buy 4 1000 corona mask sell 5 500 corona mask buy 6 1000 handbag sell 29 7000 corona mask sell 10 10000 output stocknam capitalgainloss corona mask 9500 leetcod 8000 handbag 23000 explan leetcod stock bought day 1 1000 sold day 5 9000 capit gain 9000 1000 8000 handbag stock bought day 17 30000 sold day 29 7000 capit loss 7000 30000 23000 corona mask stock bought day 1 10 sold day 3 1010 bought day 4 1000 sold day 5 500 last bought day 6 1000 sold day 10 10000 capit gainloss sum capit gainsloss buy sell oper 1010 10 500 1000 10000 1000 1000 500 9000 9500 capitalgainloss
given two posit integ n k factor integ n defin integ n 0 consid list factor n sort ascend order return kth factor list return 1 n less k factor exampl 1 input n 12 k 3 output 3 explan factor list 1 2 3 4 6 12 3rd factor 3 exampl 2 input n 7 k 2 output 7 explan factor list 1 7 2nd factor 7 exampl 3 input n 4 k 4 output 1 explan factor list 1 2 4 3 factor return 1 constraint 1 k n 1000 follow could solv problem less complex thekthfactorofn
given integ n repres number node perfect binari tree consist node number 1 n root tree node 1 node tree two children left child node 2 right child 2 1 node tree also cost repres given 0index integ array cost size n costi cost node 1 allow increment cost node 1 number time return minimum number increment need make cost path root leaf node equal note perfect binari tree tree node except leaf node exactli 2 children cost path sum cost node path exampl 1 input n 7 cost 1522331 output 6 explan follow increment increas cost node 4 one time increas cost node 3 three time increas cost node 7 two time path root leaf total cost 9 total increment 1 3 2 6 shown minimum answer achiev exampl 2 input n 3 cost 533 output 0 explan two path alreadi equal total cost increment need constraint 3 n 105 n 1 power 2 costlength n 1 costi 104 makecostsofpathsequalinabinarytre
sql schema pandan schema tabl dailysal column name type dateid date makenam varchar leadid int partnerid int tabl may contain duplic word primari key tabl sql tabl contain date name product sold id lead partner sold name consist lowercas english letter dateid makenam find number distinct leadid distinct partnerid return result tabl order result format follow exampl exampl 1 input dailysal tabl dateid makenam leadid partnerid 2020128 toyota 0 1 2020128 toyota 1 0 2020128 toyota 1 2 2020127 toyota 0 2 2020127 toyota 0 1 2020128 honda 1 2 2020128 honda 2 1 2020127 honda 0 1 2020127 honda 1 2 2020127 honda 2 1 output dateid makenam uniquelead uniquepartn 2020128 toyota 2 3 2020127 toyota 1 2 2020128 honda 2 2 2020127 honda 3 2 explan 2020128 toyota get lead 0 1 partner 0 1 2 honda get lead 1 2 partner 1 2 2020127 toyota get lead 0 partner 1 2 honda get lead 0 1 2 partner 1 2 dailyleadsandpartn
given 0index integ array num allow travers indic travers index index j j gcdnumsi numsj 1 gcd greatest common divisor task determin everi pair indic j num j exist sequenc travers take us j return true possibl travers pair indic fals otherwis exampl 1 input num 236 output true explan exampl 3 possibl pair indic 0 1 0 2 1 2 go index 0 index 1 use sequenc travers 0 2 1 move index 0 index 2 gcdnums0 nums2 gcd2 6 2 1 move index 2 index 1 gcdnums2 nums1 gcd6 3 3 1 go index 0 index 2 go directli gcdnums0 nums2 gcd2 6 2 1 likewis go index 1 index 2 go directli gcdnums1 nums2 gcd3 6 3 1 exampl 2 input num 395 output fals explan sequenc travers take us index 0 index 2 exampl return fals exampl 3 input num 43128 output true explan 6 possibl pair indic travers 0 1 0 2 0 3 1 2 1 3 2 3 valid sequenc travers exist pair return true constraint 1 numslength 105 1 numsi 105 greatestcommondivisortravers
alic text bob use phone map digit letter shown figur order add letter alic press key correspond digit time posit letter key exampl add letter alic press 7 four time similarli add letter k alic press 5 twice note digit 0 1 map letter alic use howev due error transmiss bob receiv alic text messag receiv string press key instead exampl alic sent messag bob bob receiv string 2266622 given string pressedkey repres string receiv bob return total number possibl text messag alic could sent sinc answer may larg return modulo 109 7 exampl 1 input pressedkey 22233 output 8 explan possibl text messag alic could sent aaadd abdd badd cdd aaae abe bae ce sinc 8 possibl messag return 8 exampl 2 input pressedkey 222222222222222222222222222222222222 output 82876089 explan 2082876103 possibl text messag alic could sent sinc need return answer modulo 109 7 return 2082876103 109 7 82876089 constraint 1 pressedkeyslength 105 pressedkey consist digit 2 9 countnumberoftext
given string find first nonrep charact return index exist return 1 exampl 1 input leetcod output 0 exampl 2 input loveleetcod output 2 exampl 3 input aabb output 1 constraint 1 slength 105 consist lowercas english letter firstuniquecharacterinastr
given array string word return string word substr anoth word return answer order substr contigu sequenc charact within string exampl 1 input word massasherosuperhero output ashero explan substr mass hero substr superhero heroa also valid answer exampl 2 input word leetcodeetcod output etcod explan et code substr leetcod exampl 3 input word bluegreenbu output explan string word substr anoth string constraint 1 wordslength 100 1 wordsilength 30 wordsi contain lowercas english letter string word uniqu stringmatchinginanarray
given data stream input nonneg integ a1 a2 summar number seen far list disjoint interv implement summaryrang class summaryrang initi object empti stream void addnumint valu add integ valu stream int getinterv return summari integ stream current list disjoint interv starti endi answer sort starti exampl 1 input summaryrang addnum getinterv addnum getinterv addnum getinterv addnum getinterv addnum getinterv 1 3 7 2 6 output null null 1 1 null 1 1 3 3 null 1 1 3 3 7 7 null 1 3 7 7 null 1 3 6 7 explan summaryrang summaryrang new summaryrang summaryrangesaddnum1 arr 1 summaryrangesgetinterv return 1 1 summaryrangesaddnum3 arr 1 3 summaryrangesgetinterv return 1 1 3 3 summaryrangesaddnum7 arr 1 3 7 summaryrangesgetinterv return 1 1 3 3 7 7 summaryrangesaddnum2 arr 1 2 3 7 summaryrangesgetinterv return 1 3 7 7 summaryrangesaddnum6 arr 1 2 3 6 7 summaryrangesgetinterv return 1 3 6 7 constraint 0 valu 104 3 104 call made addnum getinterv 102 call made getinterv follow lot merg number disjoint interv small compar size data stream datastreamasdisjointinterv
given 0index array distinct integ num element num lowest valu element highest valu call minimum maximum respect goal remov element array delet defin either remov element front array remov element back array return minimum number delet would take remov minimum maximum element array exampl 1 input num 210754186 output 5 explan minimum element array nums5 1 maximum element array nums1 10 remov minimum maximum remov 2 element front 3 element back result 2 3 5 delet minimum number possibl exampl 2 input num 041918235 output 3 explan minimum element array nums1 4 maximum element array nums2 19 remov minimum maximum remov 3 element front result 3 delet minimum number possibl exampl 3 input num 101 output 1 explan one element array make minimum maximum element remov 1 delet constraint 1 numslength 105 105 numsi 105 integ num distinct removingminimumandmaximumfromarray
given posit integ n follow oper number time add subtract power 2 n return minimum number oper make n equal 0 number x power 2 x 2i 0 exampl 1 input n 39 output 3 explan follow oper add 20 1 n n 40 subtract 23 8 n n 32 subtract 25 32 n n 0 shown 3 minimum number oper need make n equal 0 exampl 2 input n 54 output 3 explan follow oper add 21 2 n n 56 add 23 8 n n 64 subtract 26 64 n n 0 minimum number oper 3 constraint 1 n 105 minimumoperationstoreduceanintegerto0
bitwis array num bitwis integ num exampl num 1 5 3 bitwis equal 1 5 3 1 also num 7 bitwis 7 given array posit integ candid evalu bitwis everi combin number candid number candid may use combin return size largest combin candid bitwis greater 0 exampl 1 input candid 16177162122414 output 4 explan combin 16176224 bitwis 16 17 62 24 16 0 size combin 4 shown combin size greater 4 bitwis greater 0 note one combin may largest size exampl combin 62122414 bitwis 62 12 24 14 8 0 exampl 2 input candid 88 output 2 explan largest combin 88 bitwis 8 8 8 0 size combin 2 return 2 constraint 1 candidateslength 105 1 candidatesi 107 largestcombinationwithbitwiseandgreaterthanzero
given integ array num length n num permut number rang 0 n 1 build set sk numsk numsnumsk numsnumsnumsk subject follow rule first element sk start select element numsk index k next element sk numsnumsk numsnumsnumsk stop ad right duplic element occur sk return longest length set sk exampl 1 input num 5403162 output 4 explan nums0 5 nums1 4 nums2 0 nums3 3 nums4 1 nums5 6 nums6 2 one longest set sk s0 nums0 nums5 nums6 nums2 5 6 2 0 exampl 2 input num 012 output 1 constraint 1 numslength 105 0 numsi numslength valu num uniqu arraynest
initi power power initi score 0 bag token tokensi valu ith token 0index goal maxim total score potenti play token one two way current power least tokensi may play ith token face lose tokensi power gain 1 score current score least 1 may play ith token face gain tokensi power lose 1 score token may play order play token return largest possibl score achiev play number token exampl 1 input token 100 power 50 output 0 explan play token bag imposs either littl power littl score exampl 2 input token 100200 power 150 output 1 explan play 0th token 100 face power becom 50 score becom 1 need play 1st token sinc play face add score exampl 3 input token 100200300400 power 200 output 2 explan play token order get score 2 1 play 0th token 100 face power becom 100 score becom 1 2 play 3rd token 400 face power becom 500 score becom 0 3 play 1st token 200 face power becom 300 score becom 1 4 play 2nd token 300 face power becom 0 score becom 2 constraint 0 tokenslength 1000 0 tokensi power 104 bagoftoken
given integ n repres length unknown array tri recov also given array sum contain valu 2n subset sum unknown array particular order return array an length n repres unknown array multipl answer exist return array sub subset array arr sub obtain arr delet possibl zero element arr sum element sub one possibl subset sum arr sum empti array consid 0 note test case gener alway least one correct answer exampl 1 input n 3 sum 32100123 output 123 explan 123 abl achiev given subset sum sum 0 1 sum 1 2 sum 2 12 sum 3 3 sum 3 13 sum 2 23 sum 1 123 sum 0 note permut 123 also permut 123 also accept exampl 2 input n 2 sum 0000 output 00 explan correct answer 00 exampl 3 input n 4 sum 0055414991434838 output 0145 explan 0145 abl achiev given subset sum constraint 1 n 15 sumslength 2n 104 sumsi 104 findarraygivensubsetsum
given array num consist posit integ also given integ array queri size ith queri want make element num equal queriesi perform follow oper array number time increas decreas element array 1 return array answer size answeri minimum number oper make element num equal queriesi note queri array reset origin state exampl 1 input num 3168 queri 15 output 1410 explan first queri follow oper decreas nums0 2 time num 1168 decreas nums2 5 time num 1118 decreas nums3 7 time num 1111 total number oper first queri 2 5 7 14 second queri follow oper increas nums0 2 time num 5168 increas nums1 4 time num 5568 decreas nums2 1 time num 5558 decreas nums3 3 time num 5555 total number oper second queri 2 4 1 3 10 exampl 2 input num 2963 queri 10 output 20 explan increas valu array 10 total number oper 8 1 4 7 20 constraint n numslength querieslength 1 n 105 1 numsi queriesi 109 minimumoperationstomakeallarrayelementsequ
lock front 4 circular wheel wheel 10 slot 0 1 2 3 4 5 6 7 8 9 wheel rotat freeli wrap around exampl turn 9 0 0 9 move consist turn one wheel one slot lock initi start 0000 string repres state 4 wheel given list deadend dead end mean lock display code wheel lock stop turn unabl open given target repres valu wheel unlock lock return minimum total number turn requir open lock 1 imposs exampl 1 input deadend 02010101010212122002 target 0202 output 6 explan sequenc valid move would 0000 1000 1100 1200 1201 1202 0202 note sequenc like 0000 0001 0002 0102 0202 would invalid wheel lock becom stuck display becom dead end 0102 exampl 2 input deadend 8888 target 0009 output 1 explan turn last wheel revers move 0000 0009 exampl 3 input deadend 88878889887888988788898878889888 target 8888 output 1 explan reach target without get stuck constraint 1 deadendslength 500 deadendsilength 4 targetlength 4 target list deadend target deadendsi consist digit openthelock
integ array origin transform doubl array chang append twice valu everi element origin randomli shuffl result array given array chang return origin chang doubl array chang doubl array return empti array element origin may return order exampl 1 input chang 134268 output 134 explan one possibl origin array could 134 twice valu 1 1 2 2 twice valu 3 3 2 6 twice valu 4 4 2 8 origin array could 431 314 exampl 2 input chang 6301 output explan chang doubl array exampl 3 input chang 1 output explan chang doubl array constraint 1 changedlength 105 0 changedi 105 findoriginalarrayfromdoubledarray
given x n integ matrix matrix element 0 set entir row column 0s must place exampl 1 input matrix 111101111 output 101000101 exampl 2 input matrix 012034521315 output 000004500310 constraint matrixlength n matrix0length 1 n 200 231 matrixij 231 1 follow straightforward solut use omn space probabl bad idea simpl improv use om n space still best solut could devis constant space solut setmatrixzero
given string repres serial nest list implement parser deseri return deseri nestedinteg element either integ list whose element may also integ list exampl 1 input 324 output 324 explan return nestedinteg object contain singl integ 324 exampl 2 input 123456789 output 123456789 explan return nestedinteg object contain nest list 2 element 1 integ contain valu 123 2 nest list contain two element integ contain valu 456 ii nest list one element integ contain valu 789 constraint 1 slength 5 104 consist digit squar bracket neg sign comma serial valid nestedinteg valu input rang 106 106 minipars
sql schema pandan schema tabl employe column name type employeeid int name varchar salari int sql employeeid primari key tabl row tabl indic employe id employe name salari calcul bonu employe bonu employe 100 salari id employe odd number employe name start charact bonu employe 0 otherwis return result tabl order employeeid result format follow exampl exampl 1 input employe tabl employeeid name salari 2 meir 3000 3 michael 3800 7 addilyn 7400 8 juan 6100 9 kannon 7700 output employeeid bonu 2 0 3 0 7 7400 8 0 9 7700 explan employe id 2 8 get 0 bonu even employeeid employe id 3 get 0 bonu name start rest employe get 100 bonu calculatespecialbonu
infinit binari tree everi node two children node label row order odd number row ie first third fifth label left right even number row second fourth sixth label right left given label node tree return label path root tree node label exampl 1 input label 14 output 13414 exampl 2 input label 26 output 1261026 constraint 1 label 106 pathinzigzaglabelledbinarytre
street n 2 plot n plot side street plot side number 1 n plot hous place return number way hous place two hous adjac side street sinc answer may larg return modulo 109 7 note hous place ith plot one side street hous also place ith plot side street exampl 1 input n 1 output 4 explan possibl arrang 1 plot empti 2 hous place one side street 3 hous place side street 4 two hous place one side street exampl 2 input n 2 output 9 explan 9 possibl arrang shown diagram constraint 1 n 104 countnumberofwaystoplacehous
given array arr consist zero one divid array three nonempti part part repres binari valu possibl return j 1 j arr0 arr1 arri first part arri 1 arri 2 arrj 1 second part arrj arrj 1 arrarrlength 1 third part three part equal binari valu possibl return 1 1 note entir part use consid binari valu repres exampl 110 repres 6 decim 3 also lead zero allow 011 11 repres valu exampl 1 input arr 10101 output 03 exampl 2 input arr 11011 output 11 exampl 3 input arr 11001 output 02 constraint 3 arrlength 3 104 arri 0 1 threeequalpart
n citi label 1 n two differ citi label x directli connect bidirect road x share common divisor strictli greater threshold formal citi label x road exist integ z follow true x z 0 z 0 z threshold given two integ n threshold array queri must determin queriesi ai bi citi ai bi connect directli indirectli ie path return array answer answerlength querieslength answeri true ith queri path ai bi answeri fals path exampl 1 input n 6 threshold 2 queri 142536 output falsefalsetru explan divisor number 1 1 2 1 2 3 1 3 4 1 2 4 5 1 5 6 1 2 3 6 use underlin divisor threshold citi 3 6 share common divisor one directli connect result queri 14 1 connect 4 25 2 connect 5 36 3 connect 6 path 36 exampl 2 input n 6 threshold 0 queri 4534322613 output truetruetruetruetru explan divisor number previou exampl howev sinc threshold 0 divisor use sinc number share 1 divisor citi connect exampl 3 input n 5 threshold 1 queri 4545322334 output falsefalsefalsefalsefals explan citi 2 4 share common divisor 2 strictli greater threshold 1 one directli connect pleas notic multipl queri pair node x queri x equival queri x constraint 2 n 104 0 threshold n 1 querieslength 105 queriesilength 2 1 ai bi citi ai bi graphconnectivitywiththreshold
appeal string number distinct charact found string exampl appeal abbca 3 3 distinct charact b c given string return total appeal substr substr contigu sequenc charact within string exampl 1 input abbca output 28 explan follow substr abbca substr length 1 b b c appeal 1 1 1 1 1 respect sum 5 substr length 2 ab bb bc ca appeal 2 1 2 2 respect sum 7 substr length 3 abb bbc bca appeal 2 2 3 respect sum 7 substr length 4 abbc bbca appeal 3 3 respect sum 6 substr length 5 abbca appeal 3 sum 3 total sum 5 7 7 6 3 28 exampl 2 input code output 20 explan follow substr code substr length 1 c e appeal 1 1 1 1 respect sum 4 substr length 2 co od de appeal 2 2 2 respect sum 6 substr length 3 cod ode appeal 3 3 respect sum 6 substr length 4 code appeal 4 sum 4 total sum 4 6 6 4 20 constraint 1 slength 105 consist lowercas english letter totalappealofastr
given root binari search tree bst integ val find node bst node valu equal val return subtre root node node exist return null exampl 1 input root 42713 val 2 output 213 exampl 2 input root 42713 val 5 output constraint number node tree rang 1 5000 1 nodev 107 root binari search tree 1 val 107 searchinabinarysearchtre
sql schema tabl employe column name type empid int name varchar supervisor int salari int empid primari key column tabl row tabl indic name id employe addit salari id manag tabl bonu column name type empid int bonu int empid primari key column tabl empid foreign key empid employe tabl row tabl contain id employe respect bonu write sql queri report name bonu amount employe bonu less 1000 return result tabl order queri result format follow exampl exampl 1 input employe tabl empid name supervisor salari 3 brad null 4000 1 john 3 1000 2 dan 3 2000 4 thoma 3 4000 bonu tabl empid bonu 2 500 4 2000 output name bonu brad null john null dan 500 employeebonu
8 x 8 chessboard exactli one white rook r number white bishop b black pawn p empti squar rook move choos one four cardin direct north east south west move direct choos stop reach edg board captur black pawn block white bishop rook consid attack pawn rook captur pawn rook turn number avail captur white rook number pawn rook attack return number avail captur white rook exampl 1 input board prpp output 3 explan exampl rook attack pawn exampl 2 input board pppppppbpppbrbpppbppppppp output 0 explan bishop block rook attack pawn exampl 3 input board pppprpbbp output 3 explan rook attack pawn posit b5 d6 f5 constraint boardlength 8 boardilength 8 boardij either r b p exactli one cell boardij r availablecapturesforrook
given integ array num length n want creat array an length 2n ansi numsi ansi n numsi 0 n 0index specif an concaten two num array return array an exampl 1 input num 121 output 121121 explan array an form follow an nums0nums1nums2nums0nums1nums2 an 121121 exampl 2 input num 1321 output 13211321 explan array an form follow an nums0nums1nums2nums3nums0nums1nums2nums3 an 13211321 constraint n numslength 1 n 1000 1 numsi 1000 concatenationofarray
messag contain letter az encod number use follow map 1 b 2 z 26 decod encod messag digit must group map back letter use revers map may multipl way exampl 11106 map aajf group 1 1 10 6 kjf group 11 10 6 note group 1 11 06 invalid 06 map f sinc 6 differ 06 given string contain digit return number way decod test case gener answer fit 32bit integ exampl 1 input 12 output 2 explan 12 could decod ab 1 2 l 12 exampl 2 input 226 output 3 explan 226 could decod bz 2 26 vf 22 6 bbf 2 2 6 exampl 3 input 06 output 0 explan 06 map f lead zero 6 differ 06 constraint 1 slength 100 contain digit may contain lead zero decodeway
alic bob want water n plant garden plant arrang row label 0 n 1 left right ith plant locat x plant need specif amount water alic bob water initi full water plant follow way alic water plant order left right start 0th plant bob water plant order right left start n 1th plant begin water plant simultan take amount time water plant regardless much water need alicebob must water plant enough fulli water otherwis first refil instantan water plant case alic bob reach plant one water current hisher water water plant amount water alic water plant given 0index integ array plant n integ plantsi amount water ith plant need two integ capacitya capacityb repres capac alic bob water can respect return number time refil water plant exampl 1 input plant 2233 capacitya 5 capacityb 5 output 1 explan initi alic bob 5 unit water water can alic water plant 0 bob water plant 3 alic bob 3 unit 2 unit water respect alic enough water plant 1 water bob enough water plant 2 refil water total number time refil water plant 0 0 1 0 1 exampl 2 input plant 2233 capacitya 3 capacityb 4 output 2 explan initi alic bob 3 unit 4 unit water water can respect alic water plant 0 bob water plant 3 alic bob 1 unit water need water plant 1 2 respect sinc neither enough water current plant refil can water plant total number time refil water plant 0 1 1 0 2 exampl 3 input plant 5 capacitya 10 capacityb 8 output 0 explan one plant alic water 10 unit water wherea bob 8 unit sinc alic water water plant total number time refil 0 constraint n plantslength 1 n 105 1 plantsi 106 maxplantsi capacitya capacityb 109 wateringplantsii
given string partit everi substr partit palindrom return minimum cut need palindrom partit exampl 1 input aab output 1 explan palindrom partit aab could produc use 1 cut exampl 2 input output 0 exampl 3 input ab output 1 constraint 1 slength 2000 consist lowercas english letter palindromepartitioningii
integ array perm permut first n posit integ n alway odd encod anoth integ array encod length n 1 encodedi permi xor permi 1 exampl perm 132 encod 21 given encod array return origin array perm guarante answer exist uniqu exampl 1 input encod 31 output 123 explan perm 123 encod 1 xor 22 xor 3 31 exampl 2 input encod 6546 output 24153 constraint 3 n 105 n odd encodedlength n 1 decodexoredpermut
prize xaxi given integ array prizeposit sort nondecreas order prizepositionsi posit ith prize could differ prize posit line also given integ k allow select two segment integ endpoint length segment must k collect prize whose posit fall within least one two select segment includ endpoint segment two select segment may intersect exampl k 2 choos segment 1 3 2 4 win prize satisfi 1 prizepositionsi 3 2 prizepositionsi 4 return maximum number prize win choos two segment optim exampl 1 input prizeposit 1122335 k 2 output 7 explan exampl win 7 prize select two segment 1 3 3 5 exampl 2 input prizeposit 1234 k 0 output 2 explan exampl one choic segment 3 3 4 4 abl get 2 prize constraint 1 prizepositionslength 105 1 prizepositionsi 109 0 k 109 prizeposit sort nondecreas order maximizewinfromtwoseg
given array point pointsi xi yi repres point xy plane integ k return k closest point origin 0 0 distanc two point xy plane euclidean distanc ie √x1 x22 y1 y22 may return answer order answer guarante uniqu except order exampl 1 input point 1322 k 1 output 22 explan distanc 1 3 origin sqrt10 distanc 2 2 origin sqrt8 sinc sqrt8 sqrt10 2 2 closer origin want closest k 1 point origin answer 22 exampl 2 input point 335124 k 2 output 3324 explan answer 2433 would also accept constraint 1 k pointslength 104 104 xi yi 104 kclosestpointstoorigin
given integ n break sum k posit integ k 2 maxim product integ return maximum product get exampl 1 input n 2 output 1 explan 2 1 1 1 × 1 1 exampl 2 input n 10 output 36 explan 10 3 3 4 3 × 3 × 4 36 constraint 2 n 58 integerbreak
given array num numsi find mani number array smaller numsi count number valid js j numsj numsi return answer array exampl 1 input num 81223 output 40113 explan nums08 exist four smaller number 1 2 2 3 nums11 exist smaller number nums22 exist one smaller number 1 nums32 exist one smaller number 1 nums43 exist three smaller number 1 2 2 exampl 2 input num 6548 output 2103 exampl 3 input num 7777 output 0000 constraint 2 numslength 500 0 numsi 100 howmanynumbersaresmallerthanthecurrentnumb
given two 0index integ array player1 player2 repres number pin player 1 player 2 hit bowl game respect bowl game consist n turn number pin turn exactli 10 assum player hit xi pin ith turn valu ith turn player 2xi player hit 10 pin previou two turn otherwis xi score player sum valu n turn return 1 score player 1 score player 2 2 score player 2 score player 1 0 case draw exampl 1 input player1 41079 player2 6523 output 1 explan score player1 4 10 27 29 46 score player2 6 5 2 3 16 score player1 score player2 player1 winner answer 1 exampl 2 input player1 3576 player2 810102 output 2 explan score player1 3 5 7 6 21 score player2 8 10 210 22 42 score player2 score player1 player2 winner answer 2 exampl 3 input player1 23 player2 41 output 0 explan score player1 2 3 5 score player2 4 1 5 score player1 equal score player2 draw answer 0 constraint n player1length player2length 1 n 1000 0 player1i player2i 10 determinethewinnerofabowlinggam
given root binari tree return lowest common ancestor deepest leav recal node binari tree leaf children depth root tree 0 depth node depth children 1 lowest common ancestor set node node largest depth everi node subtre root exampl 1 input root 3516208nullnull74 output 274 explan return node valu 2 color yellow diagram node colour blue deepest leafnod tree note node 6 0 8 also leaf node depth 2 depth node 7 4 3 exampl 2 input root 1 output 1 explan root deepest node tree lca exampl 3 input root 013null2 output 2 explan deepest leaf node tree 2 lca one node constraint number node tree rang 1 1000 0 nodev 1000 valu node tree uniqu note question 865 httpsleetcodecomproblemssmallestsubtreewithallthedeepestnod lowestcommonancestorofdeepestleav
given string allow consist distinct charact array string word string consist charact string appear string allow return number consist string array word exampl 1 input allow ab word adbdaaabbaabadab output 2 explan string aaab baa consist sinc contain charact b exampl 2 input allow abc word abcabacbcabc output 7 explan string consist exampl 3 input allow cad word ccacdbbabacbadacd output 4 explan string cc acd ac consist constraint 1 wordslength 104 1 allowedlength 26 1 wordsilength 10 charact allow distinct wordsi allow contain lowercas english letter countthenumberofconsistentstr
social media compani tri monitor activ site analyz number tweet occur select period time period partit smaller time chunk base certain frequenc everi minut hour day exampl period 10 10000 second would partit follow time chunk frequenc everi minut 60second chunk 1069 70129 130189 997010000 everi hour 3600second chunk 103609 36107209 721010000 everi day 86400second chunk 1010000 notic last chunk may shorter specifi frequenc chunk size alway end end time period 10000 exampl design implement api help compani analysi implement tweetcount class tweetcount initi tweetcount object void recordtweetstr tweetnam int time store tweetnam record time second listinteg gettweetcountsperfrequencystr freq string tweetnam int starttim int endtim return list integ repres number tweet tweetnam time chunk given period time starttim endtim second frequenc freq freq one minut hour day repres frequenc everi minut hour day respect exampl input tweetcountsrecordtweetrecordtweetrecordtweetgettweetcountsperfrequencygettweetcountsperfrequencyrecordtweetgettweetcountsperfrequ tweet30tweet360tweet310minutetweet3059minutetweet3060tweet3120hourtweet30210 output nullnullnullnull221null4 explan tweetcount tweetcount new tweetcount tweetcountsrecordtweettweet3 0 new tweet tweet3 time 0 tweetcountsrecordtweettweet3 60 new tweet tweet3 time 60 tweetcountsrecordtweettweet3 10 new tweet tweet3 time 10 tweetcountsgettweetcountsperfrequencyminut tweet3 0 59 return 2 chunk 059 2 tweet tweetcountsgettweetcountsperfrequencyminut tweet3 0 60 return 21 chunk 059 2 tweet chunk 6060 1 tweet tweetcountsrecordtweettweet3 120 new tweet tweet3 time 120 tweetcountsgettweetcountsperfrequencyhour tweet3 0 210 return 4 chunk 0210 4 tweet constraint 0 time starttim endtim 109 0 endtim starttim 104 104 call total recordtweet gettweetcountsperfrequ tweetcountsperfrequ
given string split call good split two nonempti string sleft sright concaten equal ie sleft sright number distinct letter sleft sright return number good split make exampl 1 input aacaba output 2 explan 5 way split aacaba 2 good acaba left string right string contain 1 3 differ letter respect aa caba left string right string contain 1 3 differ letter respect aac aba left string right string contain 2 2 differ letter respect good split aaca ba left string right string contain 2 2 differ letter respect good split aacab left string right string contain 3 1 differ letter respect exampl 2 input abcd output 1 explan split string follow ab cd constraint 1 slength 105 consist lowercas english letter numberofgoodwaystosplitastr
given root perfect binari tree revers node valu odd level tree exampl suppos node valu level 3 21347112918 becom 18291174312 return root revers tree binari tree perfect parent node two children leav level level node number edg along path root node exampl 1 input root 2358132134 output 2538132134 explan tree one odd level node level 1 3 5 respect revers becom 5 3 exampl 2 input root 71311 output 71113 explan node level 1 13 11 revers becom 11 13 exampl 3 input root 012000011112222 output 021000022221111 explan odd level nonzero valu node level 1 1 2 2 1 revers node level 3 1 1 1 1 2 2 2 2 2 2 2 2 1 1 1 1 revers constraint number node tree rang 1 214 0 nodev 105 root perfect binari tree reverseoddlevelsofbinarytre
given array n string str length may choos delet indic delet charact indic string exampl str abcdefuvwxyz delet indic 0 2 3 final array delet bef vyz suppos chose set delet indic answer delet final array element lexicograph order ie strs0 strs1 strs2 strsn 1 return minimum possibl valu answerlength exampl 1 input str cabbac output 1 explan delet first column str b c str lexicograph order ie strs0 strs1 strs2 requir least 1 delet sinc initi str lexicograph order answer 1 exampl 2 input str xcybza output 0 explan str alreadi lexicograph order need delet anyth note row str necessarili lexicograph order ie necessarili true strs00 strs01 exampl 3 input str zyxwvutsr output 3 explan delet everi column constraint n strslength 1 n 100 1 strsilength 100 strsi consist lowercas english letter deletecolumnstomakesortedii
given link list swap everi two adjac node return head must solv problem without modifi valu list node ie node may chang exampl 1 input head 1234 output 2143 exampl 2 input head output exampl 3 input head 1 output 1 constraint number node list rang 0 100 0 nodev 100 swapnodesinpair
given head two sort link list list1 list2 merg two list one sort list list made splice togeth node first two list return head merg link list exampl 1 input list1 124 list2 134 output 112344 exampl 2 input list1 list2 output exampl 3 input list1 list2 0 output 0 constraint number node list rang 0 50 100 nodev 100 list1 list2 sort nondecreas order mergetwosortedlist
given array arr posit integ consid binari tree node either 0 2 children valu arr correspond valu leaf inord travers tree valu nonleaf node equal product largest leaf valu left right subtre respect among possibl binari tree consid return smallest possibl sum valu nonleaf node guarante sum fit 32bit integ node leaf zero children exampl 1 input arr 624 output 32 explan two possibl tree shown first nonleaf node sum 36 second nonleaf node sum 32 exampl 2 input arr 411 output 44 constraint 2 arrlength 40 1 arri 15 guarante answer fit 32bit sign integ ie less 231 minimumcosttreefromleafvalu
given two integ n k return kth lexicograph smallest integ rang 1 n exampl 1 input n 13 k 2 output 10 explan lexicograph order 1 10 11 12 13 2 3 4 5 6 7 8 9 second smallest number 10 exampl 2 input n 1 k 1 output 1 constraint 1 k n 109 kthsmallestinlexicographicalord
given integ array num two integ k p return number distinct subarray k element divis p two array nums1 nums2 said distinct differ length exist least one index nums1i nums2i subarray defin nonempti contigu sequenc element array exampl 1 input num 23322 k 2 p 2 output 11 explan element indic 0 3 4 divis p 2 11 distinct subarray k 2 element divis 2 2 23 233 2332 3 33 332 3322 32 322 22 note subarray 2 3 occur num count subarray 23322 count 3 element divis 2 exampl 2 input num 1234 k 4 p 1 output 10 explan element num divis p 1 also everi subarray num 4 element divis 1 sinc subarray distinct total number subarray satisfi constraint 10 constraint 1 numslength 200 1 numsi p 200 1 k numslength follow solv problem on2 time complex kdivisibleelementssubarray
given root complet binari tree return number node tree accord wikipedia everi level except possibl last complet fill complet binari tree node last level far left possibl 1 2h node inclus last level h design algorithm run less time complex exampl 1 input root 123456 output 6 exampl 2 input root output 0 exampl 3 input root 1 output 1 constraint number node tree rang 0 5 104 0 nodev 5 104 tree guarante complet countcompletetreenod
sql schema tabl sale column name type saleid int productid int year int quantiti int price int saleid year primari key tabl productid foreign key product tabl row tabl show sale product productid certain year note price per unit tabl product column name type productid int productnam varchar productid primari key tabl row tabl indic product name product write sql queri select product id year quantiti price first year everi product sold return result tabl order queri result format follow exampl exampl 1 input sale tabl saleid productid year quantiti price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 product tabl productid productnam 100 nokia 200 appl 300 samsung output productid firstyear quantiti price 100 2008 10 5000 200 2011 15 9000 productsalesanalysisiii
given array string word return smallest string contain string word substr multipl valid string smallest length return may assum string word substr anoth string word exampl 1 input word alexlovesleetcod output alexlovesleetcod explan permut alexlovesleetcod would also accept exampl 2 input word catgctaagtgctattcaatgcatc output gctaagttcatgcatc constraint 1 wordslength 12 1 wordsilength 20 wordsi consist lowercas english letter string word uniqu findtheshortestsuperstr
given n x n integ matrix follow oper number time choos two adjac element matrix multipli 1 two element consid adjac share border goal maxim summat matrix element return maximum sum matrix element use oper mention exampl 1 input matrix 1111 output 4 explan follow follow step reach sum equal 4 multipli 2 element first row 1 multipli 2 element first column 1 exampl 2 input matrix 123123123 output 16 explan follow follow step reach sum equal 16 multipli 2 last element second row 1 constraint n matrixlength matrixilength 2 n 250 105 matrixij 105 maximummatrixsum
given two integ b return string length b contain exactli letter exactli b b letter substr aaa occur substr bbb occur exampl 1 input 1 b 2 output abb explan abb bab bba correct answer exampl 2 input 4 b 1 output aabaa constraint 0 b 100 guarante exist given b stringwithoutaaaorbbb
given string zero one return maximum score split string two nonempti substr ie left substr right substr score split string number zero left substr plu number one right substr exampl 1 input 011101 output 5 explan possibl way split two nonempti substr left 0 right 11101 score 1 4 5 left 01 right 1101 score 1 3 4 left 011 right 101 score 1 2 3 left 0111 right 01 score 1 1 2 left 01110 right 1 score 2 1 3 exampl 2 input 00111 output 5 explan left 00 right 111 get maximum score 2 3 5 exampl 3 input 1111 output 3 constraint 2 slength 500 string consist charact 0 1 maximumscoreaftersplittingastr
given two string array queri dictionari word array compris lowercas english letter length one edit take word queri chang letter letter find word queri maximum two edit equal word dictionari return list word queri match word dictionari maximum two edit return word order appear queri exampl 1 input queri wordnoteantswood dictionari woodjokemoat output wordnotewood explan chang r word allow equal dictionari word wood chang n j k note chang joke would take 2 edit ant equal dictionari word wood remain unchang 0 edit match correspond dictionari word thu return wordnotewood exampl 2 input queri ye dictionari output explan appli two edit ye make equal thu return empti array constraint 1 querieslength dictionarylength 100 n queriesilength dictionaryjlength 1 n 100 queriesi dictionaryj compos lowercas english letter wordswithintwoeditsofdictionari
n passeng board airplan exactli n seat first passeng lost ticket pick seat randomli rest passeng take seat still avail pick seat randomli find seat occupi return probabl nth person get seat exampl 1 input n 1 output 100000 explan first person get first seat exampl 2 input n 2 output 050000 explan second person probabl 05 get second seat first person get first seat constraint 1 n 105 airplaneseatassignmentprob
given array integ num integ k return number uniqu kdiff pair array kdiff pair integ pair numsi numsj follow true 0 j numslength j numsi numsj k notic val denot absolut valu val exampl 1 input num 31415 k 2 output 2 explan two 2diff pair array 1 3 3 5 although two 1s input return number uniqu pair exampl 2 input num 12345 k 1 output 4 explan four 1diff pair array 1 2 2 3 3 4 4 5 exampl 3 input num 13154 k 0 output 1 explan one 0diff pair array 1 1 constraint 1 numslength 104 107 numsi 107 0 k 107 kdiffpairsinanarray
given 0index binari string length n appli two type oper choos index invert charact index 0 index inclus cost 1 choos index invert charact index index n 1 inclus cost n return minimum cost make charact string equal invert charact mean valu 0 becom 1 viceversa exampl 1 input 0011 output 2 explan appli second oper 2 obtain 0000 cost 2 shown 2 minimum cost make charact equal exampl 2 input 010101 output 9 explan appli first oper 2 obtain 101101 cost 3 appli first oper 1 obtain 011101 cost 2 appli first oper 0 obtain 111101 cost 1 appli second oper 4 obtain 111110 cost 2 appli second oper 5 obtain 111111 cost 1 total cost make charact equal 9 shown 9 minimum cost make charact equal constraint 1 slength n 105 si either 0 1 minimumcosttomakeallcharactersequ
given root binari tree calcul vertic order travers binari tree node posit row col left right children posit row 1 col 1 row 1 col 1 respect root tree 0 0 vertic order travers binari tree list toptobottom order column index start leftmost column end rightmost column may multipl node row column case sort node valu return vertic order travers binari tree exampl 1 input root 3920nullnull157 output 9315207 explan column 1 node 9 column column 0 node 3 15 column order top bottom column 1 node 20 column column 2 node 7 column exampl 2 input root 1234567 output 4215637 explan column 2 node 4 column column 1 node 2 column column 0 node 1 5 6 column 1 top come first 5 6 posit 2 0 order valu 5 6 column 1 node 3 column column 2 node 7 column exampl 3 input root 1234657 output 4215637 explan case exact exampl 2 node 5 6 swap note solut remain sinc 5 6 locat order valu constraint number node tree rang 1 1000 0 nodev 1000 verticalordertraversalofabinarytre
wrote mani posit integ string call num howev realiz forgot add comma seper differ number rememb list integ nondecreas integ lead zero return number possibl list integ could written get string num sinc answer may larg return modulo 109 7 exampl 1 input num 327 output 2 explan could written number 3 27 327 exampl 2 input num 094 output 0 explan number lead zero number must posit exampl 3 input num 0 output 0 explan number lead zero number must posit constraint 1 numlength 3500 num consist digit 0 9 numberofwaystoseparatenumb
given integ array card cardsi repres valu ith card pair card match card valu return minimum number consecut card pick pair match card among pick card imposs match card return 1 exampl 1 input card 342347 output 4 explan pick card 3423 contain match pair card valu 3 note pick card 4234 also optim exampl 2 input card 1053 output 1 explan way pick set consecut card contain pair match card constraint 1 cardslength 105 0 cardsi 106 minimumconsecutivecardstopickup
chef collect data satisfact level n dish chef cook dish 1 unit time liketim coeffici dish defin time taken cook dish includ previou dish multipli satisfact level ie timei satisfactioni return maximum sum liketim coeffici chef obtain dish prepar dish prepar order chef discard dish get maximum valu exampl 1 input satisfact 18059 output 14 explan remov second last dish maximum total liketim coeffici equal 11 02 53 14 dish prepar one unit time exampl 2 input satisfact 432 output 20 explan dish prepar order 21 32 43 20 exampl 3 input satisfact 145 output 0 explan peopl like dish dish prepar constraint n satisfactionlength 1 n 500 1000 satisfactioni 1000 reducingdish
given sort integ array arr contain 1 prime number integ arr uniqu also given integ k everi j 0 j arrlength consid fraction arri arrj return kth smallest fraction consid return answer array integ size 2 answer0 arri answer1 arrj exampl 1 input arr 1235 k 3 output 25 explan fraction consid sort order 15 13 25 12 35 23 third fraction 25 exampl 2 input arr 17 k 1 output 17 constraint 2 arrlength 1000 1 arri 3 104 arr0 1 arri prime number 0 number arr uniqu sort strictli increas order 1 k arrlength arrlength 1 2 follow solv problem better on2 complex kthsmallestprimefract
given string s1 s2 s3 find whether s3 form interleav s1 s2 interleav two string configur divid n substr respect s1 s2 sn t1 t2 tm n 1 interleav s1 t1 s2 t2 s3 t3 t1 s1 t2 s2 t3 s3 note b concaten string b exampl 1 input s1 aabcc s2 dbbca s3 aadbbcbcac output true explan one way obtain s3 split s1 s1 aa bc c s2 s2 dbbc interleav two split get aa dbbc bc c aadbbcbcac sinc s3 obtain interleav s1 s2 return true exampl 2 input s1 aabcc s2 dbbca s3 aadbbbaccc output fals explan notic imposs interleav s2 string obtain s3 exampl 3 input s1 s2 s3 output true constraint 0 s1length s2length 100 0 s3length 200 s1 s2 s3 consist lowercas english letter follow could solv use os2length addit memori space interleavingstr
sql schema tabl weather column name type id int recordd date temperatur int id primari key tabl tabl contain inform temperatur certain day write sql queri find date id higher temperatur compar previou date yesterday return result tabl order queri result format follow exampl exampl 1 input weather tabl id recordd temperatur 1 20150101 10 2 20150102 25 3 20150103 20 4 20150104 30 output id 2 4 explan 20150102 temperatur higher previou day 10 25 20150104 temperatur higher previou day 20 30 risingtemperatur
given 0index array num consist posit integ choos two indic j j sum digit number numsi equal numsj return maximum valu numsi numsj obtain possibl indic j satisfi condit exampl 1 input num 184336137 output 54 explan pair j satisfi condit 0 2 number sum digit equal 9 sum 18 36 54 1 4 number sum digit equal 7 sum 43 7 50 maximum sum obtain 54 exampl 2 input num 10121914 output 1 explan two number satisfi condit return 1 constraint 1 numslength 105 1 numsi 109 maxsumofapairwithequalsumofdigit
game play cat mous name cat mous environ repres grid size row x col element wall floor player cat mous food player repres charact ccatmmous floor repres charact walk wall repres charact walk food repres charact f walk one charact c f grid mous cat play accord follow rule mous move first take turn move turn cat mous jump one four direct left right jump wall outsid grid catjump mousejump maximum length cat mous jump time respect cat mous jump less maximum length stay posit allow mous jump cat game end 4 way cat occupi posit mous cat win cat reach food first cat win mous reach food first mous win mous get food within 1000 turn cat win given row x col matrix grid two integ catjump mousejump return true mous win game cat mous play optim otherwis return fals exampl 1 input grid fcm catjump 1 mousejump 2 output true explan cat catch mous turn get food mous exampl 2 input grid mcf catjump 1 mousejump 4 output true exampl 3 input grid mcf catjump 1 mousejump 3 output fals constraint row gridlength col gridilength 1 row col 8 gridij consist charact c f one charact c f grid 1 catjump mousejump 8 catandmouseii
given array posit integ num return array answer consist digit integ num separ order appear num separ digit integ get digit order exampl integ 10921 separ digit 10921 exampl 1 input num 13258377 output 13258377 explan separ 13 13 separ 25 25 separ 83 83 separ 77 77 answer 13258377 note answer contain separ order exampl 2 input num 7139 output 7139 explan separ integ num answer 7139 constraint 1 numslength 1000 1 numsi 105 separatethedigitsinanarray
given integ num rearrang digit num valu minim contain lead zero return rearrang number minim valu note sign number chang rearrang digit exampl 1 input num 310 output 103 explan possibl arrang digit 310 013 031 103 130 301 310 arrang smallest valu contain lead zero 103 exampl 2 input num 7605 output 7650 explan possibl arrang digit 7605 7650 6705 5076 0567 arrang smallest valu contain lead zero 7650 constraint 1015 num 1015 smallestvalueoftherearrangednumb
binari watch 4 led top repres hour 011 6 led bottom repres minut 059 led repres zero one least signific bit right exampl binari watch read 451 given integ turnedon repres number led current ignor pm return possibl time watch could repres may return answer order hour must contain lead zero exampl 0100 valid 100 minut must consist two digit may contain lead zero exampl 102 valid 1002 exampl 1 input turnedon 1 output 001002004008016032100200400800 exampl 2 input turnedon 9 output constraint 0 turnedon 10 binarywatch
given 0index 2d array grid size 2 x n gridrc repres number point posit r c matrix two robot play game matrix robot initi start 0 0 want reach 1 n1 robot may move right r c r c 1 r c r 1 c start game first robot move 0 0 1 n1 collect point cell path cell r c travers path gridrc set 0 second robot move 0 0 1 n1 collect point path note path may intersect one anoth first robot want minim number point collect second robot contrast second robot want maxim number point collect robot play optim return number point collect second robot exampl 1 input grid 254151 output 4 explan optim path taken first robot shown red optim path taken second robot shown blue cell visit first robot set 0 second robot collect 0 0 4 0 4 point exampl 2 input grid 331852 output 4 explan optim path taken first robot shown red optim path taken second robot shown blue cell visit first robot set 0 second robot collect 0 3 1 0 4 point exampl 3 input grid 131151331 output 7 explan optim path taken first robot shown red optim path taken second robot shown blue cell visit first robot set 0 second robot collect 0 1 3 3 0 7 point constraint gridlength 2 n gridrlength 1 n 5 104 1 gridrc 105 gridgam
given n x n matrix row column sort ascend order return kth smallest element matrix note kth smallest element sort order kth distinct element must find solut memori complex better on2 exampl 1 input matrix 159101113121315 k 8 output 13 explan element matrix 159101112131315 8th smallest number 13 exampl 2 input matrix 5 k 1 output 5 constraint n matrixlength matrixilength 1 n 300 109 matrixij 109 row column matrix guarante sort nondecreas order 1 k n2 follow could solv problem constant memori ie o1 memori complex could solv problem time complex solut may advanc interview may find read paper fun kthsmallestelementinasortedmatrix
given array tree treesi xi yi repres locat tree garden fenc entir garden use minimum length rope expens garden wellfenc tree enclos return coordin tree exactli locat fenc perimet may return answer order exampl 1 input tree 112220243342 output 1120423324 explan tree perimet fenc except tree 2 2 insid fenc exampl 2 input tree 122242 output 422212 explan fenc form line pass tree constraint 1 treeslength 3000 treesilength 2 0 xi yi 100 given posit uniqu erectthef
given array integ arr integ k valu arri said stronger valu arrj arri arrj median array arri arrj arri said stronger arrj arri arrj return list strongest k valu array return answer arbitrari order median middl valu order integ list formal length list n median element posit n 1 2 sort list 0index arr 6 3 7 2 11 n 5 median obtain sort array arr 3 2 6 7 11 median arrm 5 1 2 2 median 6 arr 7 22 17 3 n 4 median obtain sort array arr 7 3 17 22 median arrm 4 1 2 1 median 3 exampl 1 input arr 12345 k 2 output 51 explan median 3 element array sort strongest 51423 strongest 2 element 5 1 1 5 also accept answer pleas note although 5 3 1 3 5 stronger 1 5 1 exampl 2 input arr 11355 k 2 output 55 explan median 3 element array sort strongest 55113 strongest 2 element 5 5 exampl 3 input arr 6711768 k 5 output 118667 explan median 7 element array sort strongest 1186677 permut 118667 accept constraint 1 arrlength 105 105 arri 105 1 k arrlength thekstrongestvaluesinanarray
given 0index integ array num size n repres cost collect differ chocol cost collect chocol index numsi chocol differ type initi chocol index ith type one oper follow incur cost x simultan chang chocol ith type 1 mod nth type chocol return minimum cost collect chocol type given perform mani oper would like exampl 1 input num 20115 x 5 output 13 explan initi chocol type 012 buy 1st type chocol cost 1 perform oper cost 5 type chocol becom 120 buy 2nd type chocol cost 1 perform oper cost 5 chocol type becom 201 buy 0th type chocol cost 1 thu total cost becom 1 5 1 5 1 13 prove optim exampl 2 input num 123 x 4 output 6 explan collect three type chocol price without perform oper therefor total cost 1 2 3 6 constraint 1 numslength 1000 1 numsi 109 1 x 109 collectingchocol
sql schema tabl queue column name type personid int personnam varchar weight int turn int personid primari key column tabl tabl inform peopl wait bu personid turn column contain number 1 n n number row tabl turn determin order peopl board bu turn1 denot first person board turnn denot last person board weight weight person kilogram queue peopl wait board bu howev bu weight limit 1000 kilogram may peopl board write sql queri find personnam last person fit bu without exceed weight limit test case gener first person exceed weight limit queri result format follow exampl exampl 1 input queue tabl personid personnam weight turn 5 alic 250 1 4 bob 175 5 3 alex 350 2 6 john cena 400 3 1 winston 500 6 2 mari 200 4 output personnam john cena explan folow tabl order turn simplic turn id name weight total weight 1 5 alic 250 250 2 3 alex 350 600 3 6 john cena 400 1000 last person board 4 2 mari 200 1200 board 5 4 bob 175 6 1 winston 500 lastpersontofitinthebu
given 0index array n integ arr interv two element arr defin absolut differ indic formal interv arri arrj j return array interv length n intervalsi sum interv arri element arr valu arri note x absolut valu x exampl 1 input arr 2131233 output 4272445 explan index 0 anoth 2 found index 4 0 4 4 index 1 anoth 1 found index 3 1 3 2 index 2 two 3s found indic 5 6 2 5 2 6 7 index 3 anoth 1 found index 1 3 1 2 index 4 anoth 2 found index 0 4 0 4 index 5 two 3s found indic 2 6 5 2 5 6 4 index 6 two 3s found indic 2 5 6 2 6 5 5 exampl 2 input arr 1051010 output 5034 explan index 0 two 10 found indic 2 3 0 2 0 3 5 index 1 one 5 array sum interv ident element 0 index 2 two 10 found indic 0 3 2 0 2 3 3 index 3 two 10 found indic 0 2 3 0 3 2 4 constraint n arrlength 1 n 105 1 arri 105 intervalsbetweenidenticalel
given array integ height repres histogram bar height width bar 1 return area largest rectangl histogram exampl 1 input height 215623 output 10 explan histogram width bar 1 largest rectangl shown red area area 10 unit exampl 2 input height 24 output 4 constraint 1 heightslength 105 0 heightsi 104 largestrectangleinhistogram
alic caretak n garden want plant flower maxim total beauti garden given 0index integ array flower size n flowersi number flower alreadi plant ith garden flower alreadi plant remov given anoth integ newflow maximum number flower alic addit plant also given integ target full partial garden consid complet least target flower total beauti garden determin sum follow number complet garden multipli full minimum number flower incomplet garden multipli partial incomplet garden valu 0 return maximum total beauti alic obtain plant newflow flower exampl 1 input flower 1311 newflow 7 target 6 full 12 partial 1 output 14 explan alic plant 2 flower 0th garden 3 flower 1st garden 1 flower 2nd garden 1 flower 3rd garden garden 3622 plant total 2 3 1 1 7 flower 1 garden complet minimum number flower incomplet garden 2 thu total beauti 1 12 2 1 12 2 14 way plant flower obtain total beauti higher 14 exampl 2 input flower 2453 newflow 10 target 5 full 2 partial 6 output 30 explan alic plant 3 flower 0th garden 0 flower 1st garden 0 flower 2nd garden 2 flower 3rd garden garden 5455 plant total 3 0 0 2 5 flower 3 garden complet minimum number flower incomplet garden 4 thu total beauti 3 2 4 6 6 24 30 way plant flower obtain total beauti higher 30 note alic could make garden complet case would obtain lower total beauti constraint 1 flowerslength 105 1 flowersi target 105 1 newflow 1010 1 full partial 105 maximumtotalbeautyofthegarden
given integ n return structur uniqu bst binari search tree exactli n node uniqu valu 1 n return answer order exampl 1 input n 3 output 1null2null31null3221331nullnull232null1 exampl 2 input n 1 output 1 constraint 1 n 8 uniquebinarysearchtreesii
given n matrix one zero return mani squar submatric one exampl 1 input matrix 0111 1111 0111 output 15 explan 10 squar side 1 4 squar side 2 1 squar side 3 total number squar 10 4 1 15 exampl 2 input matrix 101 110 110 output 7 explan 6 squar side 1 1 squar side 2 total number squar 6 1 7 constraint 1 arrlength 300 1 arr0length 300 0 arrij 1 countsquaresubmatriceswithallon
2d plane n point integ coordin pointsi xi yi return minimum time second visit point order given point move accord rule 1 second either move vertic one unit move horizont one unit move diagon sqrt2 unit word move one unit vertic one unit horizont 1 second visit point order appear array allow pass point appear later order count visit exampl 1 input point 113410 output 7 explan one optim path 11 22 33 34 23 12 01 10 time 11 34 3 second time 34 10 4 second total time 7 second exampl 2 input point 3222 output 5 constraint pointslength n 1 n 100 pointsilength 2 1000 pointsi0 pointsi1 1000 minimumtimevisitingallpoint
given 2d integ array descript descriptionsi parenti childi islefti indic parenti parent childi binari tree uniqu valu furthermor islefti 1 childi left child parenti islefti 0 childi right child parenti construct binari tree describ descript return root test case gener binari tree valid exampl 1 input descript 2015120170502015080080191 output 502080151719 explan root node node valu 50 sinc parent result binari tree shown diagram exampl 2 input descript 121230341 output 12nullnull34 explan root node node valu 1 sinc parent result binari tree shown diagram constraint 1 descriptionslength 104 descriptionsilength 3 1 parenti childi 105 0 islefti 1 binari tree describ descript valid createbinarytreefromdescript
given two string s1 s2 return true s2 contain permut s1 fals otherwis word return true one s1 permut substr s2 exampl 1 input s1 ab s2 eidbaooo output true explan s2 contain one permut s1 ba exampl 2 input s1 ab s2 eidboaoo output fals constraint 1 s1length s2length 104 s1 s2 consist lowercas english letter permutationinstr
given integ array num return array answer answeri equal product element num except numsi product prefix suffix num guarante fit 32bit integ must write algorithm run time without use divis oper exampl 1 input num 1234 output 241286 exampl 2 input num 11033 output 00900 constraint 2 numslength 105 30 numsi 30 product prefix suffix num guarante fit 32bit integ follow solv problem o1 extra space complex output array count extra space space complex analysi productofarrayexceptself
randomizedcollect data structur contain collect number possibl duplic ie multiset support insert remov specif element also report random element implement randomizedcollect class randomizedcollect initi empti randomizedcollect object bool insertint val insert item val multiset even item alreadi present return true item present fals otherwis bool removeint val remov item val multiset present return true item present fals otherwis note val multipl occurr multiset remov one int getrandom return random element current multiset element probabl element return linearli relat number valu multiset contain must implement function class function work averag o1 time complex note test case gener getrandom call least one item randomizedcollect exampl 1 input randomizedcollect insert insert insert getrandom remov getrandom 1 1 2 1 output null true fals true 2 true 1 explan randomizedcollect randomizedcollect new randomizedcollect randomizedcollectioninsert1 return true sinc collect contain 1 insert 1 collect randomizedcollectioninsert1 return fals sinc collect contain 1 insert anoth 1 collect collect contain 11 randomizedcollectioninsert2 return true sinc collect contain 2 insert 2 collect collect contain 112 randomizedcollectiongetrandom getrandom return 1 probabl 23 return 2 probabl 13 randomizedcollectionremove1 return true sinc collect contain 1 remov 1 collect collect contain 12 randomizedcollectiongetrandom getrandom return 1 2 equal like constraint 231 val 231 1 2 105 call total made insert remov getrandom least one element data structur getrandom call insertdeletegetrandomo1duplicatesallow
play game integ start integ 1 want reach integ target one move either increment current integ one ie x x 1 doubl current integ ie x 2 x use increment oper number time howev use doubl oper maxdoubl time given two integ target maxdoubl return minimum number move need reach target start 1 exampl 1 input target 5 maxdoubl 0 output 4 explan keep increment 1 reach target exampl 2 input target 19 maxdoubl 2 output 7 explan initi x 1 increment 3 time x 4 doubl x 8 increment x 9 doubl x 18 increment x 19 exampl 3 input target 10 maxdoubl 4 output 4 explan initi x 1 increment x 2 doubl x 4 increment x 5 doubl x 10 constraint 1 target 109 0 maxdoubl 100 minimummovestoreachtargetscor
given array num consist posit integ take integ array revers digit add end array appli oper origin integ num return number distinct integ final array exampl 1 input num 113101231 output 6 explan includ revers number result array 11310123113112113 revers integ ad end array underlin note integ 10 revers becom 01 1 number distinct integ array 6 number 1 10 12 13 21 31 exampl 2 input num 222 output 1 explan includ revers number result array 222222 number distinct integ array 1 number 2 constraint 1 numslength 105 1 numsi 106 countnumberofdistinctintegersafterreverseoper
given nonneg integ x return squar root x round nearest integ return integ nonneg well must use builtin expon function oper exampl use powx 05 c x 05 python exampl 1 input x 4 output 2 explan squar root 4 2 return 2 exampl 2 input x 8 output 2 explan squar root 8 282842 sinc round nearest integ 2 return constraint 0 x 231 1 sqrtx
stand posit 0 infinit number line destin posit target make number move nummov move either go left right ith move start 1 nummov take step chosen direct given integ target return minimum number move requir ie minimum nummov reach destin exampl 1 input target 2 output 3 explan 1st move step 0 1 1 step 2nd move step 1 1 2 step 3rd move step 1 2 3 step exampl 2 input target 3 output 2 explan 1st move step 0 1 1 step 2nd move step 1 3 2 step constraint 109 target 109 target 0 reachanumb
given 0index integ array num target element target target index index numsi target return list target indic num sort num nondecreas order target indic return empti list return list must sort increas order exampl 1 input num 12523 target 2 output 12 explan sort num 12235 indic numsi 2 1 2 exampl 2 input num 12523 target 3 output 3 explan sort num 12235 index numsi 3 3 exampl 3 input num 12523 target 5 output 4 explan sort num 12235 index numsi 5 4 constraint 1 numslength 100 1 numsi target 100 findtargetindicesaftersortingarray
given integ array num length n repres permut integ rang 0 n 1 number global invers number differ pair j 0 j n numsi numsj number local invers number indic 0 n 1 numsi numsi 1 return true number global invers equal number local invers exampl 1 input num 102 output true explan 1 global invers 1 local invers exampl 2 input num 120 output fals explan 2 global invers 1 local invers constraint n numslength 1 n 105 0 numsi n integ num uniqu num permut number rang 0 n 1 globalandlocalinvers
given integ array num sort nondecreas order remov duplic inplac uniqu element appear twice rel order element kept sinc imposs chang length array languag must instead result place first part array num formal k element remov duplic first k element num hold final result matter leav beyond first k element return k place final result first k slot num alloc extra space anoth array must modifi input array inplac o1 extra memori custom judg judg test solut follow code int num input array int expectednum expect answer correct length int k removeduplicatesnum call implement assert k expectednumslength int 0 k assert numsi expectednumsi assert pass solut accept exampl 1 input num 111223 output 5 num 11223 explan function return k 5 first five element num 1 1 2 2 3 respect matter leav beyond return k henc underscor exampl 2 input num 001111233 output 7 num 0011233 explan function return k 7 first seven element num 0 0 1 1 2 3 3 respect matter leav beyond return k henc underscor constraint 1 numslength 3 104 104 numsi 104 num sort nondecreas order removeduplicatesfromsortedarrayii
n piec arrang line piec color either b given string color length n colorsi color ith piec alic bob play game take altern turn remov piec line game alic move first alic allow remov piec color neighbor also color allow remov piec color b bob allow remov piec color b neighbor also color b allow remov piec color alic bob remov piec edg line player make move turn player lose player win assum alic bob play optim return true alic win return fals bob win exampl 1 input color aaababb output true explan aaababb aababb alic move first remov second left sinc whose neighbor bob turn bob make move turn sinc bs whose neighbor b thu alic win return true exampl 2 input color aa output fals explan alic turn first two edg line move turn thu bob win return fals exampl 3 input color abbbbbbbaaa output fals explan abbbbbbbaaa abbbbbbbaa alic move first option remov second last right abbbbbbbaa abbbbbbaa next bob turn mani option b piec remov pick alic second turn piec remov thu bob win return fals constraint 1 colorslength 105 color consist letter b removecoloredpiecesifbothneighborsarethesamecolor
given array interv intervalsi li ri repres interv li ri remov interv cover anoth interv list interv b cover interv c c b return number remain interv exampl 1 input interv 143628 output 2 explan interv 36 cover 28 therefor remov exampl 2 input interv 1423 output 1 constraint 1 intervalslength 1000 intervalsilength 2 0 li ri 105 given interv uniqu removecoveredinterv
given sort uniqu integ array num rang ab set integ b inclus return smallest sort list rang cover number array exactli element num cover exactli one rang integ x x one rang num rang ab list output ab b b exampl 1 input num 012457 output 02457 explan rang 02 02 45 45 77 7 exampl 2 input num 0234689 output 024689 explan rang 00 0 24 24 66 6 89 89 constraint 0 numslength 20 231 numsi 231 1 valu num uniqu num sort ascend order summaryrang
given array target consist distinct integ anoth integ array arr duplic one oper insert integ posit arr exampl arr 1412 add 3 middl make 14312 note insert integ begin end array return minimum number oper need make target subsequ arr subsequ array new array gener origin array delet element possibl none without chang remain element rel order exampl 274 subsequ 4237214 underlin element 242 exampl 1 input target 513 arr 94234 output 2 explan add 5 1 way make arr 5941234 target subsequ arr exampl 2 input target 648132 arr 47623861 output 3 constraint 1 targetlength arrlength 105 1 targeti arri 109 target contain duplic minimumoperationstomakeasubsequ
given head two singli linkedlist heada headb return node two list intersect two link list intersect return null exampl follow two link list begin intersect node c1 test case gener cycl anywher entir link structur note link list must retain origin structur function return custom judg input judg given follow program given input intersectv valu node intersect occur 0 intersect node lista first link list listb second link list skipa number node skip ahead lista start head get intersect node skipb number node skip ahead listb start head get intersect node judg creat link structur base input pass two head heada headb program correctli return intersect node solut accept exampl 1 input intersectv 8 lista 41845 listb 561845 skipa 2 skipb 3 output intersect 8 explan intersect node valu 8 note must 0 two list intersect head read 41845 head b read 561845 2 node intersect node 3 node intersect node b note intersect node valu 1 node valu 1 b 2nd node 3rd node b differ node refer word point two differ locat memori node valu 8 b 3rd node 4th node b point locat memori exampl 2 input intersectv 2 lista 19124 listb 324 skipa 3 skipb 1 output intersect 2 explan intersect node valu 2 note must 0 two list intersect head read 19124 head b read 324 3 node intersect node 1 node intersect node b exampl 3 input intersectv 0 lista 264 listb 15 skipa 3 skipb 2 output intersect explan head read 264 head b read 15 sinc two list intersect intersectv must 0 skipa skipb arbitrari valu explan two list intersect return null constraint number node lista number node listb n 1 n 3 104 1 nodev 105 0 skipa 0 skipb n intersectv 0 lista listb intersect intersectv listaskipa listbskipb lista listb intersect follow could write solut run om n time use o1 memori intersectionoftwolinkedlist
sql schema tabl person column name type id int email varchar id primari key column tabl row tabl contain email email contain uppercas letter write sql queri report duplic email note guarante email field null return result tabl order queri result format follow exampl exampl 1 input person tabl id email 1 abcom 2 cdcom 3 abcom output email abcom explan abcom repeat two time duplicateemail
given string num repres larg integ integ k call integ wonder permut digit num greater valu num mani wonder integ howev care smallestvalu one exampl num 5489355142 1st smallest wonder integ 5489355214 2nd smallest wonder integ 5489355241 3rd smallest wonder integ 5489355412 4th smallest wonder integ 5489355421 return minimum number adjac digit swap need appli num reach kth smallest wonder integ test gener way kth smallest wonder integ exist exampl 1 input num 5489355142 k 4 output 2 explan 4th smallest wonder number 5489355421 get number swap index 7 index 8 5489355142 5489355412 swap index 8 index 9 5489355412 5489355421 exampl 2 input num 11112 k 4 output 4 explan 4th smallest wonder number 21111 get number swap index 3 index 4 11112 11121 swap index 2 index 3 11121 11211 swap index 1 index 2 11211 12111 swap index 0 index 1 12111 21111 exampl 3 input num 00123 k 1 output 1 explan 1st smallest wonder number 00132 get number swap index 3 index 4 00123 00132 constraint 2 numlength 1000 1 k 1000 num consist digit minimumadjacentswapstoreachthekthsmallestnumb
given array queri posit integ 1 process queriesi i0 iquerieslength1 accord follow rule begin permut p123m current find posit queriesi permut p index 0 move begin permut p notic posit queriesi p result queriesi return array contain result given queri exampl 1 input queri 3121 5 output 2121 explan queri process follow i0 queriesi3 p12345 posit 3 p 2 move 3 begin p result p31245 i1 queriesi1 p31245 posit 1 p 1 move 1 begin p result p13245 i2 queriesi2 p13245 posit 2 p 2 move 2 begin p result p21345 i3 queriesi1 p21345 posit 1 p 1 move 1 begin p result p12345 therefor array contain result 2121 exampl 2 input queri 4122 4 output 3120 exampl 3 input queri 75583 8 output 65075 constraint 1 103 1 querieslength 1 queriesi queriesonapermutationwithkey
given array interv interv intervalsi starti endi return minimum number interv need remov make rest interv nonoverlap exampl 1 input interv 12233413 output 1 explan 13 remov rest interv nonoverlap exampl 2 input interv 121212 output 2 explan need remov two 12 make rest interv nonoverlap exampl 3 input interv 1223 output 0 explan dont need remov interv sinc theyr alreadi nonoverlap constraint 1 intervalslength 105 intervalsilength 2 5 104 starti endi 5 104 nonoverlappinginterv
string valid parenthes string denot vp meet one follow empti string singl charact equal written ab concaten b b vpss written vp similarli defin nest depth depth vp follow depth 0 depthc 0 c string singl charact equal deptha b maxdeptha depthb b vpss depth 1 deptha vp exampl vpss nest depth 0 1 2 vpss given vp repres string return nest depth exampl 1 input 123841 output 3 explan digit 8 insid 3 nest parenthes string exampl 2 input 123 output 3 constraint 1 slength 100 consist digit 09 charact guarante parenthes express vp maximumnestingdepthoftheparenthes
given root binari tree integ limit delet insuffici node tree simultan return root result binari tree node insuffici everi root leaf path intersect node sum strictli less limit leaf node children exampl 1 input root 12349999789999912139914 limit 1 output 1234nullnull789null14 exampl 2 input root 54811null17471nullnull53 limit 22 output 54811null1747nullnullnull5 exampl 3 input root 1235null4nul limit 1 output 1null34 constraint number node tree rang 1 5000 105 nodev 105 109 limit 109 insufficientnodesinroottoleafpath
given string num repres nonneg integ num integ k return smallest possibl integ remov k digit num exampl 1 input num 1432219 k 3 output 1219 explan remov three digit 4 3 2 form new number 1219 smallest exampl 2 input num 10200 k 1 output 200 explan remov lead 1 number 200 note output must contain lead zero exampl 3 input num 10 k 2 output 0 explan remov digit number left noth 0 constraint 1 k numlength 105 num consist digit num lead zero except zero removekdigit
build tabl n row 1index start write 0 1st row everi subsequ row look previou row replac occurr 0 01 occurr 1 10 exampl n 3 1st row 0 2nd row 01 3rd row 0110 given two integ n k return kth 1index symbol nth row tabl n row exampl 1 input n 1 k 1 output 0 explan row 1 0 exampl 2 input n 2 k 1 output 0 explan row 1 0 row 2 01 exampl 3 input n 2 k 2 output 1 explan row 1 0 row 2 01 constraint 1 n 30 1 k 2n 1 kthsymbolingrammar
given array num defin run sum array runningsumi sumnums0…numsi return run sum num exampl 1 input num 1234 output 13610 explan run sum obtain follow 1 12 123 1234 exampl 2 input num 11111 output 12345 explan run sum obtain follow 1 11 111 1111 11111 exampl 3 input num 312101 output 3461617 constraint 1 numslength 1000 106 numsi 106 runningsumof1darray
gene string repres 8charact long string choic c g suppos need investig mutat gene string startgen gene string endgen one mutat defin one singl charact chang gene string exampl aaccggtt aaccggta one mutat also gene bank bank record valid gene mutat gene must bank make valid gene string given two gene string startgen endgen gene bank bank return minimum number mutat need mutat startgen endgen mutat return 1 note start point assum valid might includ bank exampl 1 input startgen aaccggtt endgen aaccggta bank aaccggta output 1 exampl 2 input startgen aaccggtt endgen aaacggta bank aaccggtaaaccgctaaaacggta output 2 constraint 0 banklength 10 startgenelength endgenelength bankilength 8 startgen endgen banki consist charact c g minimumgeneticmut
given integ array num handl multipl queri follow type updat valu element num calcul sum element num indic left right inclus left right implement numarray class numarrayint num initi object integ array num void updateint index int val updat valu numsindex val int sumrangeint left int right return sum element num indic left right inclus ie numsleft numsleft 1 numsright exampl 1 input numarray sumrang updat sumrang 1 3 5 0 2 1 2 0 2 output null 9 null 8 explan numarray numarray new numarray1 3 5 numarraysumrange0 2 return 1 3 5 9 numarrayupdate1 2 num 1 2 5 numarraysumrange0 2 return 1 2 5 8 constraint 1 numslength 3 104 100 numsi 100 0 index numslength 100 val 100 0 left right numslength 3 104 call made updat sumrang rangesumquerymut
n garden label 1 n array path pathsi xi yi describ bidirect path garden xi garden yi garden want plant one 4 type flower garden 3 path come leav task choos flower type garden two garden connect path differ type flower return choic array answer answeri type flower plant i1th garden flower type denot 1 2 3 4 guarante answer exist exampl 1 input n 3 path 122331 output 123 explan garden 1 2 differ type garden 2 3 differ type garden 3 1 differ type henc 123 valid answer valid answer includ 124 142 321 exampl 2 input n 4 path 1234 output 1212 exampl 3 input n 4 path 122334411324 output 1234 constraint 1 n 104 0 pathslength 2 104 pathsilength 2 1 xi yi n xi yi everi garden 3 path come leav flowerplantingwithnoadjac
undirect weight connect graph given posit integ n denot graph n node label 1 n array edg edgesi ui vi weighti denot edg node ui vi weight equal weighti path node start node end sequenc node z0 z1 z2 zk z0 start zk end edg zi zi1 0 k1 distanc path sum weight edg path let distancetolastnodex denot shortest distanc path node n node x restrict path path also satisfi distancetolastnodezi distancetolastnodezi1 0 k1 return number restrict path node 1 node n sinc number may larg return modulo 109 7 exampl 1 input n 5 edg 1231332311425223515410 output 3 explan circl contain node number black distancetolastnod valu blue three restrict path 1 1 2 5 2 1 2 3 5 3 1 3 5 exampl 2 input n 7 edg 131412734253561672753264 output 1 explan circl contain node number black distancetolastnod valu blue restrict path 1 3 7 constraint 1 n 2 104 n 1 edgeslength 4 104 edgesilength 3 1 ui vi n ui vi 1 weighti 105 one edg two node least one path two node numberofrestrictedpathsfromfirsttolastnod
given 0index string text anoth 0index string pattern length 2 consist lowercas english letter add either pattern0 pattern1 anywher text exactli note charact ad even begin end text return maximum number time pattern occur subsequ modifi text subsequ string deriv anoth string delet charact without chang order remain charact exampl 1 input text abdcdbc pattern ac output 4 explan add pattern0 text1 text2 get abadcdbc number time ac occur subsequ 4 string 4 subsequ ac ad charact text aabdcdbc abdacdbc howev string abdcadbc abdccdbc abdcdbcc although obtain 3 subsequ ac thu suboptim shown possibl get 4 subsequ ac ad one charact exampl 2 input text aabb pattern ab output 6 explan string obtain text 6 subsequ ab aaabb aaabb aabbb constraint 1 textlength 105 patternlength 2 text pattern consist lowercas english letter maximizenumberofsubsequencesinastr
given 0index 2d integ array tire tiresi fi ri indic ith tire finish xth success lap fi rix1 second exampl fi 3 ri 2 tire would finish 1st lap 3 second 2nd lap 3 2 6 second 3rd lap 3 22 12 second etc also given integ changetim integ numlap race consist numlap lap may start race tire unlimit suppli tire everi lap may chang given tire includ current tire type wait changetim second return minimum time finish race exampl 1 input tire 2334 changetim 5 numlap 4 output 21 explan lap 1 start tire 0 finish lap 2 second lap 2 continu tire 0 finish lap 2 3 6 second lap 3 chang tire new tire 0 5 second finish lap anoth 2 second lap 4 continu tire 0 finish lap 2 3 6 second total time 2 6 5 2 6 21 second minimum time complet race 21 second exampl 2 input tire 1102234 changetim 6 numlap 5 output 25 explan lap 1 start tire 1 finish lap 2 second lap 2 continu tire 1 finish lap 2 2 4 second lap 3 chang tire new tire 1 6 second finish lap anoth 2 second lap 4 continu tire 1 finish lap 2 2 4 second lap 5 chang tire tire 0 6 second finish lap anoth 1 second total time 2 4 6 2 4 6 1 25 second minimum time complet race 25 second constraint 1 tireslength 105 tiresilength 2 1 fi changetim 105 2 ri 105 1 numlap 1000 minimumtimetofinishtherac
given integ array num design algorithm randomli shuffl array permut array equal like result shuffl implement solut class solutionint num initi object integ array num int reset reset array origin configur return int shuffl return random shuffl array exampl 1 input solut shuffl reset shuffl 1 2 3 output null 3 1 2 1 2 3 1 3 2 explan solut solut new solution1 2 3 solutionshuffl shuffl array 123 return result permut 123 must equal like return exampl return 3 1 2 solutionreset reset array back origin configur 123 return 1 2 3 solutionshuffl return random shuffl array 123 exampl return 1 3 2 constraint 1 numslength 50 106 numsi 106 element num uniqu 104 call total made reset shuffl shuffleanarray
given string columntitl repres column titl appear excel sheet return correspond column number exampl 1 b 2 c 3 z 26 aa 27 ab 28 exampl 1 input columntitl output 1 exampl 2 input columntitl ab output 28 exampl 3 input columntitl zy output 701 constraint 1 columntitlelength 7 columntitl consist uppercas english letter columntitl rang fxshrxw excelsheetcolumnnumb
sentenc string singlespac separ word word contain digit lowercas letter dollar sign word repres price sequenc digit preced dollar sign exampl 100 23 6 repres price 100 1e5 given string sentenc repres sentenc integ discount word repres price appli discount discount price updat word sentenc updat price repres exactli two decim place return string repres modifi sentenc note price contain 10 digit exampl 1 input sentenc 1 2 5 candi shop discount 50 output 050 100 5 candi shop explan word repres price 1 2 50 discount 1 yield 050 1 replac 050 50 discount 2 yield 1 sinc need exactli 2 decim place price replac 2 100 exampl 2 input sentenc 1 2 3 4 5 6 7 8 9 10 discount 100 output 1 2 000 4 000 000 7 8 000 10 explan appli 100 discount price result 0 word repres price 3 5 6 9 replac 000 constraint 1 sentencelength 105 sentenc consist lowercas english letter digit sentenc lead trail space word sentenc separ singl space price posit number without lead zero price 10 digit 0 discount 100 applydiscounttopric
given integ n return number rang 1 n sort lexicograph order must write algorithm run time use o1 extra space exampl 1 input n 13 output 11011121323456789 exampl 2 input n 2 output 12 constraint 1 n 5 104 lexicographicalnumb
n packag tri place box one packag box supplier produc box differ size infinit suppli packag place box size packag less equal size box packag size given integ array packag packagesi size ith packag supplier given 2d integ array box boxesj array box size jth supplier produc want choos singl supplier use box total wast space minim packag box defin space wast size box size packag total wast space sum space wast box exampl fit packag size 235 supplier offer box size 48 fit packag size2 size3 two box size4 packag size5 box size8 would result wast 42 43 85 6 return minimum total wast space choos box supplier optim 1 imposs fit packag insid box sinc answer may larg return modulo 109 7 exampl 1 input packag 235 box 4828 output 6 explan optim choos first supplier use two size4 box one size8 box total wast 42 43 85 6 exampl 2 input packag 235 box 142334 output 1 explan box packag size 5 fit exampl 3 input packag 358101112 box 1211910514 output 9 explan optim choos third supplier use two size5 box two size10 box two size14 box total wast 53 55 108 1010 1411 1412 9 constraint n packageslength boxeslength 1 n 105 1 105 1 packagesi 105 1 boxesjlength 105 1 boxesjk 105 sumboxesjlength 105 element boxesj distinct minimumspacewastedfrompackag
fibonacci number commonli denot fn form sequenc call fibonacci sequenc number sum two preced one start 0 1 f0 0 f1 1 fn fn 1 fn 2 n 1 given n calcul fn exampl 1 input n 2 output 1 explan f2 f1 f0 1 0 1 exampl 2 input n 3 output 2 explan f3 f2 f1 1 1 2 exampl 3 input n 4 output 3 explan f4 f3 f2 2 1 3 constraint 0 n 30 fibonaccinumb
given integ n undirect graph n vertic number 0 n 1 given 2d integ array edg edgesi ai bi denot exist undirect edg connect vertic ai bi return number complet connect compon graph connect compon subgraph graph exist path two vertic vertex subgraph share edg vertex outsid subgraph connect compon said complet exist edg everi pair vertic exampl 1 input n 6 edg 01021234 output 3 explan pictur one see compon graph complet exampl 2 input n 6 edg 0102123435 output 1 explan compon contain vertic 0 1 2 complet sinc edg everi pair two vertic hand compon contain vertic 3 4 5 complet sinc edg vertic 4 5 thu number complet compon graph 1 constraint 1 n 50 0 edgeslength n n 1 2 edgesilength 2 0 ai bi n 1 ai bi repeat edg countthenumberofcompletecompon
given object array return empti empti object contain keyvalu pair empti array contain element may assum object array output jsonpars exampl 1 input obj x 5 42 output fals explan object 2 keyvalu pair empti exampl 2 input obj output true explan object doesnt keyvalu pair empti exampl 3 input obj null fals 0 output fals explan array 3 element empti constraint 2 jsonstringifyobjlength 105 solv o1 time isobjectempti
given 2d integ array interv intervalsi lefti righti describ ith interv start lefti end righti inclus size interv defin number integ contain formal righti lefti 1 also given integ array queri answer jth queri size smallest interv lefti queriesj righti interv exist answer 1 return array contain answer queri exampl 1 input interv 14243644 queri 2345 output 3314 explan queri process follow queri 2 interv 24 smallest interv contain 2 answer 4 2 1 3 queri 3 interv 24 smallest interv contain 3 answer 4 2 1 3 queri 4 interv 44 smallest interv contain 4 answer 4 4 1 1 queri 5 interv 36 smallest interv contain 5 answer 6 3 1 4 exampl 2 input interv 2325182025 queri 219522 output 2146 explan queri process follow queri 2 interv 23 smallest interv contain 2 answer 3 2 1 2 queri 19 none interv contain 19 answer 1 queri 5 interv 25 smallest interv contain 5 answer 5 2 1 4 queri 22 interv 2025 smallest interv contain 22 answer 25 20 1 6 constraint 1 intervalslength 105 1 querieslength 105 intervalsilength 2 1 lefti righti 107 1 queriesj 107 minimumintervaltoincludeeachqueri
parenthes string nonempti string consist valid follow condit true written ab concaten b b valid parenthes string written valid parenthes string given parenthes string string lock length n lock binari string consist 0s 1s index lock lockedi 1 chang si lockedi 0 chang si either return true make valid parenthes string otherwis return fals exampl 1 input lock 010100 output true explan locked1 1 locked3 1 chang s1 s3 chang s0 s4 leav s2 s5 unchang make valid exampl 2 input lock 0000 output true explan need make chang alreadi valid exampl 3 input lock 0 output fals explan lock permit us chang s0 chang s0 either make valid constraint n slength lockedlength 1 n 105 si either lockedi either 0 1 checkifaparenthesesstringcanbevalid
given nonneg float point number round two decim place celsiu denot temperatur celsiu convert celsiu kelvin fahrenheit return array an kelvin fahrenheit return array an answer within 105 actual answer accept note kelvin celsiu 27315 fahrenheit celsiu 180 3200 exampl 1 input celsiu 3650 output 309650009770000 explan temperatur 3650 celsiu convert kelvin 30965 convert fahrenheit 9770 exampl 2 input celsiu 12211 output 3952600025179800 explan temperatur 12211 celsiu convert kelvin 39526 convert fahrenheit 251798 constraint 0 celsiu 1000 convertthetemperatur
given integ array arr return number distinct bitwis or nonempti subarray arr bitwis subarray bitwis integ subarray bitwis subarray one integ integ subarray contigu nonempti sequenc element within array exampl 1 input arr 0 output 1 explan one possibl result 0 exampl 2 input arr 112 output 3 explan possibl subarray 1 1 2 1 1 1 2 1 1 2 yield result 1 1 2 1 3 3 3 uniqu valu answer 3 exampl 3 input arr 124 output 6 explan possibl result 1 2 3 4 6 7 constraint 1 arrlength 5 104 0 arri 109 bitwiseorsofsubarray
given root binari tree return frequent subtre sum tie return valu highest frequenc order subtre sum node defin sum node valu form subtre root node includ node exampl 1 input root 523 output 234 exampl 2 input root 525 output 2 constraint number node tree rang 1 104 105 nodev 105 mostfrequentsubtreesum
binari matrix matrix element either 0 1 given quadtree1 quadtree2 quadtree1 repres n n binari matrix quadtree2 repres anoth n n binari matrix return quadtre repres n n binari matrix result logic bitwis two binari matrix repres quadtree1 quadtree2 notic assign valu node true fals isleaf fals accept answer quadtre tree data structur intern node exactli four children besid node two attribut val true node repres grid 1s fals node repres grid 0s isleaf true node leaf node tree fals node four children class node public boolean val public boolean isleaf public node topleft public node topright public node bottomleft public node bottomright construct quadtre twodimension area use follow step current grid valu ie 1s 0s set isleaf true set val valu grid set four children null stop current grid differ valu set isleaf fals set val valu divid current grid four subgrid shown photo recurs children proper subgrid want know quadtre refer wiki quadtre format inputoutput repres serial format quadtre use level order travers null signifi path termin node exist similar serial binari tree differ node repres list isleaf val valu isleaf val true repres 1 list isleaf val valu isleaf val fals repres 0 exampl 1 input quadtree1 0111111010 quadtree2 0111011110nullnullnullnull10101111 output 0011111110 explan quadtree1 quadtree2 shown see binari matrix repres quadtre appli logic bitwis two binari matric get binari matrix repres result quadtre notic binari matric shown illustr dont construct binari matrix get result tree exampl 2 input quadtree1 10 quadtree2 10 output 10 explan tree repres binari matrix size 11 matrix contain zero result matrix size 11 also zero constraint quadtree1 quadtree2 valid quadtre repres n n grid n 2x 0 x 9 logicaloroftwobinarygridsrepresentedasquadtre
task write program popular bank autom incom transact transfer deposit withdraw bank n account number 1 n initi balanc account store 0index integ array balanc 1th account initi balanc balancei execut valid transact transact valid given account number 1 n amount money withdrawn transfer less equal balanc account implement bank class banklong balanc initi object 0index integ array balanc boolean transferint account1 int account2 long money transfer money dollar account number account1 account number account2 return true transact success fals otherwis boolean depositint account long money deposit money dollar account number account return true transact success fals otherwis boolean withdrawint account long money withdraw money dollar account number account return true transact success fals otherwis exampl 1 input bank withdraw transfer deposit transfer withdraw 10 100 20 50 30 3 10 5 1 20 5 20 3 4 15 10 50 output null true true true fals fals explan bank bank new bank10 100 20 50 30 bankwithdraw3 10 return true account 3 balanc 20 valid withdraw 10 account 3 20 10 10 banktransfer5 1 20 return true account 5 balanc 30 valid transfer 20 account 5 30 20 10 account 1 10 20 30 bankdeposit5 20 return true valid deposit 20 account 5 account 5 10 20 30 banktransfer3 4 15 return fals current balanc account 3 10 invalid transfer 15 bankwithdraw10 50 return fals invalid account 10 exist constraint n balancelength 1 n account account1 account2 105 0 balancei money 1012 104 call made function transfer deposit withdraw simplebanksystem
exist undirect unroot tree n node index 0 n 1 given integ n 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree node associ price given integ array price pricei price ith node price sum given path sum price node lie path addit given 2d integ array trip tripsi starti endi indic start ith trip node starti travel node endi path like perform first trip choos nonadjac node halv price return minimum total price sum perform given trip exampl 1 input n 4 edg 011213 price 22106 trip 032123 output 23 explan diagram denot tree root node 2 first part show initi tree second part show tree choos node 0 2 3 make price half 1st trip choos path 013 price sum path 1 2 3 6 2nd trip choos path 21 price sum path 2 5 7 3rd trip choos path 213 price sum path 5 2 3 10 total price sum trip 6 7 10 23 proven 23 minimum answer achiev exampl 2 input n 2 edg 01 price 22 trip 00 output 1 explan diagram denot tree root node 0 first part show initi tree second part show tree choos node 0 make price half 1st trip choos path 0 price sum path 1 total price sum trip 1 proven 1 minimum answer achiev constraint 1 n 50 edgeslength n 1 0 ai bi n 1 edg repres valid tree pricelength n pricei even integ 1 pricei 1000 1 tripslength 100 0 starti endi n 1 minimizethetotalpriceofthetrip
given integ array num return integ array count countsi number smaller element right numsi exampl 1 input num 5261 output 2110 explan right 5 2 smaller element 2 1 right 2 1 smaller element 1 right 6 1 smaller element 1 right 1 0 smaller element exampl 2 input num 1 output 0 exampl 3 input num 11 output 00 constraint 1 numslength 105 104 numsi 104 countofsmallernumbersafterself
given input string pattern p implement wildcard pattern match support match singl charact match sequenc charact includ empti sequenc match cover entir input string partial exampl 1 input aa p output fals explan match entir string aa exampl 2 input aa p output true explan match sequenc exampl 3 input cb p output fals explan match c second letter match b constraint 0 slength plength 2000 contain lowercas english letter p contain lowercas english letter wildcardmatch
given integ array num return number triplet chosen array make triangl take side length triangl exampl 1 input num 2234 output 3 explan valid combin 234 use first 2 234 use second 2 223 exampl 2 input num 4234 output 4 constraint 1 numslength 1000 0 numsi 1000 validtrianglenumb
given integ array num integ goal want choos subsequ num sum element closest possibl goal sum subsequ element sum want minim absolut differ abssum goal return minimum possibl valu abssum goal note subsequ array array form remov element possibl none origin array exampl 1 input num 5735 goal 6 output 0 explan choos whole array subsequ sum 6 equal goal absolut differ 0 exampl 2 input num 79152 goal 5 output 1 explan choos subsequ 792 sum 4 absolut differ abs4 5 abs1 1 minimum exampl 3 input num 123 goal 7 output 7 constraint 1 numslength 40 107 numsi 107 109 goal 109 closestsubsequencesum
sql schema pandan schema tabl employe column name type id int name varchar depart varchar managerid int sql id primari key column tabl row tabl indic name employe depart id manag managerid null employe manag employe manag themself find manag least five direct report return result tabl order result format follow exampl exampl 1 input employe tabl id name depart managerid 101 john none 102 dan 101 103 jame 101 104 ami 101 105 ann 101 106 ron b 101 output name john managerswithatleast5directreport
given unsort array integ num return length longest continu increas subsequ ie subarray subsequ must strictli increas continu increas subsequ defin two indic l r l r numsl numsl 1 numsr 1 numsr l r numsi numsi 1 exampl 1 input num 13547 output 3 explan longest continu increas subsequ 135 length 3 even though 1357 increas subsequ continu element 5 7 separ element 4 exampl 2 input num 22222 output 1 explan longest continu increas subsequ 2 length 1 note must strictli increas constraint 1 numslength 104 109 numsi 109 longestcontinuousincreasingsubsequ
given binari string binari consist 0s 1s appli follow oper number time oper 1 number contain substr 00 replac 10 exampl 00010 10010 oper 2 number contain substr 10 replac 01 exampl 00010 00001 return maximum binari string obtain number oper binari string x greater binari string xs decim represent greater ys decim represent exampl 1 input binari 000110 output 111011 explan valid transform sequenc 000110 000101 000101 100101 100101 110101 110101 110011 110011 111011 exampl 2 input binari 01 output 01 explan 01 transform constraint 1 binarylength 105 binari consist 0 1 maximumbinarystringafterchang
design algorithm accept stream integ retriev product last k integ stream implement productofnumb class productofnumb initi object empti stream void addint num append integ num stream int getproductint k return product last k number current list assum alway current list least k number test case gener time product contigu sequenc number fit singl 32bit integ without overflow exampl input productofnumbersaddaddaddaddaddgetproductgetproductgetproductaddgetproduct 3025423482 output nullnullnullnullnullnull20400null32 explan productofnumb productofnumb new productofnumb productofnumbersadd3 3 productofnumbersadd0 30 productofnumbersadd2 302 productofnumbersadd5 3025 productofnumbersadd4 30254 productofnumbersgetproduct2 return 20 product last 2 number 5 4 20 productofnumbersgetproduct3 return 40 product last 3 number 2 5 4 40 productofnumbersgetproduct4 return 0 product last 4 number 0 2 5 4 0 productofnumbersadd8 302548 productofnumbersgetproduct2 return 32 product last 2 number 4 8 32 constraint 0 num 100 1 k 4 104 4 104 call made add getproduct product stream point time fit 32bit integ productofthelastknumb
sql schema tabl product column name type productid int productnam varchar productcategori varchar productid primari key tabl tabl contain data compani product tabl order column name type productid int orderd date unit int primari key tabl may duplic row productid foreign key product tabl unit number product order orderd write sql queri get name product least 100 unit order februari 2020 amount return result tabl order queri result format follow exampl exampl 1 input product tabl productid productnam productcategori 1 leetcod solut book 2 jewel stringolog book 3 hp laptop 4 lenovo laptop 5 leetcod kit tshirt order tabl productid orderd unit 1 20200205 60 1 20200210 70 2 20200118 30 2 20200211 80 3 20200217 2 3 20200224 3 4 20200301 20 4 20200304 30 4 20200304 60 5 20200225 50 5 20200227 50 5 20200301 50 output productnam unit leetcod solut 130 leetcod kit 100 explan product productid 1 order februari total 60 70 130 product productid 2 order februari total 80 product productid 3 order februari total 2 3 5 product productid 4 order februari 2020 product productid 5 order februari total 50 50 100 listtheproductsorderedinaperiod
write bash script calcul frequenc word text file wordstxt simplic sake may assum wordstxt contain lowercas charact space charact word must consist lowercas charact word separ one whitespac charact exampl assum wordstxt follow content day sunni sunni script output follow sort descend frequenc 4 3 sunni 2 day 1 note dont worri handl tie guarante word frequenc count uniqu could write onelin use unix pipe wordfrequ
given two string b length choos index split string index split two string aprefix asuffix aprefix asuffix split b two string bprefix bsuffix b bprefix bsuffix check aprefix bsuffix bprefix asuffix form palindrom split string sprefix ssuffix either ssuffix sprefix allow empti exampl abc abc bc ab c abc valid split return true possibl form palindrom string otherwis return fals notic x denot concaten string x exampl 1 input x b output true explain either b palindrom answer true sinc split follow way aprefix asuffix x bprefix bsuffix aprefix bsuffix palindrom exampl 2 input xbdef b xecab output fals exampl 3 input ulacfd b jizalu output true explain split index 3 aprefix ula asuffix cfd bprefix jiz bsuffix alu aprefix bsuffix ula alu ulaalu palindrom constraint 1 alength blength 105 alength blength b consist lowercas english letter splittwostringstomakepalindrom
given posit integ num return number posit integ less equal num whose digit sum even digit sum posit integ sum digit exampl 1 input num 4 output 2 explan integ less equal 4 whose digit sum even 2 4 exampl 2 input num 30 output 14 explan 14 integ less equal 30 whose digit sum even 2 4 6 8 11 13 15 17 19 20 22 24 26 28 constraint 1 num 1000 countintegerswithevendigitsum
given string robot current hold empti string appli one follow oper empti remov first charact string give robot robot append charact string remov last charact string give robot robot write charact paper return lexicograph smallest string written paper exampl 1 input zza output azz explan let p denot written string initi p szza perform first oper three time p tzza perform second oper three time pazz exampl 2 input bac output abc explan let p denot written string perform first oper twice p sc tba perform second oper twice pab sc perform first oper pab tc perform second oper pabc exampl 3 input bdda output addb explan let p denot written string initi p sbdda perform first oper four time p tbdda perform second oper four time paddb constraint 1 slength 105 consist english lowercas letter usingarobottoprintthelexicographicallysmalleststr
design special dictionari search word prefix suffix implement wordfilt class wordfilterstr word initi object word dictionari fstring pref string suff return index word dictionari prefix pref suffix suff one valid index return largest word dictionari return 1 exampl 1 input wordfilt f appl e output null 0 explan wordfilt wordfilt new wordfilterappl wordfilterfa e return 0 word index 0 prefix suffix e constraint 1 wordslength 104 1 wordsilength 7 1 preflength sufflength 7 wordsi pref suff consist lowercas english letter 104 call made function f prefixandsuffixsearch
largestperimetertriangl
given rectangular cake size h x w two array integ horizontalcut verticalcut horizontalcutsi distanc top rectangular cake ith horizont cut similarli verticalcutsj distanc left rectangular cake jth vertic cut return maximum area piec cake cut horizont vertic posit provid array horizontalcut verticalcut sinc answer larg number return modulo 109 7 exampl 1 input h 5 w 4 horizontalcut 124 verticalcut 13 output 4 explan figur repres given rectangular cake red line horizont vertic cut cut cake green piec cake maximum area exampl 2 input h 5 w 4 horizontalcut 31 verticalcut 1 output 6 explan figur repres given rectangular cake red line horizont vertic cut cut cake green yellow piec cake maximum area exampl 3 input h 5 w 4 horizontalcut 3 verticalcut 3 output 9 constraint 2 h w 109 1 horizontalcutslength minh 1 105 1 verticalcutslength minw 1 105 1 horizontalcutsi h 1 verticalcutsi w element horizontalcut distinct element verticalcut distinct maximumareaofapieceofcakeafterhorizontalandverticalcut
given two array integ num index task creat target array follow rule initi target array empti left right read numsi indexi insert index indexi valu numsi target array repeat previou step element read num index return target array guarante insert oper valid exampl 1 input num 01234 index 01221 output 04132 explan num index target 0 0 0 1 1 01 2 2 012 3 2 0132 4 1 04132 exampl 2 input num 12340 index 01230 output 01234 explan num index target 1 0 1 2 1 12 3 2 123 4 3 1234 0 0 01234 exampl 3 input num 1 index 0 output 1 constraint 1 numslength indexlength 100 numslength indexlength 0 numsi 100 0 indexi createtargetarrayinthegivenord
given integ array num number x lone appear adjac number ie x 1 x 1 appear array return lone number num may return answer order exampl 1 input num 10658 output 108 explan 10 lone number sinc appear exactli 9 11 appear num 8 lone number sinc appear exactli 7 9 appear num 5 lone number sinc 6 appear num vice versa henc lone number num 10 8 note 8 10 may also return exampl 2 input num 1353 output 15 explan 1 lone number sinc appear exactli 0 2 appear num 5 lone number sinc appear exactli 4 6 appear num 3 lone number sinc appear twice henc lone number num 1 5 note 5 1 may also return constraint 1 numslength 105 0 numsi 106 findalllonelynumbersinthearray
given x n matrix mat integ threshold return maximum sidelength squar sum less equal threshold return 0 squar exampl 1 input mat 113243211324321132432 threshold 4 output 2 explan maximum side length squar sum less 4 2 shown exampl 2 input mat 2222222222222222222222222 threshold 1 output 0 constraint matlength n matilength 1 n 300 0 matij 104 0 threshold 105 maximumsidelengthofasquarewithsumlessthanorequaltothreshold
string originaltext encod use slant transposit cipher string encodedtext help matrix fix number row row originaltext place first topleft bottomright manner blue cell fill first follow red cell yellow cell reach end originaltext arrow indic order cell fill empti cell fill number column chosen rightmost column empti fill originaltext encodedtext form append charact matrix rowwis fashion charact blue cell append first encodedtext red cell final yellow cell arrow indic order cell access exampl originaltext cipher row 3 encod follow manner blue arrow depict originaltext place matrix red arrow denot order encodedtext form exampl encodedtext ch ie pr given encod string encodedtext number row row return origin string originaltext note originaltext trail space test case gener one possibl originaltext exampl 1 input encodedtext ch ie pr row 3 output cipher explan exampl describ problem descript exampl 2 input encodedtext iveo eed l te olc row 4 output love leetcod explan figur denot matrix use encod originaltext blue arrow show find originaltext encodedtext exampl 3 input encodedtext code row 1 output code explan sinc 1 row originaltext encodedtext constraint 0 encodedtextlength 106 encodedtext consist lowercas english letter encodedtext valid encod originaltext trail space 1 row 1000 testcas gener one possibl originaltext decodetheslantedciphertext
ugli number posit integ divis b c given four integ n b c return nth ugli number exampl 1 input n 3 2 b 3 c 5 output 4 explan ugli number 2 3 4 5 6 8 9 10 3rd 4 exampl 2 input n 4 2 b 3 c 4 output 6 explan ugli number 2 3 4 6 8 9 10 12 4th 6 exampl 3 input n 5 2 b 11 c 13 output 10 explan ugli number 2 4 6 8 10 11 12 13 5th 10 constraint 1 n b c 109 1 b c 1018 guarante result rang 1 2 109 uglynumberiii
given text file filetxt transpos content may assum row number column field separ charact exampl filetxt follow content name age alic 21 ryan 30 output follow name alic ryan age 21 30 transposefil
given array string word repres english dictionari return longest word word built one charact time word word one possibl answer return longest word smallest lexicograph order answer return empti string note word built left right addit charact ad end previou word exampl 1 input word wwoworworlworld output world explan word world built one charact time w wo wor worl exampl 2 input word abananaappapplapapplyappl output appl explan appli appl built word dictionari howev appl lexicograph smaller appli constraint 1 wordslength 1000 1 wordsilength 30 wordsi consist lowercas english letter longestwordindictionari
given posit integ k need find length smallest posit integ n n divis k n contain digit 1 return length n n return 1 note n may fit 64bit sign integ exampl 1 input k 1 output 1 explan smallest answer n 1 length 1 exampl 2 input k 2 output 1 explan posit integ n divis 2 exampl 3 input k 3 output 3 explan smallest answer n 111 length 3 constraint 1 k 105 smallestintegerdivisiblebyk
monotoneincreasingdigit
given network n node label 1 n also given time list travel time direct edg timesi ui vi wi ui sourc node vi target node wi time take signal travel sourc target send signal given node k return minimum time take n node receiv signal imposs n node receiv signal return 1 exampl 1 input time 211231341 n 4 k 2 output 2 exampl 2 input time 121 n 2 k 1 output 1 exampl 3 input time 121 n 2 k 2 output 1 constraint 1 k n 100 1 timeslength 6000 timesilength 3 1 ui vi n ui vi 0 wi 100 pair ui vi uniqu ie multipl edg networkdelaytim
given integ array num valu array defin sum numsi numsi 1 0 numslength 1 allow select subarray given array revers perform oper find maximum possibl valu final array exampl 1 input num 23154 output 10 explan revers subarray 315 array becom 25134 whose valu 10 exampl 2 input num 249242110 output 68 constraint 1 numslength 3 104 105 numsi 105 reversesubarraytomaximizearrayvalu
sql schema tabl employe column name type id int salari int sql id primari key column tabl row tabl contain inform salari employe find nth highest salari employe tabl nth highest salari return null result format follow exampl exampl 1 input employe tabl id salari 1 100 2 200 3 300 n 2 output getnthhighestsalary2 200 exampl 2 input employe tabl id salari 1 100 n 2 output getnthhighestsalary2 null nthhighestsalari
given string repres code snippet implement tag valid pars code return whether valid code snippet valid follow rule hold code must wrap valid close tag otherwis code invalid close tag necessarili valid exactli follow format tagnametagcontenttagnam among tagnam start tag tagnam end tag tagnam start end tag close tag valid tagnam tagcont valid valid tagnam contain uppercas letter length rang 19 otherwis tagnam invalid valid tagcont may contain valid close tag cdata charact see note1 except unmatch unmatch start end tag unmatch close tag invalid tagnam otherwis tagcont invalid start tag unmatch end tag exist tagnam vice versa howev also need consid issu unbalanc tag nest unmatch find subsequ find subsequ charact next pars tagnam necessarili valid cdata follow format cdatacdatacont rang cdatacont defin charact cdata first subsequ cdatacont may contain charact function cdata forbid valid pars cdatacont even charact pars tag matter valid invalid treat regular charact exampl 1 input code divthi first line cdatadivdiv output true explan code wrap close tag div div tagnam valid tagcont consist charact cdata although cdatacont unmatch start tag invalid tagnam consid plain text pars tag tagcont valid code valid thu return true exampl 2 input code div cdata cdatadivdiv output true explan first separ code starttagtagcontentendtag starttag div endtag div tagcont could also separ text1cdatatext2 text1 cdata cdata cdatadiv cdatacont div text2 reason starttag div rule 6 reason cdata cdatadiv rule 7 exampl 3 input code b b output fals explan unbalanc close b must unmatch vice versa constraint 1 codelength 500 code consist english letter digit tagvalid
minimumnumberofmovestomakepalindrom
total numcours cours take label 0 numcours 1 given array prerequisit prerequisitesi ai bi indic must take cours bi first want take cours ai exampl pair 0 1 indic take cours 0 first take cours 1 return order cours take finish cours mani valid answer return imposs finish cours return empti array exampl 1 input numcours 2 prerequisit 10 output 01 explan total 2 cours take take cours 1 finish cours 0 correct cours order 01 exampl 2 input numcours 4 prerequisit 10203132 output 0213 explan total 4 cours take take cours 3 finish cours 1 2 cours 1 2 taken finish cours 0 one correct cours order 0123 anoth correct order 0213 exampl 3 input numcours 1 prerequisit output 0 constraint 1 numcours 2000 0 prerequisiteslength numcours numcours 1 prerequisitesilength 2 0 ai bi numcours ai bi pair ai bi distinct coursescheduleii
8 x 8 chessboard contain n piec rook queen bishop given string array piec length n piecesi describ type rook queen bishop ith piec addit given 2d integ array posit also length n positionsi ri ci indic ith piec current 1base coordin ri ci chessboard make move piec choos destin squar piec travel toward stop rook travel horizont vertic r c direct r1 c r1 c r c1 r c1 queen travel horizont vertic diagon r c direct r1 c r1 c r c1 r c1 r1 c1 r1 c1 r1 c1 r1 c1 bishop travel diagon r c direct r1 c1 r1 c1 r1 c1 r1 c1 must make move everi piec board simultan move combin consist move perform given piec everi second piec instantan travel one squar toward destin alreadi piec start travel 0th second move combin invalid given time two piec occupi squar return number valid move combin note two piec start squar may choos squar piec alreadi destin two piec directli adjac valid move past swap posit one second exampl 1 input piec rook posit 11 output 15 explan imag show possibl squar piec move exampl 2 input piec queen posit 11 output 22 explan imag show possibl squar piec move exampl 3 input piec bishop posit 43 output 12 explan imag show possibl squar piec move constraint n pieceslength n positionslength 1 n 4 piec contain string rook queen bishop one queen chessboard 1 xi yi 8 positionsi distinct numberofvalidmovecombinationsonchessboard
given two string word1 word2 want construct string follow manner choos nonempti subsequ subsequence1 word1 choos nonempti subsequ subsequence2 word2 concaten subsequ subsequence1 subsequence2 make string return length longest palindrom construct describ manner palindrom construct return 0 subsequ string string made delet possibl none charact without chang order remain charact palindrom string read forward well backward exampl 1 input word1 cacb word2 cbba output 5 explan choos ab word1 cba word2 make abcba palindrom exampl 2 input word1 ab word2 ab output 3 explan choos ab word1 word2 make aba palindrom exampl 3 input word1 aa word2 bb output 0 explan construct palindrom describ method return 0 constraint 1 word1length word2length 1000 word1 word2 consist lowercas english letter maximizepalindromelengthfromsubsequ
given 0index x n integ matrix grid consist distinct integ 0 n 1 move matrix cell cell next row cell x x 1 move cell x 1 0 x 1 1 x 1 n 1 note possibl move cell last row possibl move cost given 0index 2d array movecost size n x n movecostij cost move cell valu cell column j next row cost move cell last row grid ignor cost path grid sum valu cell visit plu sum cost move made return minimum cost path start cell first row end cell last row exampl 1 input grid 534021 movecost 9815101218624143 output 17 explan path minimum possibl cost path 5 0 1 sum valu cell visit 5 0 1 6 cost move 5 0 3 cost move 0 1 8 total cost path 6 3 8 17 exampl 2 input grid 512403 movecost 121015202382171811391025532 output 6 explan path minimum possibl cost path 2 3 sum valu cell visit 2 3 5 cost move 2 3 1 total cost path 5 1 6 constraint gridlength n gridilength 2 n 50 grid consist distinct integ 0 n 1 movecostlength n movecostilength n 1 movecostij 100 minimumpathcostinagrid
gener microwav support cook time least 1 second 99 minut 99 second set cook time push four digit microwav normal push four digit prepend zero interpret first two digit minut last two digit second add cook time exampl push 9 5 4 three digit normal 0954 interpret 9 minut 54 second push 0 0 0 8 four digit interpret 0 minut 8 second push 8 0 9 0 interpret 80 minut 90 second push 8 1 3 0 interpret 81 minut 30 second given integ startat movecost pushcost targetsecond initi finger digit startat move finger specif digit cost movecost unit fatigu push digit finger cost pushcost unit fatigu multipl way set microwav cook targetsecond second interest way minimum cost return minimum cost set targetsecond second cook time rememb one minut consist 60 second exampl 1 input startat 1 movecost 2 pushcost 1 targetsecond 600 output 6 explan follow possibl way set cook time 1 0 0 0 interpret 10 minut 0 second finger alreadi digit 1 push 1 cost 1 move 0 cost 2 push 0 cost 1 push 0 cost 1 push 0 cost 1 cost 1 2 1 1 1 6 minimum cost 0 9 6 0 interpret 9 minut 60 second also 600 second finger move 0 cost 2 push 0 cost 1 move 9 cost 2 push 9 cost 1 move 6 cost 2 push 6 cost 1 move 0 cost 2 push 0 cost 1 cost 2 1 2 1 2 1 2 1 12 9 6 0 normal 0960 interpret 9 minut 60 second finger move 9 cost 2 push 9 cost 1 move 6 cost 2 push 6 cost 1 move 0 cost 2 push 0 cost 1 cost 2 1 2 1 2 1 9 exampl 2 input startat 0 movecost 1 pushcost 2 targetsecond 76 output 6 explan optim way push two digit 7 6 interpret 76 second finger move 7 cost 1 push 7 cost 2 move 6 cost 1 push 6 cost 2 total cost 1 2 1 2 6 note possibl way 0076 076 0116 116 none produc minimum cost constraint 0 startat 9 1 movecost pushcost 105 1 targetsecond 6039 minimumcosttosetcookingtim
given x n grid cell grid repres street street gridij 1 mean street connect left cell right cell 2 mean street connect upper cell lower cell 3 mean street connect left cell lower cell 4 mean street connect right cell lower cell 5 mean street connect left cell upper cell 6 mean street connect right cell upper cell initi start street upperleft cell 0 0 valid path grid path start upper left cell 0 0 end bottomright cell 1 n 1 path follow street notic allow chang street return true valid path grid fals otherwis exampl 1 input grid 243652 output true explan shown start cell 0 0 visit cell grid reach 1 n 1 exampl 2 input grid 121121 output fals explan shown street cell 0 0 connect street cell get stuck cell 0 0 exampl 3 input grid 112 output fals explan get stuck cell 0 1 reach cell 0 2 constraint gridlength n gridilength 1 n 300 1 gridij 6 checkifthereisavalidpathinagrid
bob stand cell 0 0 want reach destin row column travel right go help bob provid instruct reach destin instruct repres string charact either h mean move horizont go right v mean move vertic go multipl instruct lead bob destin exampl destin 2 3 hhhvv hvhvh valid instruct howev bob picki bob lucki number k want kth lexicograph smallest instruct lead destin k 1index given integ array destin integ k return kth lexicograph smallest instruct take bob destin exampl 1 input destin 23 k 1 output hhhvv explan instruct reach 2 3 lexicograph order follow hhhvv hhvhv hhvvh hvhhv hvhvh hvvhh vhhhv vhhvh vhvhh vvhhh exampl 2 input destin 23 k 2 output hhvhv exampl 3 input destin 23 k 3 output hhvvh constraint destinationlength 2 1 row column 15 1 k ncrrow column row ncra b denot choos b kthsmallestinstruct
sentenc list word separ singl space lead trail space word consist uppercas lowercas english letter punctuat exampl hello world hello hello world hello world sentenc given sentenc integ k want truncat contain first k word return truncat exampl 1 input hello contest k 4 output hello explan word hello contest first 4 word hello henc return hello exampl 2 input solut problem k 4 output solut explan word solut problem first 4 word solut henc return solut exampl 3 input chopper tanuki k 5 output chopper tanuki constraint 1 slength 500 k rang 1 number word consist lowercas uppercas english letter space word separ singl space lead trail space truncatesent
design stack support push pop top retriev minimum element constant time implement minstack class minstack initi stack object void pushint val push element val onto stack void pop remov element top stack int top get top element stack int getmin retriev minimum element stack must implement solut o1 time complex function exampl 1 input minstackpushpushpushgetminpoptopgetmin 203 output nullnullnullnull3null02 explan minstack minstack new minstack minstackpush2 minstackpush0 minstackpush3 minstackgetmin return 3 minstackpop minstacktop return 0 minstackgetmin return 2 constraint 231 val 231 1 method pop top getmin oper alway call nonempti stack 3 104 call made push pop top getmin minstack
given string contain charact return length longest valid wellform parenthes substr exampl 1 input output 2 explan longest valid parenthes substr exampl 2 input output 4 explan longest valid parenthes substr exampl 3 input output 0 constraint 0 slength 3 104 si longestvalidparenthes
design system manag reserv state n seat number 1 n implement seatmanag class seatmanagerint n initi seatmanag object manag n seat number 1 n seat initi avail int reserv fetch smallestnumb unreserv seat reserv return number void unreserveint seatnumb unreserv seat given seatnumb exampl 1 input seatmanag reserv reserv unreserv reserv reserv reserv reserv unreserv 5 2 5 output null 1 2 null 2 3 4 5 null explan seatmanag seatmanag new seatmanager5 initi seatmanag 5 seat seatmanagerreserv seat avail return lowest number seat 1 seatmanagerreserv avail seat 2345 return lowest 2 seatmanagerunreserve2 unreserv seat 2 avail seat 2345 seatmanagerreserv avail seat 2345 return lowest 2 seatmanagerreserv avail seat 345 return lowest 3 seatmanagerreserv avail seat 45 return lowest 4 seatmanagerreserv avail seat seat 5 return 5 seatmanagerunreserve5 unreserv seat 5 avail seat 5 constraint 1 n 105 1 seatnumb n call reserv guarante least one unreserv seat call unreserv guarante seatnumb reserv 105 call total made reserv unreserv seatreservationmanag
given posit integ n let even denot number even indic binari represent n 0index valu 1 let odd denot number odd indic binari represent n 0index valu 1 return integ array answer answer even odd exampl 1 input n 17 output 20 explan binari represent 17 10001 contain 1 0th 4th indic 2 even 0 odd indic exampl 2 input n 2 output 01 explan binari represent 2 10 contain 1 1st index 0 even 1 odd indic constraint 1 n 1000 numberofevenandoddbit
given 0index array n integ differ describ differ pair consecut integ hidden sequenc length n 1 formal call hidden sequenc hidden differencesi hiddeni 1 hiddeni given two integ lower upper describ inclus rang valu lower upper hidden sequenc contain exampl given differ 1 3 4 lower 1 upper 6 hidden sequenc sequenc length 4 whose element 1 6 inclus 3 4 1 5 4 5 2 6 possibl hidden sequenc 5 6 3 7 possibl sinc contain element greater 6 1 2 3 4 possibl sinc differ correct return number possibl hidden sequenc possibl sequenc return 0 exampl 1 input differ 134 lower 1 upper 6 output 2 explan possibl hidden sequenc 3 4 1 5 4 5 2 6 thu return 2 exampl 2 input differ 34512 lower 4 upper 5 output 4 explan possibl hidden sequenc 3 0 4 1 2 0 2 1 3 2 3 1 1 2 2 3 4 2 0 3 1 4 5 3 thu return 4 exampl 3 input differ 472 lower 3 upper 6 output 0 explan possibl hidden sequenc thu return 0 constraint n differenceslength 1 n 105 105 differencesi 105 105 lower upper 105 countthehiddensequ
pizza 3n slice vari size friend take slice pizza follow pick pizza slice friend alic pick next slice anticlockwis direct pick friend bob pick next slice clockwis direct pick repeat slice pizza given integ array slice repres size pizza slice clockwis direct return maximum possibl sum slice size pick exampl 1 input slice 123456 output 10 explan pick pizza slice size 4 alic bob pick slice size 3 5 respect pick slice size 6 final alic bob pick slice size 2 1 respect total 4 6 exampl 2 input slice 898611 output 16 explan pick pizza slice size 8 turn pick slice size 9 partner pick slice size 8 constraint 3 n sliceslength 1 sliceslength 500 1 slicesi 1000 pizzawith3nslic
stampingthesequ
two kind thread oxygen hydrogen goal group thread form water molecul barrier thread wait complet molecul form hydrogen oxygen thread given releasehydrogen releaseoxygen method respect allow pass barrier thread pass barrier group three must immedi bond form water molecul must guarante thread one molecul bond thread next molecul word oxygen thread arriv barrier hydrogen thread present must wait two hydrogen thread hydrogen thread arriv barrier thread present must wait oxygen thread anoth hydrogen thread worri match thread explicitli thread necessarili know thread pair key thread pass barrier complet set thu examin sequenc thread bind divid group three group contain one oxygen two hydrogen thread write synchron code oxygen hydrogen molecul enforc constraint exampl 1 input water hoh output hho explan hoh ohh also valid answer exampl 2 input water oohhhh output hhohho explan hohhho ohhhho hhohoh hohhoh ohhhoh hhoohh hohohh ohhohh also valid answer constraint 3 n waterlength 1 n 20 wateri either h exactli 2 n h water exactli n water buildingh2o
x n rectangular island border pacif ocean atlant ocean pacif ocean touch island left top edg atlant ocean touch island right bottom edg island partit grid squar cell given x n integ matrix height heightsrc repres height sea level cell coordin r c island receiv lot rain rain water flow neighbor cell directli north south east west neighbor cell height less equal current cell height water flow cell adjac ocean ocean return 2d list grid coordin result resulti ri ci denot rain water flow cell ri ci pacif atlant ocean exampl 1 input height 1223532344245316714551124 output 04131422303140 explan follow cell flow pacif atlant ocean shown 04 04 pacif ocean 04 atlant ocean 13 13 03 pacif ocean 13 14 atlant ocean 14 14 13 03 pacif ocean 14 atlant ocean 22 22 12 02 pacif ocean 22 23 24 atlant ocean 30 30 pacif ocean 30 40 atlant ocean 31 31 30 pacif ocean 31 41 atlant ocean 40 40 pacif ocean 40 atlant ocean note possibl path cell flow pacif atlant ocean exampl 2 input height 1 output 00 explan water flow cell pacif atlant ocean constraint heightslength n heightsrlength 1 n 200 0 heightsrc 105 pacificatlanticwaterflow
climb staircas take n step reach top time either climb 1 2 step mani distinct way climb top exampl 1 input n 2 output 2 explan two way climb top 1 1 step 1 step 2 2 step exampl 2 input n 3 output 3 explan three way climb top 1 1 step 1 step 1 step 2 1 step 2 step 3 2 step 1 step constraint 1 n 45 climbingstair
given integ array num integ val remov occurr val num inplac order element may chang return number element num equal val consid number element num equal val k get accept need follow thing chang array num first k element num contain element equal val remain element num import well size num return k custom judg judg test solut follow code int num input array int val valu remov int expectednum expect answer correct length sort valu equal val int k removeelementnum val call implement assert k expectednumslength sortnum 0 k sort first k element num int 0 actuallength assert numsi expectednumsi assert pass solut accept exampl 1 input num 3223 val 3 output 2 num 22 explan function return k 2 first two element num 2 matter leav beyond return k henc underscor exampl 2 input num 01223042 val 2 output 5 num 01403 explan function return k 5 first five element num contain 0 0 1 3 4 note five element return order matter leav beyond return k henc underscor constraint 0 numslength 100 0 numsi 50 0 val 100 removeel
hidden integ array arr consist n nonneg integ encod anoth integ array encod length n 1 encodedi arri xor arri 1 exampl arr 1021 encod 123 given encod array also given integ first first element arr ie arr0 return origin array arr prove answer exist uniqu exampl 1 input encod 123 first 1 output 1021 explan arr 1021 first 1 encod 1 xor 0 0 xor 2 2 xor 1 123 exampl 2 input encod 6273 first 4 output 42074 constraint 2 n 104 encodedlength n 1 0 encodedi 105 0 first 105 decodexoredarray
design algorithm collect daili price quot stock return span stock price current day span stock price one day maximum number consecut day start day go backward stock price less equal price day exampl price stock last four day 7212 price stock today 2 span today 4 start today price stock less equal 2 4 consecut day also price stock last four day 73412 price stock today 8 span today 3 start today price stock less equal 8 3 consecut day implement stockspann class stockspann initi object class int nextint price return span stock price given today price price exampl 1 input stockspann next next next next next next next 100 80 60 70 60 75 85 output null 1 1 1 2 1 4 6 explan stockspann stockspann new stockspann stockspannernext100 return 1 stockspannernext80 return 1 stockspannernext60 return 1 stockspannernext70 return 2 stockspannernext60 return 1 stockspannernext75 return 4 last 4 price includ today price 75 less equal today price stockspannernext85 return 6 constraint 1 price 105 104 call made next onlinestockspan
given two posit integ array nums1 nums2 length n absolut sum differ array nums1 nums2 defin sum nums1i nums2i 0 n 0index replac one element nums1 element nums1 minim absolut sum differ return minimum absolut sum differ replac one element array nums1 sinc answer may larg return modulo 109 7 x defin x x 0 x x 0 exampl 1 input nums1 175 nums2 235 output 3 explan two possibl optim solut replac second element first 175 115 replac second element third 175 155 yield absolut sum differ 12 13 53 55 3 exampl 2 input nums1 246810 nums2 246810 output 0 explan nums1 equal nums2 replac need result absolut sum differ 0 exampl 3 input nums1 1104427 nums2 935174 output 20 explan replac first element second 1104427 10104427 yield absolut sum differ 109 103 45 41 27 74 20 constraint n nums1length n nums2length 1 n 105 1 nums1i nums2i 105 minimumabsolutesumdiffer
given array string token repres arithmet express revers polish notat evalu express return integ repres valu express note valid oper operand may integ anoth express divis two integ alway truncat toward zero divis zero input repres valid arithmet express revers polish notat answer intermedi calcul repres 32bit integ exampl 1 input token 213 output 9 explan 2 1 3 9 exampl 2 input token 4135 output 6 explan 4 13 5 6 exampl 3 input token 1069311175 output 22 explan 10 6 9 3 11 17 5 10 6 12 11 17 5 10 6 132 17 5 10 0 17 5 0 17 5 17 5 22 constraint 1 tokenslength 104 tokensi either oper integ rang 200 200 evaluatereversepolishnot
given two array string list1 list2 find common string least index sum common string string appear list1 list2 common string least index sum common string appear list1i list2j j minimum valu among common string return common string least index sum return answer order exampl 1 input list1 shoguntapioca expressburg kingkfc list2 piattith grill torrey pineshungri hunter steakhouseshogun output shogun explan common string shogun exampl 2 input list1 shoguntapioca expressburg kingkfc list2 kfcshogunburg king output shogun explan common string least index sum shogun index sum 0 1 1 exampl 3 input list1 happysadgood list2 sadhappygood output sadhappi explan three common string happi index sum 0 1 1 sad index sum 1 0 1 good index sum 2 2 4 string least index sum sad happi constraint 1 list1length list2length 1000 1 list1ilength list2ilength 30 list1i list2i consist space english letter string list1 uniqu string list2 uniqu least common string list1 list2 minimumindexsumoftwolist
given string integ k choos charact string chang uppercas english charact perform oper k time return length longest substr contain letter get perform oper exampl 1 input abab k 2 output 4 explan replac two two bs vice versa exampl 2 input aababba k 1 output 4 explan replac one middl b form aabbbba substr bbbb longest repeat letter 4 may exist way achiv answer constraint 1 slength 105 consist uppercas english letter 0 k slength longestrepeatingcharacterreplac
given root binari tree return maximum width given tree maximum width tree maximum width among level width one level defin length endnod leftmost rightmost nonnul node null node endnod would present complet binari tree extend level also count length calcul guarante answer rang 32bit sign integ exampl 1 input root 13253null9 output 4 explan maximum width exist third level length 4 53null9 exampl 2 input root 1325nullnull96null7 output 7 explan maximum width exist fourth level length 7 6nullnullnullnullnull7 exampl 3 input root 1325 output 2 explan maximum width exist second level length 2 32 constraint number node tree rang 1 3000 100 nodev 100 maximumwidthofbinarytre
given array string idea repres list name use process name compani process name compani follow choos 2 distinct name idea call ideaa ideab swap first letter ideaa ideab new name found origin idea name ideaa ideab concaten ideaa ideab separ space valid compani name otherwis valid name return number distinct valid name compani exampl 1 input idea coffeedonutstimetoffe output 6 explan follow select valid coffe donut compani name creat doffe conut donut coffe compani name creat conut doffe donut time compani name creat tonut dime donut toffe compani name creat tonut doffe time donut compani name creat dime tonut toffe donut compani name creat doffe tonut therefor total 6 distinct compani name follow exampl invalid select coffe time name toffe form swap alreadi exist origin array time toffe name still swap exist origin array coffe toffe name form swap alreadi exist origin array exampl 2 input idea lackback output 0 explan valid select therefor 0 return constraint 2 ideaslength 5 104 1 ideasilength 10 ideasi consist lowercas english letter string idea uniqu namingacompani
given integ n reorder digit order includ origin order lead digit zero return true result number power two exampl 1 input n 1 output true exampl 2 input n 10 output fals constraint 1 n 109 reorderedpowerof2
sql schema pandan schema tabl patient column name type patientid int patientnam varchar condit varchar sql patientid primari key tabl condit contain 0 code separ space tabl contain inform patient hospit find patientid patientnam condit patient type diabet type diabet alway start diab1 prefix return result tabl order result format follow exampl exampl 1 input patient tabl patientid patientnam condit 1 daniel yfev cough 2 alic 3 bob diab100 myop 4 georg acn diab100 5 alain diab201 output patientid patientnam condit 3 bob diab100 myop 4 georg acn diab100 explan bob georg condit start diab1 patientswithacondit
given 0index string num length n consist digit return true everi index rang 0 n digit occur numi time num otherwis return fals exampl 1 input num 1210 output true explan num0 1 digit 0 occur num num1 2 digit 1 occur twice num num2 1 digit 2 occur num num3 0 digit 3 occur zero time num condit hold true everi index 1210 return true exampl 2 input num 030 output fals explan num0 0 digit 0 occur zero time actual occur twice num num1 3 digit 1 occur three time actual occur zero time num num2 0 digit 2 occur zero time num indic 0 1 violat condit return fals constraint n numlength 1 n 10 num consist digit checkifnumberhasequaldigitcountanddigitvalu
imag smoother filter size 3 x 3 appli cell imag round averag cell eight surround cell ie averag nine cell blue smoother one surround cell cell present consid averag ie averag four cell red smoother given x n integ matrix img repres grayscal imag return imag appli smoother cell exampl 1 input img 111101111 output 000000000 explan point 00 02 20 22 floor34 floor075 0 point 01 10 12 21 floor56 floor083333333 0 point 11 floor89 floor088888889 0 exampl 2 input img 10020010020050200100200100 output 137141137141138141137141137 explan point 00 02 20 22 floor100200200504 floor1375 137 point 01 10 12 21 floor200200502001001006 floor141666667 141 point 11 floor502002002002001001001001009 floor138888889 138 constraint imglength n imgilength 1 n 200 0 imgij 255 imagesmooth
given 0index array nonneg integ num integ num must find respect second greater integ second greater integ numsi numsj j numsj numsi exist exactli one index k numsk numsi k j numsj second greater integ consid 1 exampl array 1 2 4 3 second greater integ 1 4 2 3 3 4 1 return integ array answer answeri second greater integ numsi exampl 1 input num 24096 output 96611 explan 0th index 4 first integ greater 2 9 second integ greater 2 right 2 1st index 9 first 6 second integ greater 4 right 4 2nd index 9 first 6 second integ greater 0 right 0 3rd index integ greater 9 right second greater integ consid 1 4th index integ greater 6 right second greater integ consid 1 thu return 96611 exampl 2 input num 33 output 11 explan return 11 sinc neither integ integ greater constraint 1 numslength 105 0 numsi 109 nextgreaterelementiv
sql schema findmediangivenfrequencyofnumb
xor total array defin bitwis xor element 0 array empti exampl xor total array 256 2 xor 5 xor 6 1 given array num return sum xor total everi subset num note subset element count multipl time array subset array b obtain b delet possibl zero element b exampl 1 input num 13 output 6 explan 4 subset 13 empti subset xor total 0 1 xor total 1 3 xor total 3 13 xor total 1 xor 3 2 0 1 3 2 6 exampl 2 input num 516 output 28 explan 8 subset 516 empti subset xor total 0 5 xor total 5 1 xor total 1 6 xor total 6 51 xor total 5 xor 1 4 56 xor total 5 xor 6 3 16 xor total 1 xor 6 7 516 xor total 5 xor 1 xor 6 2 0 5 1 6 4 3 7 2 28 exampl 3 input num 345678 output 480 explan sum xor total everi subset 480 constraint 1 numslength 12 1 numsi 20 sumofallsubsetxortot
maximumstudentstakingexam
grid size n x 3 want paint cell grid exactli one three color red yellow green make sure two adjac cell color ie two cell share vertic horizont side color given n number row grid return number way paint grid answer may grow larg answer must comput modulo 109 7 exampl 1 input n 1 output 12 explan 12 possibl way paint grid shown exampl 2 input n 5000 output 30228214 constraint n gridlength 1 n 5000 numberofwaystopaintn3grid
given two posit integ n target integ consid beauti sum digit less equal target return minimum nonneg integ x n x beauti input gener alway possibl make n beauti exampl 1 input n 16 target 6 output 4 explan initi n 16 digit sum 1 6 7 ad 4 n becom 20 digit sum becom 2 0 2 shown make n beauti ad nonneg integ less 4 exampl 2 input n 467 target 6 output 33 explan initi n 467 digit sum 4 6 7 17 ad 33 n becom 500 digit sum becom 5 0 0 5 shown make n beauti ad nonneg integ less 33 exampl 3 input n 1 target 1 output 0 explan initi n 1 digit sum 1 alreadi smaller equal target constraint 1 n 1012 1 target 150 input gener alway possibl make n beauti minimumadditiontomakeintegerbeauti
letter valu letter posit alphabet start 0 ie 0 b 1 c 2 etc numer valu string lowercas english letter concaten letter valu letter convert integ exampl acb concaten letter letter valu result 021 convert get 21 given three string firstword secondword targetword consist lowercas english letter j inclus return true summat numer valu firstword secondword equal numer valu targetword fals otherwis exampl 1 input firstword acb secondword cba targetword cdb output true explan numer valu firstword acb 021 21 numer valu secondword cba 210 210 numer valu targetword cdb 231 231 return true 21 210 231 exampl 2 input firstword aaa secondword targetword aab output fals explan numer valu firstword aaa 000 0 numer valu secondword 0 0 numer valu targetword aab 001 1 return fals 0 0 1 exampl 3 input firstword aaa secondword targetword aaaa output true explan numer valu firstword aaa 000 0 numer valu secondword 0 0 numer valu targetword aaaa 0000 0 return true 0 0 0 constraint 1 firstwordlength secondwordlength targetwordlength 8 firstword secondword targetword consist lowercas english letter j inclus checkifwordequalssummationoftwoword
given 0index binari string floor repres color tile floor floori 0 denot ith tile floor color black hand floori 1 denot ith tile floor color white also given numcarpet carpetlen numcarpet black carpet length carpetlen tile cover tile given carpet number white tile still visibl minimum carpet may overlap one anoth return minimum number white tile still visibl exampl 1 input floor 10110101 numcarpet 2 carpetlen 2 output 2 explan figur show one way cover tile carpet 2 white tile visibl way cover tile carpet leav less 2 white tile visibl exampl 2 input floor 11111 numcarpet 2 carpetlen 3 output 0 explan figur show one way cover tile carpet white tile visibl note carpet abl overlap one anoth constraint 1 carpetlen floorlength 1000 floori either 0 1 1 numcarpet 1000 minimumwhitetilesaftercoveringwithcarpet
given root binari tree check whether mirror ie symmetr around center exampl 1 input root 1223443 output true exampl 2 input root 122null3null3 output fals constraint number node tree rang 1 1000 100 nodev 100 follow could solv recurs iter symmetrictre
reorganizestr
given num array posit integ size 2 n must perform n oper array ith oper 1index choos two element x receiv score gcdx remov x num return maximum score receiv perform n oper function gcdx greatest common divisor x exampl 1 input num 12 output 1 explan optim choic oper 1 gcd1 2 1 exampl 2 input num 3468 output 11 explan optim choic oper 1 gcd3 6 2 gcd4 8 3 8 11 exampl 3 input num 123456 output 14 explan optim choic oper 1 gcd1 5 2 gcd2 4 3 gcd3 6 1 4 9 14 constraint 1 n 7 numslength 2 n 1 numsi 106 maximizescoreafternoper
given tree n node number 0 n 1 form parent array parent parenti parent ith node root tree node 0 parent0 1 sinc parent want design data structur allow user lock unlock upgrad node tree data structur support follow function lock lock given node given user prevent user lock node may lock node use function node unlock unlock unlock given node given user may unlock node use function current lock user upgrad lock given node given user unlock descend regardless lock may upgrad node 3 condit true node unlock least one lock descend user lock ancestor implement lockingtre class lockingtreeint parent initi data structur parent array lockint num int user return true possibl user id user lock node num fals otherwis possibl node num becom lock user id user unlockint num int user return true possibl user id user unlock node num fals otherwis possibl node num becom unlock upgradeint num int user return true possibl user id user upgrad node num fals otherwis possibl node num upgrad exampl 1 input lockingtre lock unlock unlock lock upgrad lock 1 0 0 1 1 2 2 2 2 2 3 2 2 4 5 0 1 0 1 output null true fals true true true fals explan lockingtre lockingtre new lockingtree1 0 0 1 1 2 2 lockingtreelock2 2 return true node 2 unlock node 2 lock user 2 lockingtreeunlock2 3 return fals user 3 unlock node lock user 2 lockingtreeunlock2 2 return true node 2 previous lock user 2 node 2 unlock lockingtreelock4 5 return true node 4 unlock node 4 lock user 5 lockingtreeupgrade0 1 return true node 0 unlock least one lock descend node 4 node 0 lock user 1 node 4 unlock lockingtreelock0 1 return fals node 0 alreadi lock constraint n parentlength 2 n 2000 0 parenti n 1 0 parent0 1 0 num n 1 1 user 104 parent repres valid tree 2000 call total made lock unlock upgrad operationsontre
given 0index array string word two integ left right string call vowel string start vowel charact end vowel charact vowel charact e u return number vowel string wordsi belong inclus rang left right exampl 1 input word areamyu left 0 right 2 output 2 explan vowel string start end e ami vowel string end vowel u vowel string start u end u number vowel string mention rang 2 exampl 2 input word heyaeomuoooartro left 1 right 4 output 3 explan aeo vowel string start end mu vowel string start vowel ooo vowel string start end artro vowel string start end number vowel string mention rang 3 constraint 1 wordslength 1000 1 wordsilength 10 wordsi consist lowercas english letter 0 left right wordslength countthenumberofvowelstringsinrang
n peopl stand line label 1 n first person line hold pillow initi everi second person hold pillow pass next person stand line pillow reach end line direct chang peopl continu pass pillow opposit direct exampl pillow reach nth person pass n 1th person n 2th person given two posit integ n time return index person hold pillow time second exampl 1 input n 4 time 5 output 2 explan peopl pass pillow follow way 1 2 3 4 3 2 afer five second pillow given 2nd person exampl 2 input n 3 time 2 output 3 explan peopl pass pillow follow way 1 2 3 afer two second pillow given 3rd person constraint 2 n 1000 1 time 1000 passthepillow
flattenbinarytreetolinkedlist
given root nari tree return postord travers node valu narytre input serial repres level order travers group children separ null valu see exampl exampl 1 input root 1null324null56 output 563241 exampl 2 input root 1null2345nullnull67null8null910nullnull11null12null13nullnull14 output 2614117312841391051 constraint number node tree rang 0 104 0 nodev 104 height nari tree less equal 1000 follow recurs solut trivial could iter narytreepostordertravers
given root binari tree integ targetsum return true tree roottoleaf path ad valu along path equal targetsum leaf node children exampl 1 input root 54811null13472nullnullnull1 targetsum 22 output true explan roottoleaf path target sum shown exampl 2 input root 123 targetsum 5 output fals explan two roottoleaf path tree 1 2 sum 3 1 3 sum 4 roottoleaf path sum 5 exampl 3 input root targetsum 0 output fals explan sinc tree empti roottoleaf path constraint number node tree rang 0 5000 1000 nodev 1000 1000 targetsum 1000 pathsum
given 0index array num length n consist nonneg integ index 0 n 1 must determin size minimum size nonempti subarray num start inclus maximum possibl bitwis word let bij bitwis subarray numsij need find smallest subarray start bitwis subarray equal maxbik k n 1 bitwis array bitwis number return integ array answer size n answeri length minimum size subarray start maximum bitwis subarray contigu nonempti sequenc element within array exampl 1 input num 10213 output 33221 explan maximum possibl bitwis start index 3 start index 0 shortest subarray yield 102 start index 1 shortest subarray yield maximum bitwis 021 start index 2 shortest subarray yield maximum bitwis 21 start index 3 shortest subarray yield maximum bitwis 13 start index 4 shortest subarray yield maximum bitwis 3 therefor return 33221 exampl 2 input num 12 output 21 explan start index 0 shortest subarray yield maximum bitwis length 2 start index 1 shortest subarray yield maximum bitwis length 1 therefor return 21 constraint n numslength 1 n 105 0 numsi 109 smallestsubarrayswithmaximumbitwiseor
n bag number 0 n 1 given two 0index integ array capac rock ith bag hold maximum capacityi rock current contain rocksi rock also given integ additionalrock number addit rock place bag return maximum number bag could full capac place addit rock bag exampl 1 input capac 2345 rock 1244 additionalrock 2 output 3 explan place 1 rock bag 0 1 rock bag 1 number rock bag 2344 bag 0 1 2 full capac 3 bag full capac return 3 shown possibl 3 bag full capac note may way place rock result answer 3 exampl 2 input capac 1022 rock 220 additionalrock 100 output 3 explan place 8 rock bag 0 2 rock bag 2 number rock bag 1022 bag 0 1 2 full capac 3 bag full capac return 3 shown possibl 3 bag full capac note use addit rock constraint n capacitylength rockslength 1 n 5 104 1 capacityi 109 0 rocksi capacityi 1 additionalrock 109 maximumbagswithfullcapacityofrock
given 2d integ array num numsi nonempti array distinct posit integ return list integ present array num sort ascend order exampl 1 input num 3124512343456 output 34 explan integ present nums0 31245 nums1 1234 nums2 3456 3 4 return 34 exampl 2 input num 123456 output explan exist integ present nums0 nums1 return empti list constraint 1 numslength 1000 1 sumnumsilength 1000 1 numsij 1000 valu numsi uniqu intersectionofmultiplearray
scramblestr
given root binari tree return postord travers node valu exampl 1 input root 1null23 output 321 exampl 2 input root output exampl 3 input root 1 output 1 constraint number node tree rang 0 100 100 nodev 100 follow recurs solut trivial could iter binarytreepostordertravers
given integ num return three consecut integ sort array sum num num express sum three consecut integ return empti array exampl 1 input num 33 output 101112 explan 33 express 10 11 12 33 10 11 12 3 consecut integ return 10 11 12 exampl 2 input num 4 output explan way express 4 sum 3 consecut integ constraint 0 num 1015 findthreeconsecutiveintegersthatsumtoagivennumb
undirect graph consist n node number 0 n 1 given 0index integ array val length n valsi denot valu ith node also given 2d integ array edg edgesi ai bi denot exist undirect edg connect node ai bi star graph subgraph given graph center node contain 0 neighbor word subset edg given graph exist common node edg imag show star graph 3 4 neighbor respect center blue node star sum sum valu node present star graph given integ k return maximum star sum star graph contain k edg exampl 1 input val 1234101020 edg 011213343536 k 2 output 16 explan diagram repres input graph star graph maximum star sum denot blue center 3 includ neighbor 1 4 shown possibl get star graph sum greater 16 exampl 2 input val 5 edg k 0 output 5 explan one possibl star graph node 0 henc return 5 constraint n valslength 1 n 105 104 valsi 104 0 edgeslength minn n 1 2 105 edgesilength 2 0 ai bi n 1 ai bi 0 k n 1 maximumstarsumofagraph
given binari array num 0index defin xi number whose binari represent subarray nums0i mostsignificantbit leastsignificantbit exampl num 101 x0 1 x1 2 x2 5 return array boolean answer answeri true xi divis 5 exampl 1 input num 011 output truefalsefals explan input number binari 0 01 011 0 1 3 base10 first number divis 5 answer0 true exampl 2 input num 111 output falsefalsefals constraint 1 numslength 105 numsi either 0 1 binaryprefixdivisibleby5
sentencesimilarityii
given array num consist 2n element form x1x2xny1y2yn return array form x1y1x2y2xnyn exampl 1 input num 251347 n 3 output 235417 explan sinc x12 x25 x31 y13 y24 y37 answer 235417 exampl 2 input num 12344321 n 4 output 14233241 exampl 3 input num 1122 n 2 output 1212 constraint 1 n 500 numslength 2n 1 numsi 103 shufflethearray
given array string pattern string word return number string pattern exist substr word substr contigu sequenc charact within string exampl 1 input pattern aabcbcd word abc output 3 explan appear substr abc abc appear substr abc bc appear substr abc appear substr abc 3 string pattern appear substr word exampl 2 input pattern abc word aaaaabbbbb output 2 explan appear substr aaaaabbbbb b appear substr aaaaabbbbb c appear substr aaaaabbbbb 2 string pattern appear substr word exampl 3 input pattern aaa word ab output 3 explan pattern appear substr word ab constraint 1 patternslength 100 1 patternsilength 100 1 wordlength 100 patternsi word consist lowercas english letter numberofstringsthatappearassubstringsinword
tree ie connect undirect graph cycl consist n node number 0 n 1 exactli n 1 edg node valu associ root tree node 0 repres tree given integ array num 2d array edg numsi repres ith node valu edgesj uj vj repres edg node uj vj tree two valu x coprim gcdx 1 gcdx greatest common divisor x ancestor node node shortest path node root node consid ancestor return array an size n ansi closest ancestor node numsi numsansi coprim 1 ancestor exampl 1 input num 2332 edg 011213 output 1001 explan figur node valu parenthes node 0 coprim ancestor node 1 one ancestor node 0 valu coprim gcd23 1 node 2 two ancestor node 1 0 node 1s valu coprim gcd33 3 node 0s valu gcd23 1 node 0 closest valid ancestor node 3 two ancestor node 1 0 coprim node 1 gcd32 1 node 1 closest valid ancestor exampl 2 input num 561023615 edg 010213142526 output 1010001 constraint numslength n 1 numsi 50 1 n 105 edgeslength n 1 edgesjlength 2 0 uj vj n uj vj treeofcoprim
given integ array arr start index make seri jump 1st 3rd 5th jump seri call oddnumb jump 2nd 4th 6th jump seri call evennumb jump note jump number indic may jump forward index index j j follow way oddnumb jump ie jump 1 3 5 jump index j arri arrj arrj smallest possibl valu multipl indic j jump smallest index j evennumb jump ie jump 2 4 6 jump index j arri arrj arrj largest possibl valu multipl indic j jump smallest index j may case index legal jump start index good start index reach end array index arrlength 1 jump number time possibl 0 return number good start indic exampl 1 input arr 1013121415 output 2 explan start index 0 make 1st jump 2 sinc arr2 smallest among arr1 arr2 arr3 arr4 greater equal arr0 jump start index 1 2 make 1st jump 3 jump start index 3 make 1st jump 4 reach end start index 4 reach end alreadi total 2 differ start indic 3 4 reach end number jump exampl 2 input arr 23114 output 3 explan start index 0 make jump 1 2 3 1st jump oddnumb first jump 1 arr1 smallest valu arr1 arr2 arr3 arr4 greater equal arr0 2nd jump evennumb jump 1 2 arr2 largest valu arr2 arr3 arr4 less equal arr1 arr3 also largest valu 2 smaller index jump 2 3 3rd jump oddnumb jump 2 3 arr3 smallest valu arr3 arr4 greater equal arr2 cant jump 3 4 start index 0 good similar manner deduc start index 1 jump 4 reach end start index 2 jump 3 cant jump anymor start index 3 jump 4 reach end start index 4 alreadi end total 3 differ start indic 1 3 4 reach end number jump exampl 3 input arr 51342 output 3 explan reach end start indic 1 2 4 constraint 1 arrlength 2 104 0 arri 105 oddevenjump
given 0index binari string repres sequenc train car si 0 denot ith car contain illeg good si 1 denot ith car contain illeg good train conductor would like get rid car contain illeg good follow three oper number time remov train car left end ie remov s0 take 1 unit time remov train car right end ie remov sslength 1 take 1 unit time remov train car anywher sequenc take 2 unit time return minimum time remov car contain illeg good note empti sequenc car consid car contain illeg good exampl 1 input 1100101 output 5 explan one way remov car contain illeg good sequenc remov car left end 2 time time taken 2 1 2 remov car right end time taken 1 remov car contain illeg good found middl time taken 2 obtain total time 2 1 2 5 altern way remov car left end 2 time time taken 2 1 2 remov car right end 3 time time taken 3 1 3 also obtain total time 2 3 5 5 minimum time taken remov car contain illeg good way remov less time exampl 2 input 0010 output 2 explan one way remov car contain illeg good sequenc remov car left end 3 time time taken 3 1 3 obtain total time 3 anoth way remov car contain illeg good sequenc remov car contain illeg good found middl time taken 2 obtain total time 2 anoth way remov car contain illeg good sequenc remov car right end 2 time time taken 2 1 2 obtain total time 2 2 minimum time taken remov car contain illeg good way remov less time constraint 1 slength 2 105 si either 0 1 minimumtimetoremoveallcarscontainingillegalgood
squar tripl abc tripl b c integ a2 b2 c2 given integ n return number squar tripl 1 b c n exampl 1 input n 5 output 2 explan squar tripl 345 435 exampl 2 input n 10 output 4 explan squar tripl 345 435 6810 8610 constraint 1 n 250 countsquaresumtripl
sql schema pandan schema tabl cours column name type student varchar class varchar sql student class primari key column tabl row tabl indic name student class enrol find class least five student return result tabl order result format follow exampl exampl 1 input cours tabl student class math b english c math biolog e math f comput g math h math math output class math explan math 6 student includ english 1 student includ biolog 1 student includ comput 1 student includ classesmorethan5stud
kbook happen k event nonempti intersect ie time common k event given event starttim endtim given event return integ k repres maximum kbook previou event implement mycalendarthre class mycalendarthre initi object int bookint starttim int endtim return integ k repres largest integ exist kbook calendar exampl 1 input mycalendarthre book book book book book book 10 20 50 60 10 40 5 15 5 10 25 55 output null 1 1 2 3 3 3 explan mycalendarthre mycalendarthre new mycalendarthre mycalendarthreebook10 20 return 1 mycalendarthreebook50 60 return 1 mycalendarthreebook10 40 return 2 mycalendarthreebook5 15 return 3 mycalendarthreebook5 10 return 3 mycalendarthreebook25 55 return 3 constraint 0 starttim endtim 109 400 call made book mycalendariii
given head singli link list integ k split link list k consecut link list part length part equal possibl two part size differ one may lead part null part order occurr input list part occur earlier alway size greater equal part occur later return array k part exampl 1 input head 123 k 5 output 123 explan first element output0 output0v 1 output0next null last element output4 null string represent listnod exampl 2 input head 12345678910 k 3 output 12345678910 explan input split consecut part size differ 1 earlier part larger size later part constraint number node list rang 0 1000 0 nodev 1000 1 k 50 splitlinkedlistinpart
given array k linkedlist list linkedlist sort ascend order merg linkedlist one sort linkedlist return exampl 1 input list 14513426 output 11234456 explan linkedlist 145 134 26 merg one sort list 11234456 exampl 2 input list output exampl 3 input list output constraint k listslength 0 k 104 0 listsilength 500 104 listsij 104 listsi sort ascend order sum listsilength exceed 104 mergeksortedlist
given map server center repres n integ matrix grid 1 mean cell server 0 mean server two server said commun row column return number server commun server exampl 1 input grid 1001 output 0 explan server commun other exampl 2 input grid 1011 output 3 explan three server commun least one server exampl 3 input grid 1100001000100001 output 4 explan two server first row commun two server third column commun server right bottom corner cant commun server constraint gridlength n gridilength 1 250 1 n 250 gridij 0 1 countserversthatcommun
outofboundarypath
given binari tree root link list head first node return true element link list start head correspond downward path connect binari tree otherwis return fals context downward path mean path start node goe downward exampl 1 input head 428 root 144null22null1null68nullnullnullnull13 output true explan node blue form subpath binari tree exampl 2 input head 1426 root 144null22null1null68nullnullnullnull13 output true exampl 3 input head 14268 root 144null22null1null68nullnullnullnull13 output fals explan path binari tree contain element link list head constraint number node tree rang 1 2500 number node list rang 1 100 1 nodev 100 node link list binari tree linkedlistinbinarytre
sql schema tabl project column name type projectid int employeeid int projectid employeeid primari key tabl employeeid foreign key employe tabl row tabl indic employe employeeid work project projectid tabl employe column name type employeeid int name varchar experienceyear int employeeid primari key tabl guarante experienceyear null row tabl contain inform one employe write sql queri report averag experi year employe project round 2 digit return result tabl order queri result format follow exampl exampl 1 input project tabl projectid employeeid 1 1 1 2 1 3 2 1 2 4 employe tabl employeeid name experienceyear 1 khale 3 2 ali 2 3 john 1 4 doe 2 output projectid averageyear 1 200 2 250 explan averag experi year first project 3 2 1 3 200 second project 3 2 2 250 projectemployeesi
peak element 2d grid element strictli greater adjac neighbor left right top bottom given 0index x n matrix mat two adjac cell equal find peak element matij return length 2 array ij may assum entir matrix surround outer perimet valu 1 cell must write algorithm run om logn logm time exampl 1 input mat 1432 output 01 explan 3 4 peak element 10 01 accept answer exampl 2 input mat 10201521301471632 output 11 explan 30 32 peak element 11 22 accept answer constraint matlength n matilength 1 n 500 1 matij 105 two adjac cell equal findapeakelementii
critic point link list defin either local maxima local minima node local maxima current node valu strictli greater previou node next node node local minima current node valu strictli smaller previou node next node note node local maximaminima exist previou node next node given link list head return array length 2 contain mindist maxdist mindist minimum distanc two distinct critic point maxdist maximum distanc two distinct critic point fewer two critic point return 1 1 exampl 1 input head 31 output 11 explan critic point 31 exampl 2 input head 5312512 output 13 explan three critic point 5312512 third node local minima 1 less 3 2 5312512 fifth node local maxima 5 greater 2 1 5312512 sixth node local minima 1 less 5 2 minimum distanc fifth sixth node mindist 6 5 1 maximum distanc third sixth node maxdist 6 3 3 exampl 3 input head 132232227 output 33 explan two critic point 132232227 second node local maxima 3 greater 1 2 132232227 fifth node local maxima 3 greater 2 2 minimum maximum distanc second fifth node thu mindist maxdist 5 2 3 note last node consid local maxima next node constraint number node list rang 2 105 1 nodev 105 findtheminimumandmaximumnumberofnodesbetweencriticalpoint
given two string repres nonneg ration number return true repres number string may use parenthes denot repeat part ration number ration number repres use three part integerpart nonrepeatingpart repeatingpart number repres one follow three way integerpart exampl 12 0 123 integerpartnonrepeatingpart exampl 05 1 212 1230001 integerpartnonrepeatingpartrepeatingpart exampl 016 19 123001212 repeat portion decim expans convent denot within pair round bracket exampl 16 016666666 016 016666 016666 exampl 1 input 052 0525 output true explan 052 repres 052525252 0525 repres 052525252525 string repres number exampl 2 input 016666 016666 output true exampl 3 input 099 1 output true explan 099 repres 0999999999 repeat forev equal 1 see link explan 1 repres number 1 form correctli integerpart 1 nonrepeatingpart constraint part consist digit integerpart lead zero except zero 1 integerpartlength 4 0 nonrepeatingpartlength 4 1 repeatingpartlength 4 equalrationalnumb
given two integ left right repres rang left right return bitwis number rang inclus exampl 1 input left 5 right 7 output 4 exampl 2 input left 0 right 0 output 0 exampl 3 input left 1 right 2147483647 output 0 constraint 0 left right 231 1 bitwiseandofnumbersrang
given coordin two rectilinear rectangl 2d plane return total area cover two rectangl first rectangl defin bottomleft corner ax1 ay1 topright corner ax2 ay2 second rectangl defin bottomleft corner bx1 by1 topright corner bx2 by2 exampl 1 input ax1 3 ay1 0 ax2 3 ay2 4 bx1 0 by1 1 bx2 9 by2 2 output 45 exampl 2 input ax1 2 ay1 2 ax2 2 ay2 2 bx1 2 by1 2 bx2 2 by2 2 output 16 constraint 104 ax1 ax2 104 104 ay1 ay2 104 104 bx1 bx2 104 104 by1 by2 104 rectanglearea
given root binari tree return sum left leav leaf node children left leaf leaf left child anoth node exampl 1 input root 3920nullnull157 output 24 explan two left leav binari tree valu 9 15 respect exampl 2 input root 1 output 0 constraint number node tree rang 1 1000 1000 nodev 1000 sumofleftleav
sentenc consist lowercas letter z digit 0 9 hyphen punctuat mark space sentenc broken one token separ one space token valid word three follow true contain lowercas letter hyphen andor punctuat digit one hyphen present must surround lowercas charact ab valid ab ab valid one punctuat mark present must end token ab cd valid ab c valid exampl valid word includ ab afad bac given string sentenc return number valid word sentenc exampl 1 input sentenc cat dog output 3 explan valid word sentenc cat dog exampl 2 input sentenc 1s b8d output 0 explan valid word sentenc invalid start punctuat mark 1s b8d invalid contain digit exampl 3 input sentenc alic bob play stonegame10 output 5 explan valid word sentenc alic bob play stonegame10 invalid contain digit constraint 1 sentencelength 1000 sentenc contain lowercas english letter digit least 1 token numberofvalidwordsinasent
given array point contain coordin point 2d plane sort xvalu pointsi xi yi xi xj 1 j pointslength also given integ k return maximum valu equat yi yj xi xj xi xj k 1 j pointslength guarante exist least one pair point satisfi constraint xi xj k exampl 1 input point 1320510610 k 1 output 4 explan first two point satisfi condit xi xj 1 calcul equat get 3 0 1 2 4 third fourth point also satisfi condit give valu 10 10 5 6 1 pair satisfi condit return max 4 1 exampl 2 input point 003092 k 3 output 3 explan first two point absolut differ 3 less xvalu give valu 0 0 0 3 3 constraint 2 pointslength 105 pointsilength 2 108 xi yi 108 0 k 2 108 xi xj 1 j pointslength xi form strictli increas sequenc maxvalueofequ
n super wash machin line initi wash machin dress empti move could choos 1 n wash machin pass one dress wash machin one adjac wash machin time given integ array machin repres number dress wash machin left right line return minimum number move make wash machin number dress possibl return 1 exampl 1 input machin 105 output 3 explan 1st move 1 0 5 1 1 4 2nd move 1 1 4 2 1 3 3rd move 2 1 3 2 2 2 exampl 2 input machin 030 output 2 explan 1st move 0 3 0 1 2 0 2nd move 1 2 0 1 1 1 exampl 3 input machin 020 output 1 explan imposs make three wash machin number dress constraint n machineslength 1 n 104 0 machinesi 105 superwashingmachin
given string return string replac everi uppercas letter lowercas letter exampl 1 input hello output hello exampl 2 input output exampl 3 input love output love constraint 1 slength 100 consist printabl ascii charact tolowercas
two type person good person person alway tell truth bad person person might tell truth might lie given 0index 2d integ array statement size n x n repres statement made n peopl specif statementsij could one follow 0 repres statement made person person j bad person 1 repres statement made person person j good person 2 repres statement made person person j addit person ever make statement formal statementsii 2 0 n return maximum number peopl good base statement made n peopl exampl 1 input statement 212122202 output 2 explan person make singl statement person 0 state person 1 good person 1 state person 0 good person 2 state person 1 bad let take person 2 key assum person 2 good person base statement made person 2 person 1 bad person know sure person 1 bad person 2 good base statement made person 1 sinc person 1 bad could tell truth contradict case assumpt invalid lie case person 0 also bad person lie statement follow person 2 good person one good person group assum person 2 bad person base statement made person 2 sinc person 2 bad could tell truth follow scenario person 0 1 bad explain follow person 2 bad told truth good person group lie case person 1 good person sinc person 1 good person person 0 also good person follow person 2 bad lie two good person group see 2 person good best case return 2 note one way arriv conclus exampl 2 input statement 2002 output 1 explan person make singl statement person 0 state person 1 bad person 1 state person 0 bad let take person 0 key assum person 0 good person base statement made person 0 person 1 bad person lie follow person 0 good person one good person group assum person 0 bad person base statement made person 0 sinc person 0 bad could tell truth follow scenario person 0 1 bad follow person 0 bad told truth good person group lie case person 1 good person follow person 0 bad lie one good person group see one person good best case return 1 note one way arriv conclus constraint n statementslength statementsilength 2 n 15 statementsij either 0 1 2 statementsii 2 maximumgoodpeoplebasedonstat
findrootofnarytre
given network n node repres n x n adjac matrix graph ith node directli connect jth node graphij 1 node initi initi infect malwar whenev two node directli connect least one two node infect malwar node infect malwar spread malwar continu node infect manner suppos miniti final number node infect malwar entir network spread malwar stop remov exactli one node initi return node remov would minim miniti multipl node could remov minim miniti return node smallest index note node remov initi list infect node might still infect later due malwar spread exampl 1 input graph 110110001 initi 01 output 0 exampl 2 input graph 100010001 initi 02 output 0 exampl 3 input graph 111111111 initi 12 output 1 constraint n graphlength n graphilength 2 n 300 graphij 0 1 graphij graphji graphii 1 1 initiallength n 0 initiali n 1 integ initi uniqu minimizemalwarespread
n x n 0index grid artifact buri given integ n 0index 2d integ array artifact describ posit rectangular artifact artifactsi r1i c1i r2i c2i denot ith artifact buri subgrid r1i c1i coordin topleft cell ith artifact r2i c2i coordin bottomright cell ith artifact excav cell grid remov mud cell part artifact buri underneath uncov part artifact uncov extract given 0index 2d integ array dig digi ri ci indic excav cell ri ci return number artifact extract test case gener two artifact overlap artifact cover 4 cell entri dig uniqu exampl 1 input n 2 artifact 00000111 dig 0001 output 1 explan differ color repres differ artifact excav cell label grid 1 artifact extract name red artifact blue artifact one part cell 11 remain uncov extract thu return 1 exampl 2 input n 2 artifact 00000111 dig 000111 output 2 explan red blue artifact part uncov label extract return 2 constraint 1 n 1000 1 artifactslength diglength minn2 105 artifactsilength 4 digilength 2 0 r1i c1i r2i c2i ri ci n 1 r1i r2i c1i c2i two artifact overlap number cell cover artifact 4 entri dig uniqu countartifactsthatcanbeextract
given undirect tree consist n vertic number 1 n frog start jump vertex 1 one second frog jump current vertex anoth unvisit vertex directli connect frog jump back visit vertex case frog jump sever vertic jump randomli one probabl otherwis frog jump unvisit vertex jump forev vertex edg undirect tree given array edg edgesi ai bi mean exist edg connect vertic ai bi return probabl second frog vertex target answer within 105 actual answer accept exampl 1 input n 7 edg 121317242635 2 target 4 output 016666666666666666 explan figur show given graph frog start vertex 1 jump 13 probabl vertex 2 second 1 jump 12 probabl vertex 4 second 2 thu probabl frog vertex 4 2 second 13 12 16 016666666666666666 exampl 2 input n 7 edg 121317242635 1 target 7 output 03333333333333333 explan figur show given graph frog start vertex 1 jump 13 03333333333333333 probabl vertex 7 second 1 constraint 1 n 100 edgeslength n 1 edgesilength 2 1 ai bi n 1 50 1 target n frogpositionaftertsecond
given array num size n consist distinct integ 1 n posit integ k return number nonempti subarray num median equal k note median array middl element sort array ascend order array even length median left middl element exampl median 2314 2 median 84351 4 subarray contigu part array exampl 1 input num 32145 k 4 output 3 explan subarray median equal 4 4 45 145 exampl 2 input num 231 k 3 output 1 explan 3 subarray median equal 3 constraint n numslength 1 n 105 1 numsi k n integ num distinct countsubarrayswithmediank
given integ number n return differ product digit sum digit exampl 1 input n 234 output 15 explan product digit 2 3 4 24 sum digit 2 3 4 9 result 24 9 15 exampl 2 input n 4421 output 21 explan product digit 4 4 2 1 32 sum digit 4 4 2 1 11 result 32 11 21 constraint 1 n 105 subtracttheproductandsumofdigitsofaninteg
given x n binari matrix mat return distanc nearest 0 cell distanc two adjac cell 1 exampl 1 input mat 000010000 output 000010000 exampl 2 input mat 000010111 output 000010121 constraint matlength n matilength 1 n 104 1 n 104 matij either 0 1 least one 0 mat 01matrix
write class allow get set keyvalu pair howev time expir associ key class three public method setkey valu durat accept integ key integ valu durat millisecond durat elaps key inaccess method return true unexpir key alreadi exist fals otherwis valu durat overwritten key alreadi exist getkey unexpir key exist return associ valu otherwis return 1 count return count unexpir key exampl 1 input timelimitedcach set get count get 1 42 100 1 1 0 0 50 50 150 output null fals 42 1 1 explan t0 cach construct t0 keyvalu pair 1 42 ad time limit 100m valu doesnt exist fals return t50 key1 request valu 42 return t50 count call one activ key cach t100 key1 expir t150 get1 call 1 return cach empti exampl 2 input timelimitedcach set set get get get count 1 42 50 1 50 100 1 1 1 0 0 40 50 120 200 250 output null fals true 50 50 1 explan t0 cach construct t0 keyvalu pair 1 42 ad time limit 50m valu doesnt exist fals return t40 keyvalu pair 1 50 ad time limit 100m nonexpir valu alreadi exist true return old valu overwritten t50 get1 call return 50 t120 get1 call return 50 t140 key1 expir t200 get1 call cach empti 1 return t250 count return 0 cach empti constraint 0 key 109 0 valu 109 0 durat 1000 total method call exceed 100 cachewithtimelimit
world dota2 two parti radiant dire dota2 senat consist senat come two parti senat want decid chang dota2 game vote chang roundbas procedur round senat exercis one two right ban one senat right senat make anoth senat lose right follow round announc victori senat found senat still right vote parti announc victori decid chang game given string senat repres senat parti belong charact r repres radiant parti dire parti n senat size given string n roundbas procedur start first senat last senat given order procedur last end vote senat lost right skip procedur suppos everi senat smart enough play best strategi parti predict parti final announc victori chang dota2 game output radiant dire exampl 1 input senat rd output radiant explan first senat come radiant ban next senat right round 1 second senat cant exercis right anymor sinc right ban round 2 first senat announc victori sinc guy senat vote exampl 2 input senat rdd output dire explan first senat come radiant ban next senat right round 1 second senat cant exercis right anymor sinc right ban third senat come dire ban first senat right round 1 round 2 third senat announc victori sinc guy senat vote constraint n senatelength 1 n 104 senatei either r dota2sen
design data structur keep track valu answer queri regard frequenc implement frequencytrack class frequencytrack initi frequencytrack object empti array initi void addint number add number data structur void deleteoneint number delet one occurr number data structur data structur may contain number case noth delet bool hasfrequencyint frequenc return true number data structur occur frequenc number time otherwis return fals exampl 1 input frequencytrack add add hasfrequ 3 3 2 output null null null true explan frequencytrack frequencytrack new frequencytrack frequencytrackeradd3 data structur contain 3 frequencytrackeradd3 data structur contain 3 3 frequencytrackerhasfrequency2 return true 3 occur twice exampl 2 input frequencytrack add deleteon hasfrequ 1 1 1 output null null null fals explan frequencytrack frequencytrack new frequencytrack frequencytrackeradd1 data structur contain 1 frequencytrackerdeleteone1 data structur becom empti frequencytrackerhasfrequency1 return fals data structur empti exampl 3 input frequencytrack hasfrequ add hasfrequ 2 3 1 output null fals null true explan frequencytrack frequencytrack new frequencytrack frequencytrackerhasfrequency2 return fals data structur empti frequencytrackeradd3 data structur contain 3 frequencytrackerhasfrequency1 return true 3 occur constraint 1 number 105 1 frequenc 105 2 105 call made add deleteon hasfrequ total frequencytrack
given n cuboid dimens ith cuboid cuboidsi widthi lengthi heighti 0index choos subset cuboid place place cuboid cuboid j widthi widthj lengthi lengthj heighti heightj rearrang cuboid dimens rotat put anoth cuboid return maximum height stack cuboid exampl 1 input cuboid 504520953753452312 output 190 explan cuboid 1 place bottom 53x37 side face height 95 cuboid 0 place next 45x20 side face height 50 cuboid 2 place next 23x12 side face height 45 total height 95 50 45 190 exampl 2 input cuboid 38254576353 output 76 explan cant place cuboid choos cuboid 1 rotat 35x3 side face height 76 exampl 3 input cuboid 711177171111717111771771117117 output 102 explan rearrang cuboid see cuboid dimens place 11x7 side cuboid height 17 maximum height stack cuboid 6 17 102 constraint n cuboidslength 1 n 100 1 widthi lengthi heighti 100 maximumheightbystackingcuboid
sql schema pandan schema tabl employe column name type empid int eventday date intim int outtim int sql empid eventday intim primari key tabl tabl show employe entri exit offic eventday day event happen intim minut employe enter offic outtim minut left offic intim outtim 1 1440 guarante two event day intersect time intim outtim calcul total time minut spent employe day offic note within one day employe enter leav time spent offic singl entri outtim intim return result tabl order result format follow exampl exampl 1 input employe tabl empid eventday intim outtim 1 20201128 4 32 1 20201128 55 200 1 20201203 1 42 2 20201128 3 33 2 20201209 47 74 output day empid totaltim 20201128 1 173 20201128 2 30 20201203 1 41 20201209 2 27 explan employe 1 three event two day 20201128 total 32 4 200 55 173 one day 20201203 total 42 1 41 employe 2 two event one day 20201128 total 33 3 30 one day 20201209 total 74 47 27 findtotaltimespentbyeachemploye
given posit integ array grade repres grade student univers would like enter student competit order nonempti group order meet follow condit sum grade student ith group less sum grade student 1th group group except last total number student ith group less total number student 1th group group except last return maximum number group form exampl 1 input grade 10612735 output 3 explan follow possibl way form 3 group student 1st group student grade 12 sum grade 12 student count 1 2nd group student grade 67 sum grade 6 7 13 student count 2 3rd group student grade 1035 sum grade 10 3 5 18 student count 3 shown possibl form 3 group exampl 2 input grade 88 output 1 explan form 1 group sinc form 2 group would lead equal number student group constraint 1 gradeslength 105 1 gradesi 105 maximumnumberofgroupsenteringacompetit
given integ array num one move pick index 0 numslength increment numsi 1 return minimum number move make everi valu num uniqu test case gener answer fit 32bit integ exampl 1 input num 122 output 1 explan 1 move array could 1 2 3 exampl 2 input num 321217 output 6 explan 6 move array could 3 4 1 2 5 7 shown 5 less move imposs array uniqu valu constraint 1 numslength 105 0 numsi 105 minimumincrementtomakearrayuniqu
respect given puzzl string word valid follow condit satisfi word contain first letter puzzl letter word letter puzzl exampl puzzl abcdefg valid word face cabbag baggag invalid word beef includ base includ puzzl return array answer answeri number word given word list word valid respect puzzl puzzlesi exampl 1 input word aaaaasasableabilityacttactoraccess puzzl aboveyzabrodyzabsluteabsoryzactreszgaswxyz output 113240 explan 1 valid word aboveyz aaaa 1 valid word abrodyz aaaa 3 valid word abslut aaaa asa abl 2 valid word absoryz aaaa asa 4 valid word actresz aaaa asa actt access valid word gaswxyz caus none word list contain letter g exampl 2 input word applepleaspleas puzzl aelwxyzaelpxyzaelpsxysaelpxyxaelpsi output 01320 constraint 1 wordslength 105 4 wordsilength 50 1 puzzleslength 104 puzzlesilength 7 wordsi puzzlesi consist lowercas english letter puzzlesi contain repeat charact numberofvalidwordsforeachpuzzl
given array n string str length may choos delet indic delet charact indic string exampl str abcdefuvwxyz delet indic 0 2 3 final array delet bef vyz suppos chose set delet indic answer delet final array everi string row lexicograph order ie strs00 strs01 strs0strs0length 1 strs10 strs11 strs1strs1length 1 return minimum possibl valu answerlength exampl 1 input str babcabbazb output 3 explan delet column 0 1 4 final array str bc az row individu lexicograph order ie strs00 strs01 strs10 strs11 note strs0 strs1 array str necessarili lexicograph order exampl 2 input str edcba output 4 explan delet less 4 column row lexicograph sort exampl 3 input str ghidefabc output 0 explan row alreadi lexicograph sort constraint n strslength 1 n 100 1 strsilength 100 strsi consist lowercas english letter deletecolumnstomakesortediii
robot factori xaxi given integ array robot roboti posit ith robot also given 2d integ array factori factoryj positionj limitj indic positionj posit jth factori jth factori repair limitj robot posit robot uniqu posit factori also uniqu note robot posit factori initi robot initi broken keep move one direct direct could neg posit direct xaxi robot reach factori reach limit factori repair robot stop move moment set initi direct move robot target minim total distanc travel robot return minimum total distanc travel robot test case gener robot repair note robot move speed two robot move direct never collid two robot move opposit direct meet point collid cross robot pass factori reach limit cross exist robot move posit x posit distanc move x exampl 1 input robot 046 factori 2262 output 4 explan shown figur first robot posit 0 move posit direct repair first factori second robot posit 4 move neg direct repair first factori third robot posit 6 repair second factori need move limit first factori 2 fix 2 robot limit second factori 2 fix 1 robot total distanc 2 0 2 4 6 6 4 shown achiev better total distanc 4 exampl 2 input robot 11 factori 2121 output 2 explan shown figur first robot posit 1 move posit direct repair second factori second robot posit 1 move neg direct repair first factori limit first factori 1 fix 1 robot limit second factori 1 fix 1 robot total distanc 2 1 2 1 2 shown achiev better total distanc 2 constraint 1 robotlength factorylength 100 factoryjlength 2 109 roboti positionj 109 0 limitj robotlength input gener alway possibl repair everi robot minimumtotaldistancetravel
given root binari search tree bst valu exactli two node tree swap mistak recov tree without chang structur exampl 1 input root 13nullnull2 output 31nullnull2 explan 3 left child 1 3 1 swap 1 3 make bst valid exampl 2 input root 314nullnull2 output 214nullnull3 explan 2 right subtre 3 2 3 swap 2 3 make bst valid constraint number node tree rang 2 1000 231 nodev 231 1 follow solut use space pretti straightforward could devis constant o1 space solut recoverbinarysearchtre
sql schema tabl product column name type productid int productnam varchar unitpric int productid primari key tabl row tabl indic name price product tabl sale column name type sellerid int productid int buyerid int saled date quantiti int price int tabl primari key repeat row productid foreign key product tabl row tabl contain inform one sale write sql queri report product sold first quarter 2019 20190101 20190331 inclus return result tabl order queri result format follow exampl exampl 1 input product tabl productid productnam unitpric 1 s8 1000 2 g4 800 3 iphon 1400 sale tabl sellerid productid buyerid saled quantiti price 1 1 1 20190121 2 2000 1 2 2 20190217 1 800 2 2 3 20190602 1 800 3 3 4 20190513 2 2800 output productid productnam 1 s8 explan product id 1 sold spring 2019 product id 2 sold spring 2019 also sold spring 2019 product id 3 sold spring 2019 return product 1 product sold spring 2019 salesanalysisiii
task calcul ab mod 1337 posit integ b extrem larg posit integ given form array exampl 1 input 2 b 3 output 8 exampl 2 input 2 b 10 output 1024 exampl 3 input 1 b 433852 output 1 constraint 1 231 1 1 blength 2000 0 bi 9 b contain lead zero superpow
given head sort link list delet duplic element appear return link list sort well exampl 1 input head 112 output 12 exampl 2 input head 11233 output 123 constraint number node list rang 0 300 100 nodev 100 list guarante sort ascend order removeduplicatesfromsortedlist
given binari tree find minimum depth minimum depth number node along shortest path root node nearest leaf node note leaf node children exampl 1 input root 3920nullnull157 output 2 exampl 2 input root 2null3null4null5null6 output 5 constraint number node tree rang 0 105 1000 nodev 1000 minimumdepthofbinarytre
valid ip address consist exactli four integ separ singl dot integ 0 255 inclus lead zero exampl 012201 19216811 valid ip address 0011255245 1921681312 19216811 invalid ip address given string contain digit return possibl valid ip address form insert dot allow reorder remov digit may return valid ip address order exampl 1 input 25525511135 output 2552551113525525511135 exampl 2 input 0000 output 0000 exampl 3 input 101023 output 101023101023101023101023101023 constraint 1 slength 20 consist digit restoreipaddress
n student class number 0 n 1 teacher give student problem start student number 0 student number 1 teacher reach student number n 1 teacher restart process start student number 0 given 0index integ array chalk integ k initi k piec chalk student number given problem solv use chalki piec chalk solv problem howev current number chalk piec strictli less chalki student number ask replac chalk return index student replac chalk piec exampl 1 input chalk 515 k 22 output 0 explan student go turn follow student number 0 use 5 chalk k 17 student number 1 use 1 chalk k 16 student number 2 use 5 chalk k 11 student number 0 use 5 chalk k 6 student number 1 use 1 chalk k 5 student number 2 use 5 chalk k 0 student number 0 enough chalk replac exampl 2 input chalk 3412 k 25 output 1 explan student go turn follow student number 0 use 3 chalk k 22 student number 1 use 4 chalk k 18 student number 2 use 1 chalk k 17 student number 3 use 2 chalk k 15 student number 0 use 3 chalk k 12 student number 1 use 4 chalk k 8 student number 2 use 1 chalk k 7 student number 3 use 2 chalk k 5 student number 0 use 3 chalk k 2 student number 1 enough chalk replac constraint chalklength n 1 n 105 1 chalki 105 1 k 109 findthestudentthatwillreplacethechalk
broken calcul integ startvalu display initi one oper multipli number display 2 subtract 1 number display given two integ startvalu target return minimum number oper need display target calcul exampl 1 input startvalu 2 target 3 output 2 explan use doubl oper decrement oper 2 4 3 exampl 2 input startvalu 5 target 8 output 2 explan use decrement doubl 5 4 8 exampl 3 input startvalu 3 target 10 output 3 explan use doubl decrement doubl 3 6 5 10 constraint 1 startvalu target 109 brokencalcul
given root binari tree return maximum depth binari tree maximum depth number node along longest path root node farthest leaf node exampl 1 input root 3920nullnull157 output 3 exampl 2 input root 1null2 output 2 constraint number node tree rang 0 104 100 nodev 100 maximumdepthofbinarytre
given array distinct integ arr array integ array piec integ piec distinct goal form arr concaten array piec order howev allow reorder integ array piecesi return true possibl form array arr piec otherwis return fals exampl 1 input arr 1588 piec 8815 output true explan concaten 15 88 exampl 2 input arr 491816 piec 161849 output fals explan even though number match reorder pieces0 exampl 3 input arr 9146478 piec 7846491 output true explan concaten 91 464 78 constraint 1 pieceslength arrlength 100 sumpiecesilength arrlength 1 piecesilength arrlength 1 arri piecesij 100 integ arr distinct integ piec distinct ie flatten piec 1d array integ array distinct checkarrayformationthroughconcaten
knight n x n chessboard valid configur knight start topleft cell board visit everi cell board exactli given n x n integ matrix grid consist distinct integ rang 0 n n 1 gridrowcol indic cell row col gridrowcolth cell knight visit move 0index return true grid repres valid configur knight movement fals otherwis note valid knight move consist move two squar vertic one squar horizont two squar horizont one squar vertic figur illustr possibl eight move knight cell exampl 1 input grid 0111652017419101512182163182314924132722 output true explan diagram repres grid shown valid configur exampl 2 input grid 036581274 output fals explan diagram repres grid 8th move knight valid consid posit 7th move constraint n gridlength gridilength 3 n 7 0 gridrowcol n n integ grid uniqu checkknighttourconfigur
suppos array length n sort ascend order rotat 1 n time exampl array num 0144567 might becom 4567014 rotat 4 time 0144567 rotat 7 time notic rotat array a0 a1 a2 an1 1 time result array an1 a0 a1 a2 an2 given sort rotat array num may contain duplic return minimum element array must decreas overal oper step much possibl exampl 1 input num 135 output 1 exampl 2 input num 22201 output 0 constraint n numslength 1 n 5000 5000 numsi 5000 num sort rotat 1 n time follow problem similar find minimum rotat sort array num may contain duplic would affect runtim complex findminimuminrotatedsortedarrayii
integ sequenti digit digit number one previou digit return sort list integ rang low high inclus sequenti digit exampl 1 input low 100 high 300 output 123234 exampl 2 input low 1000 high 13000 output 12342345345645675678678912345 constraint 10 low high 109 sequentialdigit
given array string word 0index one oper pick two distinct indic j wordsi nonempti string move charact wordsi posit wordsj return true make everi string word equal use number oper fals otherwis exampl 1 input word abcaabcbc output true explan move first words1 front words2 make words1 abc words2 abc string equal abc return true exampl 2 input word aba output fals explan imposs make string equal use oper constraint 1 wordslength 100 1 wordsilength 100 wordsi consist lowercas english letter redistributecharacterstomakeallstringsequ
given 2d integ array circl circlesi xi yi ri repres center xi yi radiu ri ith circl drawn grid return number lattic point present insid least one circl note lattic point point integ coordin point lie circumfer circl also consid insid exampl 1 input circl 221 output 5 explan figur show given circl lattic point present insid circl 1 2 2 1 2 2 2 3 3 2 shown green point 1 1 1 3 shown red consid insid circl henc number lattic point present insid least one circl 5 exampl 2 input circl 222341 output 16 explan figur show given circl exactli 16 lattic point present insid least one circl 0 2 2 0 2 4 3 2 4 4 constraint 1 circleslength 200 circlesilength 3 1 xi yi 100 1 ri minxi yi countlatticepointsinsideacircl
given integ array arr map function fn return new array transform appli element return array creat returnedarrayi fnarri pleas solv without builtin arraymap method exampl 1 input arr 123 fn function plusonen return n 1 output 234 explan const newarray maparr pluson 234 function increas valu array one exampl 2 input arr 123 fn function plusin return n output 135 explan function increas valu index resid exampl 3 input arr 102030 fn function constant return 42 output 424242 explan function alway return 42 constraint 0 arrlength 1000 109 arri 109 fn return number applytransformovereachelementinarray
given array num return true array origin sort nondecreas order rotat number posit includ zero otherwis return fals may duplic origin array note array rotat x posit result array b length ai bix alength modulo oper exampl 1 input num 34512 output true explan 12345 origin sort array rotat array x 3 posit begin element valu 3 34512 exampl 2 input num 2134 output fals explan sort array rotat make num exampl 3 input num 123 output true explan 123 origin sort array rotat array x 0 posit ie rotat make num constraint 1 numslength 100 1 numsi 100 checkifarrayissortedandrot
string beauti consist first k letter english lowercas alphabet contain substr length 2 palindrom given beauti string length n posit integ k return lexicograph smallest string length n larger beauti string return empti string string lexicograph larger string b length first posit b differ charact strictli larger correspond charact b exampl abcd lexicograph larger abcc first posit differ fourth charact greater c exampl 1 input abcz k 26 output abda explan string abda beauti lexicograph larger string abcz proven string lexicograph larger string abcz beauti lexicograph smaller string abda exampl 2 input dc k 4 output explan proven string lexicograph larger string dc beauti constraint 1 n slength 105 4 k 26 beauti string lexicographicallysmallestbeautifulstr
given integ array match matchesi winneri loseri indic player winneri defeat player loseri match return list answer size 2 answer0 list player lost match answer1 list player lost exactli one match valu two list return increas order note consid player play least one match testcas gener two match outcom exampl 1 input match 1323365657454849104109 output 12104578 explan player 1 2 10 lost match player 4 5 7 8 lost one match player 3 6 9 lost two match thu answer0 1210 answer1 4578 exampl 2 input match 23135464 output 1256 explan player 1 2 5 6 lost match player 3 4 lost two match thu answer0 1256 answer1 constraint 1 matcheslength 105 matchesilength 2 1 winneri loseri 105 winneri loseri matchesi uniqu findplayerswithzerooroneloss
given list domino dominoesi b equival dominoesj c either c b b c one domino rotat equal anoth domino return number pair j 0 j dominoeslength dominoesi equival dominoesj exampl 1 input domino 12213456 output 1 exampl 2 input domino 1212111222 output 3 constraint 1 dominoeslength 4 104 dominoesilength 2 1 dominoesij 9 numberofequivalentdominopair
given n point 2d plane pointsi xi yi return widest vertic area two point point insid area vertic area area fixedwidth extend infinit along yaxi ie infinit height widest vertic area one maximum width note point edg vertic area consid includ area exampl 1 input point 87997497 output 1 explan red blue area optim exampl 2 input point 319010145388 output 3 constraint n pointslength 2 n 105 pointsilength 2 0 xi yi 109 widestverticalareabetweentwopointscontainingnopoint
given string digit return number palindrom subsequ length 5 sinc answer may larg return modulo 109 7 note string palindrom read forward backward subsequ string deriv anoth string delet charact without chang order remain charact exampl 1 input 103301 output 2 explan 6 possibl subsequ length 5 103301033110301103011330103301 two equal 10301 palindrom exampl 2 input 0000000 output 21 explan 21 subsequ 00000 palindrom exampl 3 input 9999900000 output 2 explan two palindrom subsequ 99999 00000 constraint 1 slength 104 consist digit countpalindromicsubsequ
n dice die k face number 1 k given three integ n k target return number possibl way kn total way roll dice sum faceup number equal target sinc answer may larg return modulo 109 7 exampl 1 input n 1 k 6 target 3 output 1 explan throw one die 6 face one way get sum 3 exampl 2 input n 2 k 6 target 7 output 6 explan throw two dice 6 face 6 way get sum 7 16 25 34 43 52 61 exampl 3 input n 30 k 30 target 500 output 222616187 explan answer must return modulo 109 7 constraint 1 n k 30 1 target 1000 numberofdicerollswithtargetsum
given 2d integ array matrix return transpos matrix transpos matrix matrix flip main diagon switch matrix row column indic exampl 1 input matrix 123456789 output 147258369 exampl 2 input matrix 123456 output 142536 constraint matrixlength n matrixilength 1 n 1000 1 n 105 109 matrixij 109 transposematrix
suppos array length n sort ascend order rotat 1 n time exampl array num 0124567 might becom 4567012 rotat 4 time 0124567 rotat 7 time notic rotat array a0 a1 a2 an1 1 time result array an1 a0 a1 a2 an2 given sort rotat array num uniqu element return minimum element array must write algorithm run olog n time exampl 1 input num 34512 output 1 explan origin array 12345 rotat 3 time exampl 2 input num 4567012 output 0 explan origin array 0124567 rotat 4 time exampl 3 input num 11131517 output 11 explan origin array 11131517 rotat 4 time constraint n numslength 1 n 5000 5000 numsi 5000 integ num uniqu num sort rotat 1 n time findminimuminrotatedsortedarray
revers bit given 32 bit unsign integ note note languag java unsign integ type case input output given sign integ type affect implement integ intern binari represent whether sign unsign java compil repres sign integ use 2s complement notat therefor exampl 2 input repres sign integ 3 output repres sign integ 1073741825 exampl 1 input n 00000010100101000001111010011100 output 964176192 00111001011110000010100101000000 explan input binari string 00000010100101000001111010011100 repres unsign integ 43261596 return 964176192 binari represent 00111001011110000010100101000000 exampl 2 input n 11111111111111111111111111111101 output 3221225471 10111111111111111111111111111111 explan input binari string 11111111111111111111111111111101 repres unsign integ 4294967293 return 3221225471 binari represent 10111111111111111111111111111111 constraint input must binari string length 32 follow function call mani time would optim reversebit
given integ array cooki cookiesi denot number cooki ith bag also given integ k denot number children distribut bag cooki cooki bag must go child split unfair distribut defin maximum total cooki obtain singl child distribut return minimum unfair distribut exampl 1 input cooki 81510208 k 2 output 31 explan one optim distribut 8158 1020 1st child receiv 8158 total 8 15 8 31 cooki 2nd child receiv 1020 total 10 20 30 cooki unfair distribut max3130 31 shown distribut unfair less 31 exampl 2 input cooki 61322412 k 3 output 7 explan one optim distribut 61 322 412 1st child receiv 61 total 6 1 7 cooki 2nd child receiv 322 total 3 2 2 7 cooki 3rd child receiv 412 total 4 1 2 7 cooki unfair distribut max777 7 shown distribut unfair less 7 constraint 2 cookieslength 8 1 cookiesi 105 2 k cookieslength fairdistributionofcooki
given string licensepl array string word find shortest complet word word complet word word contain letter licensepl ignor number space licensepl treat letter case insensit letter appear licensepl must appear word number time exampl licensepl abc 12c contain letter b ignor case c twice possibl complet word abccdef caaacab cbca return shortest complet word word guarante answer exist multipl shortest complet word return first one occur word exampl 1 input licensepl 1s3 pst word stepstepsstripesteppl output step explan licensepl contain letter p ignor case step contain p contain 1 step contain p charact stripe miss steppl miss sinc step word contain letter answer exampl 2 input licensepl 1s3 456 word lookspeststewshow output pest explan licensepl contain letter word contain among pest stew show shortest answer pest word appear earliest 3 constraint 1 licenseplatelength 7 licensepl contain digit letter uppercas lowercas space 1 wordslength 1000 1 wordsilength 15 wordsi consist lower case english letter shortestcompletingword
given integ array sort nondecreas order exactli one integ array occur 25 time return integ exampl 1 input arr 1226666710 output 6 exampl 2 input arr 11 output 1 constraint 1 arrlength 104 0 arri 105 elementappearingmorethan25insortedarray
given two nonneg integ num1 num2 repres string return product num1 num2 also repres string note must use builtin biginteg librari convert input integ directli exampl 1 input num1 2 num2 3 output 6 exampl 2 input num1 123 num2 456 output 56088 constraint 1 num1length num2length 200 num1 num2 consist digit num1 num2 contain lead zero except number 0 multiplystr
given integ array target integ n empti stack two follow oper push push integ top stack pop remov integ top stack also stream integ rang 1 n use two stack oper make number stack bottom top equal target follow follow rule stream integ empti pick next integ stream push top stack stack empti pop integ top stack moment element stack bottom top equal target read new integ stream oper stack return stack oper need build target follow mention rule multipl valid answer return exampl 1 input target 13 n 3 output pushpushpoppush explan initi stack empti last element top stack read 1 stream push stack 1 read 2 stream push stack 12 pop integ top stack 1 read 3 stream push stack 13 exampl 2 input target 123 n 3 output pushpushpush explan initi stack empti last element top stack read 1 stream push stack 1 read 2 stream push stack 12 read 3 stream push stack 123 exampl 3 input target 12 n 4 output pushpush explan initi stack empti last element top stack read 1 stream push stack 1 read 2 stream push stack 12 sinc stack bottom top equal target stop stack oper answer read integ 3 stream accept constraint 1 targetlength 100 1 n 100 1 targeti n target strictli increas buildanarraywithstackoper
given array num size n return major element major element element appear ⌊n 2⌋ time may assum major element alway exist array exampl 1 input num 323 output 3 exampl 2 input num 2211122 output 2 constraint n numslength 1 n 5 104 109 numsi 109 followup could solv problem linear time o1 space majorityel
given two posit integ n k binari string sn form follow s1 0 si si 1 1 reverseinvertsi 1 1 denot concaten oper reversex return revers string x invertx invert bit x 0 chang 1 1 chang 0 exampl first four string sequenc s1 0 s2 011 s3 0111001 s4 011100110110001 return kth bit sn guarante k valid given n exampl 1 input n 3 k 1 output 0 explan s3 0111001 1st bit 0 exampl 2 input n 4 k 11 output 1 explan s4 011100110110001 11th bit 1 constraint 1 n 20 1 k 2n 1 findkthbitinnthbinarystr
given two string b consist lowercas letter one oper chang charact b lowercas letter goal satisfi one follow three condit everi letter strictli less everi letter b alphabet everi letter b strictli less everi letter alphabet b consist one distinct letter return minimum number oper need achiev goal exampl 1 input aba b caa output 2 explan consid best way make condit true 1 chang b ccc 2 oper everi letter less everi letter b 2 chang bbb b aaa 3 oper everi letter b less everi letter 3 chang aaa b aaa 2 oper b consist one distinct letter best way done 2 oper either condit 1 condit 3 exampl 2 input dabadd b cda output 3 explan best way make condit 1 true chang b eee constraint 1 alength blength 105 b consist lowercas letter changeminimumcharacterstosatisfyoneofthreecondit
given string date repres gregorian calendar date format yyyymmdd return day number year exampl 1 input date 20190109 output 9 explan given date 9th day year 2019 exampl 2 input date 20190210 output 41 constraint datelength 10 date4 date7 datei digit date repres calendar date jan 1st 1900 dec 31th 2019 dayoftheyear
alic bob take turn play game alic start first given string num even length consist digit charact turn player follow still least one num choos index numi replac numi digit 0 9 game end charact num bob win sum digit first half num must equal sum digit second half alic win sum must equal exampl game end num 243801 bob win 243 801 game end num 243803 alic win 243 803 assum alic bob play optim return true alic win fals bob win exampl 1 input num 5023 output fals explan move made sum first half equal sum second half 5 0 2 3 exampl 2 input num 25 output true explan alic replac one 9 imposs bob make sum equal exampl 3 input num 3295 output fals explan proven bob alway win one possibl outcom alic replac first 9 num 93295 bob replac one right half 9 num 932959 alic replac one right half 2 num 9329592 bob replac last right half 7 num 93295927 bob win 9 3 2 9 5 9 2 7 constraint 2 numlength 105 numlength even num consist digit sumgam
want water n plant garden water plant arrang row label 0 n 1 left right ith plant locat x river x 1 refil water plant need specif amount water water plant follow way water plant order left right water current plant enough water complet water next plant return river fulli refil water refil water earli initi river ie x 1 take one step move one unit xaxi given 0index integ array plant n integ plantsi amount water ith plant need integ capac repres water capac return number step need water plant exampl 1 input plant 2233 capac 5 output 14 explan start river full water walk plant 0 1 step water water 3 unit water walk plant 1 1 step water water 1 unit water sinc complet water plant 2 walk back river refil 2 step walk plant 2 3 step water water 2 unit water sinc complet water plant 3 walk back river refil 3 step walk plant 3 4 step water step need 1 1 2 3 3 4 14 exampl 2 input plant 111423 capac 4 output 30 explan start river full water water plant 0 1 2 3 step return river 3 step water plant 3 4 step return river 4 step water plant 4 5 step return river 5 step water plant 5 6 step step need 3 3 4 4 5 5 6 30 exampl 3 input plant 7777777 capac 8 output 49 explan refil water plant step need 1 1 2 2 3 3 4 4 5 5 6 6 7 49 constraint n plantslength 1 n 1000 1 plantsi 106 maxplantsi capac 109 wateringpl
alic bob take turn play game alic start first initi number n chalkboard player turn player make move consist choos x 0 x n n x 0 replac number n chalkboard n x also player make move lose game return true alic win game assum player play optim exampl 1 input n 2 output true explan alic choos 1 bob move exampl 2 input n 3 output fals explan alic choos 1 bob choos 1 alic move constraint 1 n 1000 divisorgam
network n server label 0 n 1 given 2d integ array edg edgesi ui vi indic messag channel server ui vi pass number messag directli one second also given 0index integ array patienc length n server connect ie messag pass one server server directli indirectli messag channel server label 0 master server rest data server data server need send messag master server process wait repli messag move server optim everi messag take least amount time arriv master server master server process newli arriv messag instantli send repli origin server via revers path messag gone begin second 0 data server send messag process start second 1 begin everi second data server check receiv repli messag sent includ newli arriv repli master server resend messag period data server resend messag everi patiencei second ie data server resend messag patiencei second elaps sinc last time messag sent server otherwis resend occur server network becom idl messag pass server arriv server return earliest second start network becom idl exampl 1 input edg 0112 patienc 021 output 8 explan begin second 0 data server 1 send messag denot 1a master server data server 2 send messag denot 2a master server second 1 messag 1a arriv master server master server process messag 1a instantli send repli 1a back server 1 receiv repli 1 second 1 patience1 2 elaps sinc server sent messag therefor resend messag server 2 receiv repli 1 second 1 patience2 1 elaps sinc server sent messag therefor resend messag denot 2b second 2 repli 1a arriv server 1 resend occur server 1 messag 2a arriv master server master server process messag 2a instantli send repli 2a back server 2 resend messag denot 2c second 4 repli 2a arriv server 2 resend occur server 2 second 7 repli 2d arriv server 2 start begin second 8 messag pass server arriv server time network becom idl exampl 2 input edg 010212 patienc 01010 output 3 explan data server 1 2 receiv repli back begin second 2 begin second 3 network becom idl constraint n patiencelength 2 n 105 patience0 0 1 patiencei 105 1 n 1 edgeslength min105 n n 1 2 edgesilength 2 0 ui vi n ui vi duplic edg server directli indirectli reach anoth server thetimewhenthenetworkbecomesidl
given 2d integ array item itemsi pricei beautyi denot price beauti item respect also given 0index integ array queri queriesj want determin maximum beauti item whose price less equal queriesj item exist answer queri 0 return array answer length queri answerj answer jth queri exampl 1 input item 1232245635 queri 123456 output 245566 explan queries01 12 item price 1 henc answer queri 2 queries12 item consid 12 24 maximum beauti among 4 queries23 queries34 item consid 12 32 24 35 maximum beauti among 5 queries45 queries56 item consid henc answer maximum beauti item ie 6 exampl 2 input item 12121314 queri 1 output 4 explan price everi item equal 1 choos item maximum beauti 4 note multipl item price andor beauti exampl 3 input item 101000 queri 5 output 0 explan item price less equal 5 item chosen henc answer queri 0 constraint 1 itemslength querieslength 105 itemsilength 2 1 pricei beautyi queriesj 109 mostbeautifulitemforeachqueri
chat log n messag given two string array messag sender messagesi messag sent sendersi messag list word separ singl space lead trail space word count sender total number word sent sender note sender may send one messag return sender largest word count one sender largest word count return one lexicograph largest name note uppercas letter come lowercas letter lexicograph order alic alic distinct exampl 1 input messag hello usertwooohi userthreewond day alicenic day userthre sender aliceusertwouserthreealic output alic explan alic send total 2 3 5 word usertwo send total 2 word userthre send total 3 word sinc alic largest word count return alic exampl 2 input messag leetcod everyoneleetcod use practic sender bobcharli output charli explan bob send total 5 word charli send total 5 word sinc tie largest word count return sender lexicograph larger name charli constraint n messageslength senderslength 1 n 104 1 messagesilength 100 1 sendersilength 10 messagesi consist uppercas lowercas english letter word messagesi separ singl space messagesi lead trail space sendersi consist uppercas lowercas english letter senderwithlargestwordcount
binari tree univalu everi node tree valu given root binari tree return true given tree univalu fals otherwis exampl 1 input root 11111null1 output true exampl 2 input root 22252 output fals constraint number node tree rang 1 100 0 nodev 100 univaluedbinarytre
given 2d integ array grid size x n cell contain posit integ corner path defin set adjac cell one turn specif path exclus move either horizont vertic turn one without return previous visit cell turn path move exclus altern direct move vertic move horizont vice versa also without return previous visit cell product path defin product valu path return maximum number trail zero product corner path found grid note horizont movement mean move either left right direct vertic movement mean move either direct exampl 1 input grid 231715320812027119462214091106227453 output 3 explan grid left show valid corner path product 15 20 6 1 10 18000 3 trail zero shown maximum trail zero product corner path grid middl corner path one turn grid right corner path requir return previous visit cell exampl 2 input grid 432761888 output 0 explan grid shown figur corner path grid result product trail zero constraint gridlength n gridilength 1 n 105 1 n 105 1 gridij 1000 maximumtrailingzerosinacorneredpath
day 1 one person discov secret given integ delay mean person share secret new person everi day start delay day discov secret also given integ forget mean person forget secret forget day discov person share secret day forgot day afterward given integ n return number peopl know secret end day n sinc answer may larg return modulo 109 7 exampl 1 input n 6 delay 2 forget 4 output 5 explan day 1 suppos first person name 1 person day 2 person know secret 1 person day 3 share secret new person b 2 peopl day 4 share secret new person c 3 peopl day 5 forget secret b share secret new person 3 peopl day 6 b share secret e c share secret f 5 peopl exampl 2 input n 4 delay 1 forget 3 output 6 explan day 1 first person name 1 person day 2 share secret b 2 peopl day 3 b share secret 2 new peopl c 4 peopl day 4 forget secret b c share secret 3 new peopl 6 peopl constraint 2 n 1000 1 delay forget n numberofpeopleawareofasecret
given 0index integ array num initi indic unmark allow make oper number time pick two differ unmark indic j 2 numsi numsj mark j return maximum possibl number mark indic num use oper number time exampl 1 input num 3524 output 2 explan first oper pick 2 j 1 oper allow 2 nums2 nums1 mark index 2 1 shown there valid oper answer 2 exampl 2 input num 9254 output 4 explan first oper pick 3 j 0 oper allow 2 nums3 nums0 mark index 3 0 second oper pick 1 j 2 oper allow 2 nums1 nums2 mark index 1 2 sinc oper answer 4 exampl 3 input num 768 output 0 explan valid oper answer 0 constraint 1 numslength 105 1 numsi 109 findthemaximumnumberofmarkedindic
sever consecut hous along street money insid also robber want steal money home refus steal adjac home capabl robber maximum amount money steal one hous hous rob given integ array num repres much money stash hous formal ith hous left numsi dollar also given integ k repres minimum number hous robber steal alway possibl steal least k hous return minimum capabl robber possibl way steal least k hous exampl 1 input num 2359 k 2 output 5 explan three way rob least 2 hous rob hous indic 0 2 capabl maxnums0 nums2 5 rob hous indic 0 3 capabl maxnums0 nums3 9 rob hous indic 1 3 capabl maxnums1 nums3 9 therefor return min5 9 9 5 exampl 2 input num 27931 k 2 output 2 explan 7 way rob hous way lead minimum capabl rob hous index 0 4 return maxnums0 nums4 2 constraint 1 numslength 105 1 numsi 109 1 k numslength 12 houserobberiv
given array word word consist lowercas english letter worda predecessor wordb insert exactli one letter anywher worda without chang order charact make equal wordb exampl abc predecessor abac cba predecessor bcad word chain sequenc word word1 word2 wordk k 1 word1 predecessor word2 word2 predecessor word3 singl word trivial word chain k 1 return length longest possibl word chain word chosen given list word exampl 1 input word abbabcabdabdca output 4 explan one longest word chain ababdabdca exampl 2 input word xbcpcxbcfxbcxbcpcxbc output 5 explan word put word chain xb xbc cxbc pcxbc pcxbcf exampl 3 input word abcddbqca output 1 explan trivial word chain abcd one longest word chain abcddbqca valid word chain order letter chang constraint 1 wordslength 1000 1 wordsilength 16 wordsi consist lowercas english letter longeststringchain
given root binari tree n node node uniqu assign valu 1 n also given integ startvalu repres valu start node differ integ destvalu repres valu destin node find shortest path start node end node gener stepbystep direct path string consist uppercas letter l r u letter indic specif direct l mean go node left child node r mean go node right child node u mean go node parent node return stepbystep direct shortest path node node exampl 1 input root 5123null64 startvalu 3 destvalu 6 output uurl explan shortest path 3 → 1 → 5 → 2 → 6 exampl 2 input root 21 startvalu 2 destvalu 1 output l explan shortest path 2 → 1 constraint number node tree n 2 n 105 1 nodev n valu tree uniqu 1 startvalu destvalu n startvalu destvalu stepbystepdirectionsfromabinarytreenodetoanoth
given head link list n node node list find valu next greater node node find valu first node next strictli larger valu return integ array answer answeri valu next greater node ith node 1index ith node next greater node set answeri 0 exampl 1 input head 215 output 550 exampl 2 input head 27435 output 70550 constraint number node list n 1 n 104 1 nodev 109 nextgreaternodeinlinkedlist
gold mine grid size x n cell mine integ repres amount gold cell 0 empti return maximum amount gold collect condit everi time locat cell collect gold cell posit walk one step left right cant visit cell never visit cell 0 gold start stop collect gold posit grid gold exampl 1 input grid 060587090 output 24 explan 060 587 090 path get maximum gold 9 8 7 exampl 2 input grid 1072063450309020 output 28 explan 107 206 345 030 9020 path get maximum gold 1 2 3 4 5 6 7 constraint gridlength n gridilength 1 n 15 0 gridij 100 25 cell contain gold pathwithmaximumgold
infrastructur n citi number road connect citi roadsi ai bi indic bidirect road citi ai bi network rank two differ citi defin total number directli connect road either citi road directli connect citi count maxim network rank infrastructur maximum network rank pair differ citi given integ n array road return maxim network rank entir infrastructur exampl 1 input n 4 road 01031213 output 4 explan network rank citi 0 1 4 4 road connect either 0 1 road 0 1 count exampl 2 input n 5 road 010312132324 output 5 explan 5 road connect citi 1 2 exampl 3 input n 8 road 011223245657 output 5 explan network rank 2 5 5 notic citi connect constraint 2 n 100 0 roadslength n n 1 2 roadsilength 2 0 ai bi n1 ai bi pair citi one road connect maximalnetworkrank
design data structur store string count abil return string minimum maximum count implement allon class allon initi object data structur incstr key increment count string key 1 key exist data structur insert count 1 decstr key decrement count string key 1 count key 0 decrement remov data structur guarante key exist data structur decrement getmaxkey return one key maxim count element exist return empti string getminkey return one key minimum count element exist return empti string note function must run o1 averag time complex exampl 1 input allon inc inc getmaxkey getminkey inc getmaxkey getminkey hello hello leet output null null null hello hello null hello leet explan allon allon new allon alloneinchello alloneinchello allonegetmaxkey return hello allonegetminkey return hello alloneincleet allonegetmaxkey return hello allonegetminkey return leet constraint 1 keylength 10 key consist lowercas english letter guarante call dec key exist data structur 5 104 call made inc dec getmaxkey getminkey alloonedatastructur
given array integ num sort nondecreas order find start end posit given target valu target found array return 1 1 must write algorithm olog n runtim complex exampl 1 input num 5778810 target 8 output 34 exampl 2 input num 5778810 target 6 output 11 exampl 3 input num target 0 output 11 constraint 0 numslength 105 109 numsi 109 num nondecreas array 109 target 109 findfirstandlastpositionofelementinsortedarray
given string return maximum number occurr substr follow rule number uniqu charact substr must less equal maxlett substr size must minsiz maxsiz inclus exampl 1 input aababcaab maxlett 2 minsiz 3 maxsiz 4 output 2 explan substr aab 2 occurr origin string satisfi condit 2 uniqu letter size 3 minsiz maxsiz exampl 2 input aaaa maxlett 1 minsiz 3 maxsiz 3 output 2 explan substr aaa occur 2 time string overlap constraint 1 slength 105 1 maxlett 26 1 minsiz maxsiz min26 slength consist lowercas english letter maximumnumberofoccurrencesofasubstr
integ x good rotat digit individu 180 degre get valid number differ x digit must rotat choos leav alon number valid digit remain digit rotat exampl 0 1 8 rotat 2 5 rotat case rotat differ direct word 2 5 get mirror 6 9 rotat rest number rotat number becom invalid given integ n return number good integ rang 1 n exampl 1 input n 10 output 4 explan four good number rang 1 10 2 5 6 9 note 1 10 good number sinc remain unchang rotat exampl 2 input n 1 output 0 exampl 3 input n 2 output 1 constraint 1 n 104 rotateddigit
design algorithm accept stream charact check suffix charact string given array string word exampl word abc xyz stream ad four charact one one x z algorithm detect suffix xyz charact axyz match xyz word implement streamcheck class streamcheckerstr word initi object string array word boolean querychar letter accept new charact stream return true nonempti suffix stream form word word exampl 1 input streamcheck queri queri queri queri queri queri queri queri queri queri queri queri cd f kl b c e f g h j k l output null fals fals fals true fals true fals fals fals fals fals true explan streamcheck streamcheck new streamcheckercd f kl streamcheckerquerya return fals streamcheckerqueryb return fals streamcheckerqueryc return fals streamcheckerqueryd return true cd wordlist streamcheckerquery return fals streamcheckerqueryf return true f wordlist streamcheckerqueryg return fals streamcheckerqueryh return fals streamcheckerqueryi return fals streamcheckerqueryj return fals streamcheckerqueryk return fals streamcheckerqueryl return true kl wordlist constraint 1 wordslength 2000 1 wordsilength 200 wordsi consist lowercas english letter letter lowercas english letter 4 104 call made queri streamofcharact
sql schema pandan schema tabl teacher column name type teacherid int subjectid int deptid int sql subjectid deptid primari key tabl row tabl indic teacher teacherid teach subject subjectid depart deptid calcul number uniqu subject teacher teach univers return result tabl order result format shown follow exampl exampl 1 input teacher tabl teacherid subjectid deptid 1 2 3 1 2 4 1 3 3 2 1 1 2 2 1 2 3 1 2 4 1 output teacherid cnt 1 2 2 4 explan teacher 1 teach subject 2 depart 3 4 teach subject 3 depart 3 teacher 2 teach subject 1 depart 1 teach subject 2 depart 1 teach subject 3 depart 1 teach subject 4 depart 1 numberofuniquesubjectstaughtbyeachteach
array num length n beauti num permut integ rang 1 n everi 0 j n index k k j 2 numsk numsi numsj given integ n return beauti array num length n least one valid answer given n exampl 1 input n 4 output 2143 exampl 2 input n 5 output 31254 constraint 1 n 1000 beautifularray
given integ n indic number peopl network person label 0 n 1 also given 0index 2d integ array restrict restrictionsi xi yi mean person xi person yi becom friend either directli indirectli peopl initi one friend given list friend request 0index 2d integ array request requestsj uj vj friend request person uj person vj friend request success uj vj friend friend request process given order ie requestsj occur requestsj 1 upon success request uj vj becom direct friend futur friend request return boolean array result resultj true jth friend request success fals note uj vj alreadi direct friend request still success exampl 1 input n 3 restrict 01 request 0221 output truefals explan request 0 person 0 person 2 friend becom direct friend request 1 person 2 person 1 friend sinc person 0 person 1 would indirect friend 120 exampl 2 input n 3 restrict 01 request 1202 output truefals explan request 0 person 1 person 2 friend becom direct friend request 1 person 0 person 2 friend sinc person 0 person 1 would indirect friend 021 exampl 3 input n 5 restrict 011223 request 04123134 output truefalsetruefals explan request 0 person 0 person 4 friend becom direct friend request 1 person 1 person 2 friend sinc directli restrict request 2 person 3 person 1 friend becom direct friend request 3 person 3 person 4 friend sinc person 0 person 1 would indirect friend 0431 constraint 2 n 1000 0 restrictionslength 1000 restrictionsilength 2 0 xi yi n 1 xi yi 1 requestslength 1000 requestsjlength 2 0 uj vj n 1 uj vj processrestrictedfriendrequest
given string integ k return maximum number vowel letter substr length k vowel letter english e u exampl 1 input abciiidef k 3 output 3 explan substr iii contain 3 vowel letter exampl 2 input aeiou k 2 output 2 explan substr length 2 contain 2 vowel exampl 3 input leetcod k 3 output 2 explan lee eet ode contain 2 vowel constraint 1 slength 105 consist lowercas english letter 1 k slength maximumnumberofvowelsinasubstringofgivenlength
given n point 1d plane ith point 0 n1 x find number way draw exactli k nonoverlap line segment segment cover two point endpoint segment must integr coordin k line segment cover n point allow share endpoint return number way draw k nonoverlap line segment sinc number huge return modulo 109 7 exampl 1 input n 4 k 2 output 5 explan two line segment shown red blue imag show 5 differ way 0223 0113 0123 1223 0112 exampl 2 input n 3 k 1 output 3 explan 3 way 01 02 12 exampl 3 input n 30 k 7 output 796297179 explan total number possibl way draw 7 line segment 3796297200 take number modulo 109 7 give us 796297179 constraint 2 n 1000 1 k n1 numberofsetsofknonoverlappinglineseg
given binari string without lead zero return true contain one contigu segment one otherwis return fals exampl 1 input 1001 output fals explan one form contigu segment exampl 2 input 110 output true constraint 1 slength 100 si either 0 1 s0 1 checkifbinarystringhasatmostonesegmentofon
write function argumentslength return count argument pass exampl 1 input argsarr 5 output 1 explan argumentslength5 1 one valu pass function return 1 exampl 2 input argsarr null 3 output 3 explan argumentslength null 3 3 three valu pass function return 3 constraint argsarr valid json array 0 argsarrlength 100 returnlengthofargumentspass
string consid beauti satisfi follow condit 5 english vowel e u must appear least letter must sort alphabet order ie es es etc exampl string aeiou aaaaaaeiiiioou consid beauti uaeio aeoiu aaaeeeooo beauti given string word consist english vowel return length longest beauti substr word substr exist return 0 substr contigu sequenc charact string exampl 1 input word aeiaaioaaaaeiiiiouuuooaauuaeiu output 13 explan longest beauti substr word aaaaeiiiiouuu length 13 exampl 2 input word aeeeiiiioooauuuaeiou output 5 explan longest beauti substr word aeiou length 5 exampl 3 input word output 0 explan beauti substr return 0 constraint 1 wordlength 5 105 word consist charact e u longestsubstringofallvowelsinord
n kid candi given integ array candi candiesi repres number candi ith kid integ extracandi denot number extra candi return boolean array result length n resulti true give ith kid extracandi greatest number candi among kid fals otherwis note multipl kid greatest number candi exampl 1 input candi 23513 extracandi 3 output truetruetruefalsetru explan give extracandi kid 1 2 3 5 candi greatest among kid kid 2 3 3 6 candi greatest among kid kid 3 5 3 8 candi greatest among kid kid 4 1 3 4 candi greatest among kid kid 5 3 3 6 candi greatest among kid exampl 2 input candi 42112 extracandi 1 output truefalsefalsefalsefals explan 1 extra candi kid 1 alway greatest number candi even differ kid given extra candi exampl 3 input candi 12112 extracandi 10 output truefalsetru constraint n candieslength 2 n 100 1 candiesi 100 1 extracandi 50 kidswiththegreatestnumberofcandi
total numcours cours take label 0 numcours 1 given array prerequisit prerequisitesi ai bi indic must take cours bi first want take cours ai exampl pair 0 1 indic take cours 0 first take cours 1 return true finish cours otherwis return fals exampl 1 input numcours 2 prerequisit 10 output true explan total 2 cours take take cours 1 finish cours 0 possibl exampl 2 input numcours 2 prerequisit 1001 output fals explan total 2 cours take take cours 1 finish cours 0 take cours 0 also finish cours 1 imposs constraint 1 numcours 2000 0 prerequisiteslength 5000 prerequisitesilength 2 0 ai bi numcours pair prerequisitesi uniqu courseschedul
given array path pathsi cityai citybi mean exist direct path go cityai citybi return destin citi citi without path outgo anoth citi guarante graph path form line without loop therefor exactli one destin citi exampl 1 input path londonnew yorknew yorklimalimasao paulo output sao paulo explan start london citi reach sao paulo citi destin citi trip consist london new york lima sao paulo exampl 2 input path bcdbca output explan possibl trip b c b c c clearli destin citi exampl 3 input path az output z constraint 1 pathslength 100 pathsilength 2 1 cityailength citybilength 10 cityai citybi string consist lowercas uppercas english letter space charact destinationc
given integ array deck decki repres number written ith card partit card one group group exactli x card x 1 card one group integ written return true partit possibl fals otherwis exampl 1 input deck 12344321 output true explan possibl partit 11223344 exampl 2 input deck 11122233 output fals explan possibl partit constraint 1 decklength 104 0 decki 104 xofakindinadeckofcard
design text editor cursor follow add text cursor delet text cursor simul backspac key move cursor either left right delet text charact left cursor delet cursor also remain within actual text move beyond formal 0 cursorposit currenttextlength alway hold implement texteditor class texteditor initi object empti text void addtextstr text append text cursor cursor end right text int deletetextint k delet k charact left cursor return number charact actual delet string cursorleftint k move cursor left k time return last min10 len charact left cursor len number charact left cursor string cursorrightint k move cursor right k time return last min10 len charact left cursor len number charact left cursor exampl 1 input texteditor addtext deletetext addtext cursorright cursorleft deletetext cursorleft cursorright leetcod 4 practic 3 8 10 2 6 output null null 4 null etpractic leet 4 practi explan texteditor texteditor new texteditor current text charact repres cursor texteditoraddtextleetcod current text leetcod texteditordeletetext4 return 4 current text leet 4 charact delet texteditoraddtextpractic current text leetpractic texteditorcursorright3 return etpractic current text leetpractic cursor move beyond actual text thu move etpractic last 10 charact left cursor texteditorcursorleft8 return leet current text leetpractic leet last min10 4 4 charact left cursor texteditordeletetext10 return 4 current text practic 4 charact delet texteditorcursorleft2 return current text practic cursor move beyond actual text thu move last min10 0 0 charact left cursor texteditorcursorright6 return practi current text practic practi last min10 6 6 charact left cursor constraint 1 textlength k 40 text consist lowercas english letter 2 104 call total made addtext deletetext cursorleft cursorright followup could find solut time complex ok per call designatexteditor
write gener function return gener object yield fibonacci sequenc fibonacci sequenc defin relat xn xn1 xn2 first number seri 0 1 1 2 3 5 8 13 exampl 1 input callcount 5 output 01123 explan const gen fibgener gennextvalu 0 gennextvalu 1 gennextvalu 1 gennextvalu 2 gennextvalu 3 exampl 2 input callcount 0 output explan gennext never call noth output constraint 0 callcount 50 generatefibonaccisequ
given n x n integ matrix grid return minimum sum fall path nonzero shift fall path nonzero shift choic exactli one element row grid two element chosen adjac row column exampl 1 input grid 123456789 output 13 explan possibl fall path 159 157 167 168 248 249 267 268 348 349 357 359 fall path smallest sum 157 answer 13 exampl 2 input grid 7 output 7 constraint n gridlength gridilength 1 n 200 99 gridij 99 minimumfallingpathsumii
given integ array arr filter function fn return filter array filteredarr fn function take one two argument arri number arr index arri filteredarr contain element arr express fnarri evalu truthi valu truthi valu valu booleanvalu return true pleas solv without builtin arrayfilt method exampl 1 input arr 0102030 fn function greaterthan10n return n 10 output 2030 explan const newarray filterarr fn 20 30 function filter valu greater 10 exampl 2 input arr 123 fn function firstindexn return 0 output 1 explan fn also accept index element case function remov element index 0 exampl 3 input arr 21012 fn function plusonen return n 1 output 2012 explan falsey valu 0 filter constraint 0 arrlength 1000 109 arri 109 filterelementsfromarray
matrix diagon diagon line cell start cell either topmost row leftmost column go bottomright direct reach matrix end exampl matrix diagon start mat20 mat 6 x 3 matrix includ cell mat20 mat31 mat42 given x n matrix mat integ sort matrix diagon ascend order return result matrix exampl 1 input mat 331122121112 output 111112221233 exampl 2 input mat 1125661697235517451552753136445882227332568484281411550 output 5174152711112545869142325445815222731365066842875335568 constraint matlength n matilength 1 n 100 1 matij 100 sortthematrixdiagon
alic bob differ total number candi given two integ array alices bobsiz alicesizesi number candi ith box candi alic bobsizesj number candi jth box candi bob sinc friend would like exchang one candi box exchang total amount candi total amount candi person sum number candi box return integ array answer answer0 number candi box alic must exchang answer1 number candi box bob must exchang multipl answer may return one guarante least one answer exist exampl 1 input alices 11 bobsiz 22 output 12 exampl 2 input alices 12 bobsiz 23 output 12 exampl 3 input alices 2 bobsiz 13 output 23 constraint 1 alicesizeslength bobsizeslength 104 1 alicesizesi bobsizesj 105 alic bob differ total number candi least one valid answer given input faircandyswap
given root full binari tree follow properti leaf node either valu 0 1 0 repres fals 1 repres true nonleaf node either valu 2 3 2 repres boolean 3 repres boolean evalu node follow node leaf node evalu valu node ie true fals otherwis evalu node two children appli boolean oper valu children evalu return boolean result evalu root node full binari tree binari tree node either 0 2 children leaf node node zero children exampl 1 input root 213nullnull01 output true explan diagram illustr evalu process node evalu fals true fals node evalu true fals true root node evalu true return true exampl 2 input root 0 output fals explan root node leaf node evalu fals return fals constraint number node tree rang 1 1000 0 nodev 3 everi node either 0 2 children leaf node valu 0 1 nonleaf node valu 2 3 evaluatebooleanbinarytre
given 0index integ array num also given integ key present num everi uniqu integ target num count number time target immedi follow occurr key num word count number indic 0 numslength 2 numsi key numsi 1 target return target maximum count test case gener target maximum count uniqu exampl 1 input num 11002001100 key 1 output 100 explan target 100 2 occurr indic 1 4 follow occurr key integ follow occurr key return 100 exampl 2 input num 22223 key 2 output 2 explan target 2 3 occurr indic 1 2 3 follow occurr key target 3 one occurr index 4 follow occurr key target 2 maximum number occurr follow occurr key return 2 constraint 2 numslength 1000 1 numsi 1000 test case gener answer uniqu mostfrequentnumberfollowingkeyinanarray
given string return number differ nonempti palindrom subsequ sinc answer may larg return modulo 109 7 subsequ string obtain delet zero charact string sequenc palindrom equal sequenc revers two sequenc a1 a2 b1 b2 differ ai bi exampl 1 input bccb output 6 explan 6 differ nonempti palindrom subsequ b c bb cc bcb bccb note bcb count even though occur twice exampl 2 input abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba output 104860361 explan 3104860382 differ nonempti palindrom subsequ 104860361 modulo 109 7 constraint 1 slength 1000 si either b c countdifferentpalindromicsubsequ
two string say divid ie concaten one time given two string str1 str2 return largest string x x divid str1 str2 exampl 1 input str1 abcabc str2 abc output abc exampl 2 input str1 ababab str2 abab output ab exampl 3 input str1 leet str2 code output constraint 1 str1length str2length 1000 str1 str2 consist english uppercas letter greatestcommondivisorofstr
given integ array price repres daili price histori stock pricesi stock price ith day smooth descent period stock consist one contigu day price day lower price preced day exactli 1 first day period exempt rule return number smooth descent period exampl 1 input price 3214 output 7 explan 7 smooth descent period 3 2 1 4 32 21 321 note period one day smooth descent period definit exampl 2 input price 8677 output 4 explan 4 smooth descent period 8 6 7 7 note 86 smooth descent period 8 6 ≠ 1 exampl 3 input price 1 output 1 explan 1 smooth descent period 1 constraint 1 priceslength 105 1 pricesi 105 numberofsmoothdescentperiodsofastock
given head head link list determin link list cycl cycl link list node list reach continu follow next pointer intern po use denot index node tail next pointer connect note po pass paramet return true cycl link list otherwis return fals exampl 1 input head 3204 po 1 output true explan cycl link list tail connect 1st node 0index exampl 2 input head 12 po 0 output true explan cycl link list tail connect 0th node exampl 3 input head 1 po 1 output fals explan cycl link list constraint number node list rang 0 104 105 nodev 105 po 1 valid index linkedlist follow solv use o1 ie constant memori linkedlistcycl
valid cut circl cut repres straight line touch two point edg circl pass center cut repres straight line touch one point edg circl center valid invalid cut shown figur given integ n return minimum number cut need divid circl n equal slice exampl 1 input n 4 output 2 explan figur show cut circl twice middl divid 4 equal slice exampl 2 input n 3 output 3 explan least 3 cut need divid circl 3 equal slice shown less 3 cut result 3 slice equal size shape also note first cut divid circl distinct part constraint 1 n 100 minimumcutstodivideacircl
given binari string allow perform two type oper string sequenc type1 remov charact start string append end string type2 pick charact flip valu ie valu 0 becom 1 viceversa return minimum number type2 oper need perform becom altern string call altern two adjac charact equal exampl string 010 1010 altern string 0100 exampl 1 input 111000 output 2 explan use first oper two time make 100011 use second oper third sixth element make 101010 exampl 2 input 010 output 0 explan string alreadi altern exampl 3 input 1110 output 1 explan use second oper second element make 1010 constraint 1 slength 105 si either 0 1 minimumnumberofflipstomakethebinarystringaltern
long tabl line plate candl arrang top given 0index string consist charact repres plate repres candl also given 0index 2d integ array queri queriesi lefti righti denot substr sleftirighti inclus queri need find number plate candl substr plate consid candl least one candl left least one candl right substr exampl queri 3 8 denot substr number plate candl substr 2 two plate least one candl substr left right return integ array answer answeri answer ith queri exampl 1 input queri 2559 output 23 explan queries0 two plate candl queries1 three plate candl exampl 2 input queri 1174514175111516 output 90000 explan queries0 nine plate candl queri zero plate candl constraint 3 slength 105 consist charact 1 querieslength 105 queriesilength 2 0 lefti righti slength platesbetweencandl
set integ origin contain number 1 n unfortun due error one number got duplic anoth number set result repetit one number loss anoth number given integ array num repres data statu set error find number occur twice number miss return form array exampl 1 input num 1224 output 23 exampl 2 input num 11 output 12 constraint 2 numslength 104 1 numsi 104 setmismatch
given 0index integ array num one oper replac element array two element sum exampl consid num 567 one oper replac nums1 2 4 convert num 5247 return minimum number oper make array sort nondecreas order exampl 1 input num 393 output 2 explan step sort array nondecreas order 393 replac 9 3 6 array becom 3363 3363 replac 6 3 3 array becom 33333 2 step sort array nondecreas order therefor return 2 exampl 2 input num 12345 output 0 explan array alreadi nondecreas order therefor return 0 constraint 1 numslength 105 1 numsi 109 minimumreplacementstosortthearray
phrase palindrom convert uppercas letter lowercas letter remov nonalphanumer charact read forward backward alphanumer charact includ letter number given string return true palindrom fals otherwis exampl 1 input man plan canal panama output true explan amanaplanacanalpanama palindrom exampl 2 input race car output fals explan raceacar palindrom exampl 3 input output true explan empti string remov nonalphanumer charact sinc empti string read forward backward palindrom constraint 1 slength 2 105 consist printabl ascii charact validpalindrom
given two integ array nums1 nums2 sort nondecreas order integ k defin pair u v consist one element first array one element second array return k pair u1 v1 u2 v2 uk vk smallest sum exampl 1 input nums1 1711 nums2 246 k 3 output 121416 explan first 3 pair return sequenc 121416727411276114116 exampl 2 input nums1 112 nums2 123 k 2 output 1111 explan first 2 pair return sequenc 111112211222131323 exampl 3 input nums1 12 nums2 3 k 3 output 1323 explan possibl pair return sequenc 1323 constraint 1 nums1length nums2length 105 109 nums1i nums2i 109 nums1 nums2 sort nondecreas order 1 k 104 findkpairswithsmallestsum
given string contain lowercas letter integ k need first chang charact lowercas english letter divid k nonempti disjoint substr substr palindrom return minim number charact need chang divid string exampl 1 input abc k 2 output 1 explan split string ab c chang 1 charact ab make palindrom exampl 2 input aabbc k 3 output 0 explan split string aa bb c palindrom exampl 3 input leetcod k 8 output 0 constraint 1 k slength 100 contain lowercas english letter palindromepartitioningiii
sentenc list word separ singl space lead trail space word consist lowercas uppercas english letter sentenc shuffl append 1index word posit word rearrang word sentenc exampl sentenc sentenc shuffl sentence4 a3 is2 this1 is2 sentence4 this1 a3 given shuffl sentenc contain 9 word reconstruct return origin sentenc exampl 1 input is2 sentence4 this1 a3 output sentenc explan sort word origin posit this1 is2 a3 sentence4 remov number exampl 2 input myself2 me1 i4 and3 output explan sort word origin posit me1 myself2 and3 i4 remov number constraint 2 slength 200 consist lowercas uppercas english letter space digit 1 9 number word 1 9 word separ singl space contain lead trail space sortingthesent
given n bst binari search tree root node n separ bst store array tree 0index bst tree 3 node two root valu one oper select two distinct indic j valu store one leav treesi equal root valu treesj replac leaf node treesi treesj remov treesj tree return root result bst possibl form valid bst perform n 1 oper null imposs creat valid bst bst binari search tree binari tree node satisfi follow properti everi node node left subtre valu strictli less node valu everi node node right subtre valu strictli greater node valu leaf node children exampl 1 input tree 2132554 output 3251null4 explan first oper pick i1 j0 merg trees0 trees1 delet trees0 tree 325154 second oper pick i0 j1 merg trees1 trees0 delet trees1 tree 3251null4 result tree shown valid bst return root exampl 2 input tree 538326 output explan pick i0 j1 merg trees1 trees0 delet trees1 tree 53826 result tree shown valid oper perform result tree valid bst return null exampl 3 input tree 543 output explan imposs perform oper constraint n treeslength 1 n 5 104 number node tree rang 1 3 node input may children grandchildren two root tree valu tree input valid bst 1 treenodev 5 104 mergebststocreatesinglebst
given integ array num consist 2 n integ need divid num n pair element belong exactli one pair element present pair equal return true num divid n pair otherwis return fals exampl 1 input num 323222 output true explan 6 element num divid 6 2 3 pair num divid pair 2 2 3 3 2 2 satisfi condit exampl 2 input num 1234 output fals explan way divid num 4 2 2 pair pair satisfi everi condit constraint numslength 2 n 1 n 500 1 numsi 500 dividearrayintoequalpair
given 0index array num consisit posit integ follow oper array number time select index 0 n 1 replac either numsi numsi1 gcd valu return minimum number oper make element num equal 1 imposs return 1 gcd two integ greatest common divisor two integ exampl 1 input num 2634 output 4 explan follow oper choos index 2 replac nums2 gcd34 1 num 2614 choos index 1 replac nums1 gcd61 1 num 2114 choos index 0 replac nums0 gcd21 1 num 1114 choos index 2 replac nums3 gcd14 1 num 1111 exampl 2 input num 210614 output 1 explan shown imposs make element equal 1 constraint 2 numslength 50 1 numsi 106 followup time complex solut work could find o1 constant time complex solut minimumnumberofoperationstomakeallarrayelementsequalto1
return number permut 1 n prime number prime indic 1index recal integ prime greater 1 written product two posit integ smaller sinc answer may larg return answer modulo 109 7 exampl 1 input n 5 output 12 explan exampl 12543 valid permut 52341 prime number 5 index 1 exampl 2 input n 100 output 682289015 constraint 1 n 100 primearrang
given array book booksi thicknessi heighti indic thick height ith book also given integ shelfwidth want place book order onto bookcas shelv total width shelfwidth choos book place shelf sum thick less equal shelfwidth build anoth level shelf bookcas total height bookcas increas maximum height book put repeat process book place note step process order book place order given sequenc book exampl order list 5 book might place first second book onto first shelf third book second shelf fourth fifth book last shelf return minimum possibl height total bookshelf place shelv manner exampl 1 input book 11232311111112 shelfwidth 4 output 6 explan sum height 3 shelv 1 3 2 6 notic book number 2 first shelf exampl 2 input book 132432 shelfwidth 6 output 4 constraint 1 bookslength 1000 1 thicknessi shelfwidth 1000 1 heighti 1000 fillingbookcaseshelv
design implement link list choos use singli doubli link list node singli link list two attribut val next val valu current node next pointerrefer next node want use doubli link list need one attribut prev indic previou node link list assum node link list 0index implement mylinkedlist class mylinkedlist initi mylinkedlist object int getint index get valu indexth node link list index invalid return 1 void addatheadint val add node valu val first element link list insert new node first node link list void addattailint val append node valu val last element link list void addatindexint index int val add node valu val indexth node link list index equal length link list node append end link list index greater length node insert void deleteatindexint index delet indexth node link list index valid exampl 1 input mylinkedlist addathead addattail addatindex get deleteatindex get 1 3 1 2 1 1 1 output null null null null 2 null 3 explan mylinkedlist mylinkedlist new mylinkedlist mylinkedlistaddathead1 mylinkedlistaddattail3 mylinkedlistaddatindex1 2 link list becom 123 mylinkedlistget1 return 2 mylinkedlistdeleteatindex1 link list 13 mylinkedlistget1 return 3 constraint 0 index val 1000 pleas use builtin linkedlist librari 2000 call made get addathead addattail addatindex deleteatindex designlinkedlist
numer valu lowercas charact defin posit 1index alphabet numer valu 1 numer valu b 2 numer valu c 3 numer valu string consist lowercas charact defin sum charact numer valu exampl numer valu string abe equal 1 2 5 8 given two integ n k return lexicograph smallest string length equal n numer valu equal k note string x lexicograph smaller string x come dictionari order either x prefix first posit xi yi xi come yi alphabet order exampl 1 input n 3 k 27 output aay explan numer valu string 1 1 25 27 smallest string valu length equal 3 exampl 2 input n 5 k 73 output aaszz constraint 1 n 105 n k 26 n smalleststringwithagivennumericvalu
given undirect graph given integ n number node graph array edg edgesi ui vi indic undirect edg ui vi connect trio set three node edg everi pair degre connect trio number edg one endpoint trio return minimum degre connect trio graph 1 graph connect trio exampl 1 input n 6 edg 121332415236 output 3 explan exactli one trio 123 edg form degre bold figur exampl 2 input n 7 edg 1341432556677526 output 0 explan exactli three trio 1 143 degre 0 2 256 degre 2 3 567 degre 2 constraint 2 n 400 edgesilength 2 1 edgeslength n n1 2 1 ui vi n ui vi repeat edg minimumdegreeofaconnectedtrioinagraph
permut array integ arrang member sequenc linear order exampl arr 123 follow permut arr 123 132 2 1 3 2 3 1 312 321 next permut array integ next lexicograph greater permut integ formal permut array sort one contain accord lexicograph order next permut array permut follow sort contain arrang possibl array must rearrang lowest possibl order ie sort ascend order exampl next permut arr 123 132 similarli next permut arr 231 312 next permut arr 321 123 321 lexicograph larger rearrang given array integ num find next permut num replac must place use constant extra memori exampl 1 input num 123 output 132 exampl 2 input num 321 output 123 exampl 3 input num 115 output 151 constraint 1 numslength 100 0 numsi 100 nextpermut
comput run unlimit number task time given 2d integ array task tasksi starti endi durationi indic ith task run total durationi second necessarili continu within inclus time rang starti endi may turn comput need run task also turn idl return minimum time comput turn complet task exampl 1 input task 231451152 output 2 explan first task run inclus time rang 2 2 second task run inclus time rang 5 5 third task run two inclus time rang 2 2 5 5 comput total 2 second exampl 2 input task 132253562 output 4 explan first task run inclus time rang 2 3 second task run inclus time rang 2 3 5 5 third task run two inclus time rang 5 6 comput total 4 second constraint 1 taskslength 2000 tasksilength 3 1 starti endi 2000 1 durationi endi starti 1 minimumtimetocompletealltask
n citi number 1 n given array edg size n1 edgesi ui vi repres bidirect edg citi ui vi exist uniqu path pair citi word citi form tree subtre subset citi everi citi reachabl everi citi subset path pair pass citi subset two subtre differ citi one subtre present 1 n1 find number subtre maximum distanc two citi subtre equal return array size n1 dth element 1index number subtre maximum distanc two citi equal notic distanc two citi number edg path exampl 1 input n 4 edg 122324 output 340 explan subtre subset 12 23 24 max distanc 1 subtre subset 123 124 234 1234 max distanc 2 subtre two node max distanc 3 exampl 2 input n 2 edg 12 output 1 exampl 3 input n 3 edg 1223 output 21 constraint 2 n 15 edgeslength n1 edgesilength 2 1 ui vi n pair ui vi distinct countsubtreeswithmaxdistancebetweenc
given two string array words1 words2 return number string appear exactli two array exampl 1 input words1 leetcodeisamazingasi words2 amazingleetcodei output 2 explan leetcod appear exactli two array count string amaz appear exactli two array count string appear two array 2 occurr words1 count string appear words1 appear words2 count string thu 2 string appear exactli two array exampl 2 input words1 bbbbbb words2 aaaaaa output 0 explan string appear two array exampl 3 input words1 aab words2 aaaab output 1 explan string appear exactli two array ab constraint 1 words1length words2length 1000 1 words1ilength words2jlength 30 words1i words2j consist lowercas english letter countcommonwordswithoneoccurr
sql schema pandan schema tabl employe column name type id int name varchar sql id primari key tabl row tabl contain id name employe compani tabl employeeuni column name type id int uniqueid int sql id uniqueid primari key tabl row tabl contain id correspond uniqu id employe compani show uniqu id user user uniqu id replac show null return result tabl order result format follow exampl exampl 1 input employe tabl id name 1 alic 7 bob 11 meir 90 winston 3 jonathan employeeuni tabl id uniqueid 3 1 11 2 90 3 output uniqueid name null alic null bob 2 meir 3 winston 1 jonathan explan alic bob uniqu id show null instead uniqu id meir 2 uniqu id winston 3 uniqu id jonathan 1 replaceemployeeidwiththeuniqueidentifi
given integ array num integ k return true two distinct indic j array numsi numsj absi j k exampl 1 input num 1231 k 3 output true exampl 2 input num 1011 k 1 output true exampl 3 input num 123123 k 2 output fals constraint 1 numslength 105 109 numsi 109 0 k 105 containsduplicateii
given n x n binari grid one step choos two adjac row grid swap grid said valid cell main diagon zero return minimum number step need make grid valid 1 grid valid main diagon grid diagon start cell 1 1 end cell n n exampl 1 input grid 001110100 output 3 exampl 2 input grid 0110011001100110 output 1 explan row similar swap effect grid exampl 3 input grid 100110111 output 0 constraint n gridlength gridilength 1 n 200 gridij either 0 1 minimumswapstoarrangeabinarygrid
grammar given string repres set lowercas word let rexpr denot set word express repres grammar best understood simpl exampl singl letter repres singleton set contain word ra rw w take commadelimit list two express take union possibl rabc abc rabbc abc notic final set contain word concaten two express take set possibl concaten two word first word come first express second word come second express rabcd acadbcbd rabcdefgh abdfg abdfh abefg abefh acdfg acdfh acefg acefh formal three rule grammar everi lowercas letter x rx x express e1 e2 ek k 2 re1 e2 re1 ∪ re2 ∪ express e1 e2 re1 e2 b b re1 × re2 denot concaten × denot cartesian product given express repres set word given grammar return sort list word express repres exampl 1 input express abcd output acadaebcbdb exampl 2 input express azabcabz output aabacz explan distinct word written final answer constraint 1 expressionlength 60 expressioni consist lowercas english letter given express repres set word base grammar given descript braceexpansionii
fruit avail posit infinit xaxi given 2d integ array fruit fruitsi positioni amounti depict amounti fruit posit positioni fruit alreadi sort positioni ascend order positioni uniqu also given integ startpo integ k initi posit startpo posit either walk left right take one step move one unit xaxi walk k step total everi posit reach harvest fruit posit fruit disappear posit return maximum total number fruit harvest exampl 1 input fruit 286386 startpo 5 k 4 output 9 explan optim way move right posit 6 harvest 3 fruit move right posit 8 harvest 6 fruit move 3 step harvest 3 6 9 fruit total exampl 2 input fruit 0941576274109 startpo 5 k 4 output 14 explan move k 4 step reach posit 0 10 optim way harvest 7 fruit start posit 5 move left posit 4 harvest 1 fruit move right posit 6 harvest 2 fruit move right posit 7 harvest 4 fruit move 1 3 4 step harvest 7 1 2 4 14 fruit total exampl 3 input fruit 036485 startpo 3 k 2 output 0 explan move k 2 step reach posit fruit constraint 1 fruitslength 105 fruitsilength 2 0 startpo positioni 2 105 positioni1 positioni 0 0index 1 amounti 104 0 k 2 105 maximumfruitsharvestedafteratmostkstep
given integ array num integ k return kth largest element array note kth largest element sort order kth distinct element solv without sort exampl 1 input num 321564 k 2 output 5 exampl 2 input num 323124556 k 4 output 4 constraint 1 k numslength 105 104 numsi 104 kthlargestelementinanarray
given root binari tree integ targetsum return number path sum valu along path equal targetsum path need start end root leaf must go downward ie travel parent node child node exampl 1 input root 105332null1132null1 targetsum 8 output 3 explan path sum 8 shown exampl 2 input root 54811null13472nullnull51 targetsum 22 output 3 constraint number node tree rang 0 1000 109 nodev 109 1000 targetsum 1000 pathsumiii
given two string return number distinct subsequ equal test case gener answer fit 32bit sign integ exampl 1 input rabbbit rabbit output 3 explan shown 3 way gener rabbit rabbbit rabbbit rabbbit exampl 2 input babgbag bag output 5 explan shown 5 way gener bag babgbag babgbag babgbag babgbag babgbag constraint 1 slength tlength 1000 consist english letter distinctsubsequ
given string key messag repres cipher key secret messag respect step decod messag follow use first appear 26 lowercas english letter key order substitut tabl align substitut tabl regular english alphabet letter messag substitut use tabl space transform exampl given key happi boy actual key would least one instanc letter alphabet partial substitut tabl h b p c b e f return decod messag exampl 1 input key quick brown fox jump lazi dog messag vkb bs suepuv output secret explan diagram show substitut tabl obtain take first appear letter quick brown fox jump lazi dog exampl 2 input key eljuxhpwnyrdgtqkviszcfmabo messag zwx hnfx lqantp mnoeiu ycgk vcnjrdb output five box wizard jump quickli explan diagram show substitut tabl obtain take first appear letter eljuxhpwnyrdgtqkviszcfmabo constraint 26 keylength 2000 key consist lowercas english letter key contain everi letter english alphabet z least 1 messagelength 2000 messag consist lowercas english letter decodethemessag
implement randomizedset class randomizedset initi randomizedset object bool insertint val insert item val set present return true item present fals otherwis bool removeint val remov item val set present return true item present fals otherwis int getrandom return random element current set element guarante least one element exist method call element must probabl return must implement function class function work averag o1 time complex exampl 1 input randomizedset insert remov insert getrandom remov insert getrandom 1 2 2 1 2 output null true fals true 2 true fals 2 explan randomizedset randomizedset new randomizedset randomizedsetinsert1 insert 1 set return true 1 insert success randomizedsetremove2 return fals 2 exist set randomizedsetinsert2 insert 2 set return true set contain 12 randomizedsetgetrandom getrandom return either 1 2 randomli randomizedsetremove1 remov 1 set return true set contain 2 randomizedsetinsert2 2 alreadi set return fals randomizedsetgetrandom sinc 2 number set getrandom alway return 2 constraint 231 val 231 1 2 105 call made insert remov getrandom least one element data structur getrandom call insertdeletegetrandomo1
undirect tree n node label 0 n 1 n 1 edg given 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree also given integ array restrict repres restrict node return maximum number node reach node 0 without visit restrict node note node 0 restrict node exampl 1 input n 7 edg 011231400556 restrict 45 output 4 explan diagram show tree 0123 node reach node 0 without visit restrict node exampl 2 input n 7 edg 010205043265 restrict 421 output 3 explan diagram show tree 056 node reach node 0 without visit restrict node constraint 2 n 105 edgeslength n 1 edgesilength 2 0 ai bi n ai bi edg repres valid tree 1 restrictedlength n 1 restrictedi n valu restrict uniqu reachablenodeswithrestrict
given binari string return true longest contigu segment 1s strictli longer longest contigu segment 0s return fals otherwis exampl 110100010 longest continu segment 1s length 2 longest continu segment 0s length 3 note 0s longest continu segment 0s consid length 0 appli 1s exampl 1 input 1101 output true explan longest contigu segment 1s length 2 1101 longest contigu segment 0s length 1 1101 segment 1s longer return true exampl 2 input 111000 output fals explan longest contigu segment 1s length 3 111000 longest contigu segment 0s length 3 111000 segment 1s longer return fals exampl 3 input 110100010 output fals explan longest contigu segment 1s length 2 110100010 longest contigu segment 0s length 3 110100010 segment 1s longer return fals constraint 1 slength 100 si either 0 1 longercontiguoussegmentsofonesthanzero
given integ array num integ k one oper choos index 0 numslength chang numsi numsi x x integ rang k k appli oper index score num differ maximum minimum element num return minimum score num appli mention oper index exampl 1 input num 1 k 0 output 0 explan score maxnum minnum 1 1 0 exampl 2 input num 010 k 2 output 6 explan chang num 2 8 score maxnum minnum 8 2 6 exampl 3 input num 136 k 3 output 0 explan chang num 4 4 4 score maxnum minnum 4 4 0 constraint 1 numslength 104 0 numsi 104 0 k 104 smallestrangei
given 0index integ array num integ k task perform follow oper exactli k time order maxim score select element num remov select element array add new element valu 1 array increas score return maximum score achiev perform oper exactli k time exampl 1 input num 12345 k 3 output 18 explan need choos exactli 3 element num maxim sum first iter choos 5 sum 5 num 12346 second iter choos 6 sum 5 6 num 12347 third iter choos 7 sum 5 6 7 18 num 12348 return 18 proven 18 maximum answer achiev exampl 2 input num 555 k 2 output 11 explan need choos exactli 2 element num maxim sum first iter choos 5 sum 5 num 556 second iter choos 6 sum 5 6 11 num 557 return 11 proven 11 maximum answer achiev constraint 1 numslength 100 1 numsi 100 1 k 100 maximumsumwithexactlykel
given integ array num integ k split num k nonempti subarray largest sum subarray minim return minim largest sum split subarray contigu part array exampl 1 input num 725108 k 2 output 18 explan four way split num two subarray best way split 725 108 largest sum among two subarray 18 exampl 2 input num 12345 k 2 output 9 explan four way split num two subarray best way split 123 45 largest sum among two subarray 9 constraint 1 numslength 1000 0 numsi 106 1 k min50 numslength splitarraylargestsum
n binari tree node number 0 n 1 node two children leftchildi rightchildi return true given node form exactli one valid binari tree node left child leftchildi equal 1 similarli right child note node valu use node number problem exampl 1 input n 4 leftchild 1131 rightchild 2111 output true exampl 2 input n 4 leftchild 1131 rightchild 2311 output fals exampl 3 input n 2 leftchild 10 rightchild 11 output fals constraint n leftchildlength rightchildlength 1 n 104 1 leftchildi rightchildi n 1 validatebinarytreenod
given array string product string searchword design system suggest three product name product charact searchword type suggest product common prefix searchword three product common prefix return three lexicograph minimum product return list list suggest product charact searchword type exampl 1 input product mobilemousemoneypotmonitormousepad searchword mous output mobilemoneypotmonitormobilemoneypotmonitormousemousepadmousemousepadmousemousepad explan product sort lexicograph mobilemoneypotmonitormousemousepad type mo product match show user mobilemoneypotmonitor type mou mou mous system suggest mousemousepad exampl 2 input product havana searchword havana output havanahavanahavanahavanahavanahavana explan word havana alway suggest type search word constraint 1 productslength 1000 1 productsilength 3000 1 sumproductsilength 2 104 string product uniqu productsi consist lowercas english letter 1 searchwordlength 1000 searchword consist lowercas english letter searchsuggestionssystem
given integ array target integ array initi size target element initi zero one oper choos subarray initi increment valu one return minimum number oper form target array initi test case gener answer fit 32bit integ exampl 1 input target 12321 output 3 explan need least 3 oper form target array initi array 00000 increment 1 index 0 4 inclus 11111 increment 1 index 1 3 inclus 12221 increment 1 index 2 12321 target array form exampl 2 input target 3112 output 4 explan 0000 1111 1112 2112 3112 exampl 3 input target 31542 output 7 explan 00000 11111 21111 31111 31222 31332 31442 31542 constraint 1 targetlength 105 1 targeti 105 minimumnumberofincrementsonsubarraystoformatargetarray
given integ array coin length n repres n coin valu ith coin coinsi make valu x choos n coin valu sum x return maximum number consecut integ valu make coin start includ 0 note may multipl coin valu exampl 1 input coin 13 output 2 explan make follow valu 0 take 1 take 1 make 2 consecut integ valu start 0 exampl 2 input coin 1114 output 8 explan make follow valu 0 take 1 take 1 2 take 11 3 take 111 4 take 4 5 take 41 6 take 411 7 take 4111 make 8 consecut integ valu start 0 exampl 3 input num 141031 output 20 constraint coinslength n 1 n 4 104 1 coinsi 4 104 maximumnumberofconsecutivevaluesyoucanmak
given 0index binari array num length n num divid index 0 n two array possibl empti numsleft numsright numsleft element num index 0 1 inclus numsright element num index n 1 inclus 0 numsleft empti numsright element num n numsleft element num numsright empti divis score index sum number 0s numsleft number 1s numsright return distinct indic highest possibl divis score may return answer order exampl 1 input num 0010 output 24 explan divis index 0 numsleft numsright 0010 score 0 1 1 1 numsleft 0 numsright 010 score 1 1 2 2 numsleft 00 numsright 10 score 2 1 3 3 numsleft 001 numsright 0 score 2 0 2 4 numsleft 0010 numsright score 3 0 3 indic 2 4 highest possibl divis score 3 note answer 42 would also accept exampl 2 input num 000 output 3 explan divis index 0 numsleft numsright 000 score 0 0 0 1 numsleft 0 numsright 00 score 1 0 1 2 numsleft 00 numsright 0 score 2 0 2 3 numsleft 000 numsright score 3 0 3 index 3 highest possibl divis score 3 exampl 3 input num 11 output 0 explan divis index 0 numsleft numsright 11 score 0 2 2 1 numsleft 1 numsright 1 score 0 1 1 2 numsleft 11 numsright score 0 0 0 index 0 highest possibl divis score 2 constraint n numslength 1 n 105 numsi either 0 1 alldivisionswiththehighestscoreofabinaryarray
given posit integ num consist digit 6 9 return maximum number get chang one digit 6 becom 9 9 becom 6 exampl 1 input num 9669 output 9969 explan chang first digit result 6669 chang second digit result 9969 chang third digit result 9699 chang fourth digit result 9666 maximum number 9969 exampl 2 input num 9996 output 9999 explan chang last digit 6 9 result maximum number exampl 3 input num 9999 output 9999 explan better appli chang constraint 1 num 104 num consist 6 9 digit maximum69numb
alic bob take turn play game alic start first n stone arrang row player turn remov either leftmost stone rightmost stone row receiv point equal sum remain stone valu row winner one higher score stone left remov bob found alway lose game poor bob alway lose decid minim score differ alic goal maxim differ score given array integ stone stonesi repres valu ith stone left return differ alic bob score play optim exampl 1 input stone 53142 output 6 explan alic remov 2 get 5 3 1 4 13 point alic 13 bob 0 stone 5314 bob remov 5 get 3 1 4 8 point alic 13 bob 8 stone 314 alic remov 3 get 1 4 5 point alic 18 bob 8 stone 14 bob remov 1 get 4 point alic 18 bob 12 stone 4 alic remov 4 get 0 point alic 18 bob 12 stone score differ 18 12 6 exampl 2 input stone 7905110010102 output 122 constraint n stoneslength 2 n 1000 1 stonesi 1000 stonegamevii
n pile stone arrang row ith pile stonesi stone move consist merg exactli k consecut pile one pile cost move equal total number stone k pile return minimum cost merg pile stone one pile imposs return 1 exampl 1 input stone 3241 k 2 output 20 explan start 3 2 4 1 merg 3 2 cost 5 left 5 4 1 merg 4 1 cost 5 left 5 5 merg 5 5 cost 10 left 10 total cost 20 minimum possibl exampl 2 input stone 3241 k 3 output 1 explan merg oper 2 pile left cant merg anymor task imposs exampl 3 input stone 35126 k 3 output 25 explan start 3 5 1 2 6 merg 5 1 2 cost 8 left 3 8 6 merg 3 8 6 cost 17 left 17 total cost 25 minimum possibl constraint n stoneslength 1 n 30 1 stonesi 100 2 k 30 minimumcosttomergeston
compani n employe uniqu id employe 0 n 1 head compani one headid employe one direct manag given manag array manageri direct manag ith employe managerheadid 1 also guarante subordin relationship tree structur head compani want inform compani employe urgent piec news inform direct subordin inform subordin employe know urgent news ith employe need informtimei minut inform direct subordin ie informtimei minut direct subordin start spread news return number minut need inform employe urgent news exampl 1 input n 1 headid 0 manag 1 informtim 0 output 0 explan head compani employe compani exampl 2 input n 6 headid 2 manag 221222 informtim 001000 output 1 explan head compani id 2 direct manag employe compani need 1 minut inform tree structur employe compani shown constraint 1 n 105 0 headid n managerlength n 0 manageri n managerheadid 1 informtimelength n 0 informtimei 1000 informtimei 0 employe subordin guarante employe inform timeneededtoinformallemploye
given string express repres express fraction addit subtract return calcul result string format final result irreduc fraction final result integ chang format fraction denomin 1 case 2 convert 21 exampl 1 input express 1212 output 01 exampl 2 input express 121213 output 13 exampl 3 input express 1312 output 16 constraint input string contain 0 9 output fraction input output format ±numeratordenomin first input fraction output posit omit input contain valid irreduc fraction numer denomin fraction alway rang 1 10 denomin 1 mean fraction actual integ fraction format defin number given fraction rang 1 10 numer denomin final result guarante valid rang 32bit int fractionadditionandsubtract
sequenc special consist posit number 0s follow posit number 1s posit number 2s exampl 012 001112 special contrast 210 1 0120 special given array num consist integ 0 1 2 return number differ subsequ special sinc answer may larg return modulo 109 7 subsequ array sequenc deriv array delet element without chang order remain element two subsequ differ set indic chosen differ exampl 1 input num 0122 output 3 explan special subsequ bold 0122 0122 0122 exampl 2 input num 2200 output 0 explan special subsequ 2200 exampl 3 input num 012012 output 7 explan special subsequ bold 012012 012012 012012 012012 012012 012012 012012 constraint 1 numslength 105 0 numsi 2 countnumberofspecialsubsequ
given strictli increas integ array rung repres height rung ladder current floor height 0 want reach last rung also given integ dist climb next highest rung distanc current floor rung next rung dist abl insert rung posit integ height rung alreadi return minimum number rung must ad ladder order climb last rung exampl 1 input rung 13510 dist 2 output 2 explan current reach last rung add rung height 7 8 climb ladder ladder rung 1357810 exampl 2 input rung 36810 dist 3 output 0 explan ladder climb without ad addit rung exampl 3 input rung 3467 dist 2 output 1 explan current reach first rung ground add rung height 1 climb ladder ladder rung 13467 constraint 1 rungslength 105 1 rungsi 109 1 dist 109 rung strictli increas addminimumnumberofrung
task deliv box storag port use one ship howev ship limit number box total weight carri given array box boxesi portsi weighti three integ portscount maxbox maxweight portsi port need deliv ith box weightsi weight ith box portscount number port maxbox maxweight respect box weight limit ship box need deliv order given ship follow step ship take number box box queue violat maxbox maxweight constraint load box order ship make trip port box need deliv deliv ship alreadi correct port trip need box immedi deliv ship make return trip storag take box queue ship must end storag box deliv return minimum number trip ship need make deliv box respect port exampl 1 input box 112111 portscount 2 maxbox 3 maxweight 3 output 4 explan optim strategi follow ship take box queue goe port 1 port 2 port 1 return storag 4 trip total number trip 4 note first third box deliv togeth box need deliv order ie second box need deliv port 2 third box exampl 2 input box 1233313124 portscount 3 maxbox 3 maxweight 6 output 6 explan optim strategi follow ship take first box goe port 1 return storag 2 trip ship take second third fourth box goe port 3 return storag 2 trip ship take fifth box goe port 2 return storag 2 trip total number trip 2 2 2 6 exampl 3 input box 141221213234 portscount 3 maxbox 6 maxweight 7 output 6 explan optim strategi follow ship take first second box goe port 1 return storag 2 trip ship take third fourth box goe port 2 return storag 2 trip ship take fifth sixth box goe port 3 return storag 2 trip total number trip 2 2 2 6 constraint 1 boxeslength 105 1 portscount maxbox maxweight 105 1 portsi portscount 1 weightsi maxweight deliveringboxesfromstoragetoport
given collect number num might contain duplic return possibl uniqu permut order exampl 1 input num 112 output 112 121 211 exampl 2 input num 123 output 123132213231312321 constraint 1 numslength 8 10 numsi 10 permutationsii
given function fn return memoiz version function memoiz function function never call twice input instead return cach valu fn function constraint type valu accept input consid ident exampl 1 input getinput 222212 fn function b return b output val4calls1val4calls1val3calls2 explan const input getinput const memoiz memoizefn const arr input memoizedarr input 2 2 2 2 4 requir call fn input 2 2 2 2 4 input seen call fn requir input 1 2 1 2 3 requir anoth call fn total 2 exampl 2 input getinput fn function b return b output valcalls1valcalls2valcalls3 explan merg two empti object alway result empti object may seem like 1 call fn cachehit howev none object exampl 3 input getinput const return oooooo fn function b return b output valcalls1valcalls1valcalls1 explan merg two empti object alway result empti object 2nd 3rd third function call result cachehit everi object pass ident constraint 1 inputslength 105 0 inputsflatlength 105 inputsij nan memoizeii
given string integ array indic length string shuffl charact ith posit move indicesi shuffl string return shuffl string exampl 1 input codeleet indic 45670213 output leetcod explan shown codeleet becom leetcod shuffl exampl 2 input abc indic 012 output abc explan shuffl charact remain posit constraint slength indiceslength n 1 n 100 consist lowercas english letter 0 indicesi n valu indic uniqu shufflestr
row domino topsi bottomsi repres top bottom halv ith domino domino tile two number 1 6 one half tile may rotat ith domino topsi bottomsi swap valu return minimum number rotat valu top valu bottom done return 1 exampl 1 input top 212422 bottom 526232 output 2 explan first figur repres domino given top bottom rotat rotat second fourth domino make everi valu top row equal 2 indic second figur exampl 2 input top 35123 bottom 36334 output 1 explan case possibl rotat domino make one row valu equal constraint 2 topslength 2 104 bottomslength topslength 1 topsi bottomsi 6 minimumdominorotationsforequalrow
n x n grid compos 1 x 1 squar 1 x 1 squar consist blank space charact divid squar contigu region given grid grid repres string array return number region note backslash charact escap repres exampl 1 input grid output 2 exampl 2 input grid output 1 exampl 3 input grid output 5 explan recal charact escap refer refer constraint n gridlength gridilength 1 n 30 gridij either regionscutbyslash
car travel start posit destin target mile east start posit ga station along way ga station repres array station stationsi positioni fueli indic ith ga station positioni mile east start posit fueli liter ga car start infinit tank ga initi startfuel liter fuel use one liter ga per one mile drive car reach ga station may stop refuel transfer ga station car return minimum number refuel stop car must make order reach destin reach destin return 1 note car reach ga station 0 fuel left car still refuel car reach destin 0 fuel left still consid arriv exampl 1 input target 1 startfuel 1 station output 0 explan reach target without refuel exampl 2 input target 100 startfuel 1 station 10100 output 1 explan reach target even first ga station exampl 3 input target 100 startfuel 10 station 1060203030306040 output 2 explan start 10 liter fuel drive posit 10 expend 10 liter fuel refuel 0 liter 60 liter ga drive posit 10 posit 60 expend 50 liter fuel refuel 10 liter 50 liter ga drive reach target made 2 refuel stop along way return 2 constraint 1 target startfuel 109 0 stationslength 500 1 positioni positioni1 target 1 fueli 109 minimumnumberofrefuelingstop
given two string array creator id integ array view length n ith video platform creat creatori id idsi viewsi view popular creator sum number view creator video find creator highest popular id view video multipl creator highest popular find multipl video highest view count creator find lexicograph smallest id return 2d array string answer answeri creatori idi mean creatori highest popular idi id popular video answer return order exampl 1 input creator alicebobalicechri id onetwothreefour view 51054 output aliceonebobtwo explan popular alic 5 5 10 popular bob 10 popular chri 4 alic bob popular creator bob video highest view count two alic video highest view count one three sinc one lexicograph smaller three includ answer exampl 2 input creator alicealicealic id abc view 122 output aliceb explan video id b c highest view count sinc b lexicograph smaller c includ answer constraint n creatorslength idslength viewslength 1 n 105 1 creatorsilength idsilength 5 creatorsi idsi consist lowercas english letter 0 viewsi 105 mostpopularvideocr
given two string consist lowercas english letter return minimum number charact need append end becom subsequ subsequ string deriv anoth string delet charact without chang order remain charact exampl 1 input coach code output 4 explan append charact ding end coachingd subsequ coachingd shown append 3 charact end never make subsequ exampl 2 input abcd output 0 explan alreadi subsequ abcd exampl 3 input z abcd output 5 explan append charact abcd end zabcd subsequ zabcd shown append 4 charact end never make subsequ constraint 1 slength tlength 105 consist lowercas english letter appendcharacterstostringtomakesubsequ
given array function f1 f2 f3 fn return new function fn function composit array function function composit fx gx hx fnx fghx function composit empti list function ident function fx x may assum function array accept one integ input return one integ output exampl 1 input function x x 1 x x x x 2 x x 4 output 65 explan evalu right left start x 4 2 4 8 8 8 64 64 1 65 exampl 2 input function x 10 x x 10 x x 10 x x 1 output 1000 explan evalu right left 10 1 10 10 10 100 10 100 1000 exampl 3 input function x 42 output 42 explan composit zero function ident function constraint 1000 x 1000 0 functionslength 1000 function accept return singl integ functioncomposit
given 0index integ array num pair indic j 0 j numslength call beauti first digit numsi last digit numsj coprim return total number beauti pair num two integ x coprim integ greater 1 divid word x coprim gcdx 1 gcdx greatest common divisor x exampl 1 input num 2514 output 5 explan 5 beauti pair num 0 j 1 first digit nums0 2 last digit nums1 5 confirm 2 5 coprim sinc gcd25 1 0 j 2 first digit nums0 2 last digit nums2 1 inde gcd21 1 1 j 2 first digit nums1 5 last digit nums2 1 inde gcd51 1 1 j 3 first digit nums1 5 last digit nums3 4 inde gcd54 1 2 j 3 first digit nums2 1 last digit nums3 4 inde gcd14 1 thu return 5 exampl 2 input num 112112 output 2 explan 2 beauti pair 0 j 1 first digit nums0 1 last digit nums1 1 inde gcd11 1 0 j 2 first digit nums0 1 last digit nums2 2 inde gcd12 1 thu return 2 constraint 2 numslength 100 1 numsi 9999 numsi 10 0 numberofbeautifulpair
given two integ left right return count number inclus rang left right prime number set bit binari represent recal number set bit integ number 1s present written binari exampl 21 written binari 10101 3 set bit exampl 1 input left 6 right 10 output 4 explan 6 110 2 set bit 2 prime 7 111 3 set bit 3 prime 8 1000 1 set bit 1 prime 9 1001 2 set bit 2 prime 10 1010 2 set bit 2 prime 4 number prime number set bit exampl 2 input left 10 right 15 output 5 explan 10 1010 2 set bit 2 prime 11 1011 3 set bit 3 prime 12 1100 2 set bit 2 prime 13 1101 3 set bit 3 prime 14 1110 3 set bit 3 prime 15 1111 4 set bit 4 prime 5 number prime number set bit constraint 1 left right 106 0 right left 104 primenumberofsetbitsinbinaryrepresent
determin 9 x 9 sudoku board valid fill cell need valid accord follow rule row must contain digit 19 without repetit column must contain digit 19 without repetit nine 3 x 3 subbox grid must contain digit 19 without repetit note sudoku board partial fill could valid necessarili solvabl fill cell need valid accord mention rule exampl 1 input board 537 6195 986 863 4831 726 628 4195 879 output true exampl 2 input board 837 6195 986 863 4831 726 628 4195 879 output fals explan exampl 1 except 5 top left corner modifi 8 sinc two 8s top left 3x3 subbox invalid constraint boardlength 9 boardilength 9 boardij digit 19 validsudoku
alic bob oppon archeri competit competit set follow rule alic first shoot numarrow arrow bob shoot numarrow arrow point calcul follow target integ score section rang 0 11 inclus section target score k 0 11 say alic bob shot ak bk arrow section respect ak bk alic take k point ak bk bob take k point howev ak bk 0 nobodi take k point exampl alic bob shot 2 arrow section score 11 alic take 11 point hand alic shot 0 arrow section score 11 bob shot 2 arrow section bob take 11 point given integ numarrow integ array alicearrow size 12 repres number arrow alic shot score section 0 11 bob want maxim total number point obtain return array bobarrow repres number arrow bob shot score section 0 11 sum valu bobarrow equal numarrow multipl way bob earn maximum total point return one exampl 1 input numarrow 9 alicearrow 110100210120 output 000011001231 explan tabl show competit score bob earn total point 4 5 8 9 10 11 47 shown bob obtain score higher 47 point exampl 2 input numarrow 3 alicearrow 001000000002 output 000000001110 explan tabl show competit score bob earn total point 8 9 10 27 shown bob obtain score higher 27 point constraint 1 numarrow 105 alicearrowslength bobarrowslength 12 0 alicearrowsi bobarrowsi numarrow sumalicearrowsi numarrow maximumpointsinanarcherycompetit
given integ array num integ k num compris 0s 1s one move choos two adjac indic swap valu return minimum number move requir num k consecut 1s exampl 1 input num 100101 k 2 output 1 explan 1 move num could 100011 2 consecut 1s exampl 2 input num 10000011 k 3 output 5 explan 5 move leftmost 1 shift right num 00000111 exampl 3 input num 1101 k 2 output 0 explan num alreadi 2 consecut 1s constraint 1 numslength 105 numsi 0 1 1 k sumnum minimumadjacentswapsforkconsecutiveon
movi rent compani consist n shop want implement rent system support search book return movi system also support gener report current rent movi movi given 2d integ array entri entriesi shopi moviei pricei indic copi movi moviei shop shopi rental price pricei shop carri one copi movi moviei system support follow function search find cheapest 5 shop unrent copi given movi shop sort price ascend order case tie one smaller shopi appear first less 5 match shop return shop unrent copi empti list return rent rent unrent copi given movi given shop drop drop previous rent copi given movi given shop report return cheapest 5 rent movi possibl movi id 2d list re resj shopj moviej describ jth cheapest rent movi moviej rent shop shopj movi re sort price ascend order case tie one smaller shopj appear first still tie one smaller moviej appear first fewer 5 rent movi return movi current rent empti list return implement movierentingsystem class movierentingsystemint n int entri initi movierentingsystem object n shop movi entri listinteg searchint movi return list shop unrent copi given movi describ void rentint shop int movi rent given movi given shop void dropint shop int movi drop previous rent movi given shop listlistinteg report return list cheapest rent movi describ note test case gener rent call shop unrent copi movi drop call shop previous rent movi exampl 1 input movierentingsystem search rent rent report drop search 3 0 1 5 0 2 6 0 3 7 1 1 4 1 2 7 2 1 5 1 0 1 1 2 1 2 2 output null 1 0 2 null null 0 1 1 2 null 0 1 explan movierentingsystem movierentingsystem new movierentingsystem3 0 1 5 0 2 6 0 3 7 1 1 4 1 2 7 2 1 5 movierentingsystemsearch1 return 1 0 2 movi id 1 unrent shop 1 0 2 shop 1 cheapest shop 0 2 price order shop number movierentingsystemrent0 1 rent movi 1 shop 0 unrent movi shop 0 23 movierentingsystemrent1 2 rent movi 2 shop 1 unrent movi shop 1 1 movierentingsystemreport return 0 1 1 2 movi 1 shop 0 cheapest follow movi 2 shop 1 movierentingsystemdrop1 2 drop movi 2 shop 1 unrent movi shop 1 12 movierentingsystemsearch2 return 0 1 movi id 2 unrent shop 0 1 shop 0 cheapest follow shop 1 constraint 1 n 3 105 1 entrieslength 105 0 shopi n 1 moviei pricei 104 shop carri one copi movi moviei 105 call total made search rent drop report designmovierentalsystem
xor sum list bitwis xor element list contain one element xor sum equal element exampl xor sum 1234 equal 1 xor 2 xor 3 xor 4 4 xor sum 3 equal 3 given two 0index array arr1 arr2 consist nonneg integ consid list contain result arr1i arr2j bitwis everi j pair 0 arr1length 0 j arr2length return xor sum aforement list exampl 1 input arr1 123 arr2 65 output 0 explan list 1 6 1 5 2 6 2 5 3 6 3 5 012021 xor sum 0 xor 1 xor 2 xor 0 xor 2 xor 1 0 exampl 2 input arr1 12 arr2 4 output 4 explan list 12 4 4 xor sum 4 constraint 1 arr1length arr2length 105 0 arr1i arr2j 109 findxorsumofallpairsbitwiseand
given string consist digit check split two nonempti substr numer valu substr descend order differ numer valu everi two adjac substr equal 1 exampl string 0090089 split 0090 089 numer valu 9089 valu descend order adjac valu differ 1 way valid anoth exampl string 001 split 0 01 00 1 0 0 1 howev way invalid numer valu 01 01 001 respect descend order return true possibl split describ fals otherwis substr contigu sequenc charact string exampl 1 input 1234 output fals explan valid way split exampl 2 input 050043 output true explan split 05 004 3 numer valu 543 valu descend order adjac valu differ 1 exampl 3 input 9080701 output fals explan valid way split constraint 1 slength 20 consist digit splittingastringintodescendingconsecutivevalu
given integ num return string base 7 represent exampl 1 input num 100 output 202 exampl 2 input num 7 output 10 constraint 107 num 107 base7
given two 0index integ array nums1 nums2 size n integ diff find number pair j 0 j n 1 nums1i nums1j nums2i nums2j diff return number pair satisfi condit exampl 1 input nums1 325 nums2 221 diff 1 output 3 explan 3 pair satisfi condit 1 0 j 1 3 2 2 2 1 sinc j 1 1 pair satisfi condit 2 0 j 2 3 5 2 1 1 sinc j 2 2 pair satisfi condit 3 1 j 2 2 5 2 1 1 sinc j 3 2 pair satisfi condit therefor return 3 exampl 2 input nums1 31 nums2 22 diff 1 output 0 explan sinc exist pair satisfi condit return 0 constraint n nums1length nums2length 2 n 105 104 nums1i nums2i 104 104 diff 104 numberofpairssatisfyinginequ
given string array string word return number wordsi subsequ subsequ string new string gener origin string charact none delet without chang rel order remain charact exampl ace subsequ abcd exampl 1 input abcd word abbacdac output 3 explan three string word subsequ acd ace exampl 2 input dsahjpjauf word ahjpjaujaahbwzgqnuktnmlanowax output 2 constraint 1 slength 5 104 1 wordslength 5000 1 wordsilength 50 wordsi consist lowercas english letter numberofmatchingsubsequ
given array integ num integ target return number nonempti subsequ num sum minimum maximum element less equal target sinc answer may larg return modulo 109 7 exampl 1 input num 3567 target 9 output 4 explan 4 subsequ satisfi condit 3 min valu max valu target 3 3 9 35 3 5 9 356 3 6 9 36 3 6 9 exampl 2 input num 3368 target 10 output 6 explan 6 subsequ satisfi condit num repeat number 3 3 33 36 36 336 exampl 3 input num 233467 target 12 output 61 explan 63 nonempti subsequ two satisfi condit 67 7 number valid subsequ 63 2 61 constraint 1 numslength 105 1 numsi 106 1 target 106 numberofsubsequencesthatsatisfythegivensumcondit
given posit integ n appli one follow oper n even replac n n 2 n odd replac n either n 1 n 1 return minimum number oper need n becom 1 exampl 1 input n 8 output 3 explan 8 4 2 1 exampl 2 input n 7 output 4 explan 7 8 4 2 1 7 6 3 2 1 exampl 3 input n 4 output 2 constraint 1 n 231 1 integerreplac
countandsay sequenc sequenc digit string defin recurs formula countandsay1 1 countandsayn way would say digit string countandsayn1 convert differ digit string determin say digit string split minim number substr substr contain exactli one uniqu digit substr say number digit say digit final concaten everi said digit exampl say convers digit string 3322251 given posit integ n return nth term countandsay sequenc exampl 1 input n 1 output 1 explan base case exampl 2 input n 4 output 1211 explan countandsay1 1 countandsay2 say 1 one 1 11 countandsay3 say 11 two 1s 21 countandsay4 say 21 one 2 one 1 12 11 1211 constraint 1 n 30 countandsay
given two integ array nums1 nums2 return array intersect element result must uniqu may return result order exampl 1 input nums1 1221 nums2 22 output 2 exampl 2 input nums1 495 nums2 94984 output 94 explan 49 also accept constraint 1 nums1length nums2length 1000 0 nums1i nums2i 1000 intersectionoftwoarray
given two string allow remov number charact string score string 0 charact remov string otherwis let left minimum index among remov charact let right maximum index among remov charact score string right left 1 return minimum possibl score make subsequ subsequ string new string form origin string delet none charact without disturb rel posit remain charact ie ace subsequ abcd aec exampl 1 input abacaba bzaa output 1 explan exampl remov charact z index 1 0index string becom baa subsequ string abacaba score 1 1 1 1 proven 1 minimum score achiev exampl 2 input cde xyz output 3 explan exampl remov charact x z indic 0 1 2 0index string becom subsequ string cde score 2 0 1 3 proven 3 minimum score achiev constraint 1 slength tlength 105 consist lowercas english letter subsequencewiththeminimumscor
given string time form hhmm digit string hidden repres valid time inclus 0000 2359 return latest valid time get time replac hidden digit exampl 1 input time 20 output 2350 explan latest hour begin digit 2 23 latest minut end digit 0 50 exampl 2 input time 03 output 0939 exampl 3 input time 122 output 1922 constraint time format hhmm guarante produc valid time given string latesttimebyreplacinghiddendigit
given direct acycl graph dag n node label 0 n 1 find possibl path node 0 node n 1 return order graph given follow graphi list node visit node ie direct edg node node graphij exampl 1 input graph 1233 output 013023 explan two path 0 1 3 0 2 3 exampl 2 input graph 43132434 output 04034013401234014 constraint n graphlength 2 n 15 0 graphij n graphij ie selfloop element graphi uniqu input graph guarante dag allpathsfromsourcetotarget
given root binari tree return leftmost valu last row tree exampl 1 input root 213 output 1 exampl 2 input root 1234null56nullnull7 output 7 constraint number node tree rang 1 104 231 nodev 231 1 findbottomlefttreevalu
given integ n find sequenc satisfi follow integ 1 occur sequenc integ 2 n occur twice sequenc everi integ 2 n distanc two occurr exactli distanc two number sequenc ai aj absolut differ indic j return lexicograph largest sequenc guarante given constraint alway solut sequenc lexicograph larger sequenc b length first posit b differ sequenc number greater correspond number b exampl 0190 lexicograph larger 0156 first posit differ third number 9 greater 5 exampl 1 input n 3 output 31232 explan 23213 also valid sequenc 31232 lexicograph largest valid sequenc exampl 2 input n 5 output 531435242 constraint 1 n 20 constructthelexicographicallylargestvalidsequ
given array interv intervalsi starti endi starti uniqu right interv interv interv j startj endi startj minim note may equal j return array right interv indic interv right interv exist interv put 1 index exampl 1 input interv 12 output 1 explan one interv collect output 1 exampl 2 input interv 342312 output 101 explan right interv 34 right interv 23 34 sinc start0 3 smallest start end1 3 right interv 12 23 sinc start1 2 smallest start end2 2 exampl 3 input interv 142334 output 121 explan right interv 14 34 right interv 23 34 sinc start2 3 smallest start end1 3 constraint 1 intervalslength 2 104 intervalsilength 2 106 starti endi 106 start point interv uniqu findrightinterv
given root binari tree return length longest path node path valu path may may pass root length path two node repres number edg exampl 1 input root 54511null5 output 2 explan shown imag show longest path valu ie 5 exampl 2 input root 14544null5 output 2 explan shown imag show longest path valu ie 4 constraint number node tree rang 0 104 1000 nodev 1000 depth tree exceed 1000 longestunivaluepath
given array integ num integ limit return size longest nonempti subarray absolut differ two element subarray less equal limit exampl 1 input num 8247 limit 4 output 2 explan subarray 8 maximum absolut diff 88 0 4 82 maximum absolut diff 82 6 4 824 maximum absolut diff 82 6 4 8247 maximum absolut diff 82 6 4 2 maximum absolut diff 22 0 4 24 maximum absolut diff 24 2 4 247 maximum absolut diff 27 5 4 4 maximum absolut diff 44 0 4 47 maximum absolut diff 47 3 4 7 maximum absolut diff 77 0 4 therefor size longest subarray 2 exampl 2 input num 1012472 limit 5 output 4 explan subarray 2472 longest sinc maximum absolut diff 27 5 5 exampl 3 input num 42224422 limit 0 output 3 constraint 1 numslength 105 1 numsi 109 0 limit 109 longestcontinuoussubarraywithabsolutedifflessthanorequaltolimit
given direct graph n node label 0 n 1 node exactli one outgo edg graph repres given 0index integ array edg length n edgesi indic direct edg node node edgesi edg score node defin sum label node edg point return node highest edg score multipl node edg score return node smallest index exampl 1 input edg 10000775 output 7 explan node 1 2 3 4 edg point node 0 edg score node 0 1 2 3 4 10 node 0 edg point node 1 edg score node 1 0 node 7 edg point node 5 edg score node 5 7 node 5 6 edg point node 7 edg score node 7 5 6 11 node 7 highest edg score return 7 exampl 2 input edg 2002 output 0 explan node 1 2 edg point node 0 edg score node 0 1 2 3 node 0 3 edg point node 2 edg score node 2 0 3 3 node 0 2 edg score 3 sinc node 0 smaller index return 0 constraint n edgeslength 2 n 105 0 edgesi n edgesi nodewithhighestedgescor
given 0index array string garbag garbagei repres assort garbag ith hous garbagei consist charact p g repres one unit metal paper glass garbag respect pick one unit type garbag take 1 minut also given 0index integ array travel trave number minut need go hous hous 1 three garbag truck citi respons pick one type garbag garbag truck start hous 0 must visit hous order howev need visit everi hous one garbag truck may use given moment one truck drive pick garbag two truck anyth return minimum number minut need pick garbag exampl 1 input garbag gpgpgg travel 243 output 21 explan paper garbag truck 1 travel hous 0 hous 1 2 collect paper garbag hous 1 3 travel hous 1 hous 2 4 collect paper garbag hous 2 altogeth take 8 minut pick paper garbag glass garbag truck 1 collect glass garbag hous 0 2 travel hous 0 hous 1 3 travel hous 1 hous 2 4 collect glass garbag hous 2 5 travel hous 2 hous 3 6 collect glass garbag hous 3 altogeth take 13 minut pick glass garbag sinc metal garbag need consid metal garbag truck therefor take total 8 13 21 minut collect garbag exampl 2 input garbag mmmpgmgp travel 310 output 37 explan metal garbag truck take 7 minut pick metal garbag paper garbag truck take 15 minut pick paper garbag glass garbag truck take 15 minut pick glass garbag take total 7 15 15 37 minut collect garbag constraint 2 garbagelength 105 garbagei consist letter p g 1 garbageilength 10 travellength garbagelength 1 1 trave 100 minimumamountoftimetocollectgarbag
die simul gener random number 1 6 roll introduc constraint gener roll number rollmaxi 1index consecut time given array integ rollmax integ n return number distinct sequenc obtain exact n roll sinc answer may larg return modulo 109 7 two sequenc consid differ least one element differ exampl 1 input n 2 rollmax 112223 output 34 explan 2 roll die constraint die 6 6 36 possibl combin case look rollmax array number 1 2 appear consecut therefor sequenc 11 22 occur final answer 362 34 exampl 2 input n 2 rollmax 111111 output 30 exampl 3 input n 3 rollmax 111223 output 181 constraint 1 n 5000 rollmaxlength 6 1 rollmaxi 15 dicerollsimul
given string word return sum number vowel e u everi substr word substr contigu nonempti sequenc charact within string note due larg constraint answer may fit sign 32bit integ pleas care calcul exampl 1 input word aba output 6 explan possibl substr ab aba b ba b 0 vowel ab ba 1 vowel aba 2 vowel henc total sum vowel 0 1 1 1 1 2 6 exampl 2 input word abc output 3 explan possibl substr ab abc b bc c ab abc 1 vowel b bc c 0 vowel henc total sum vowel 1 1 1 0 0 0 3 exampl 3 input word ltcd output 0 explan vowel substr ltcd constraint 1 wordlength 105 word consist lowercas english letter vowelsofallsubstr
given n x n integ matrix grid valu gridij repres elev point j rain start fall time depth water everywher swim squar anoth 4direct adjac squar elev squar individu swim infinit distanc zero time cours must stay within boundari grid swim return least time reach bottom right squar n 1 n 1 start top left squar 0 0 exampl 1 input grid 0213 output 3 explan time 0 grid locat 0 0 go anywher els 4direct adjac neighbor higher elev 0 reach point 1 1 time 3 depth water 3 swim anywher insid grid exampl 2 input grid 0123424232221512131415161117181920109876 output 16 explan final rout shown need wait time 16 0 0 4 4 connect constraint n gridlength n gridilength 1 n 50 0 gridij n2 valu gridij uniqu swiminrisingwat
distribut number candi row n numpeopl peopl follow way give 1 candi first person 2 candi second person give n candi last person go back start row give n 1 candi first person n 2 candi second person give 2 n candi last person process repeat us give one candi time move start row reach end run candi last person receiv remain candi necessarili one previou gift return array length numpeopl sum candi repres final distribut candi exampl 1 input candi 7 numpeopl 4 output 1231 explan first turn ans0 1 array 1000 second turn ans1 2 array 1200 third turn ans2 3 array 1230 fourth turn ans3 1 one candi left final array 1231 exampl 2 input candi 10 numpeopl 3 output 523 explan first turn ans0 1 array 100 second turn ans1 2 array 120 third turn ans2 3 array 123 fourth turn ans0 4 final array 523 constraint 1 candi 109 1 numpeopl 1000 distributecandiestopeopl
given integ array num 0index one oper choos element array increment 1 exampl num 123 choos increment nums1 make num 133 return minimum number oper need make num strictli increas array num strictli increas numsi numsi1 0 numslength 1 array length 1 trivial strictli increas exampl 1 input num 111 output 3 explan follow oper 1 increment nums2 num becom 112 2 increment nums1 num becom 122 3 increment nums2 num becom 123 exampl 2 input num 15241 output 14 exampl 3 input num 8 output 0 constraint 1 numslength 5000 1 numsi 104 minimumoperationstomakethearrayincreas
play guess game game work follow pick number 1 n guess number guess right number win game guess wrong number tell whether number pick higher lower continu guess everi time guess wrong number x pay x dollar run money lose game given particular n return minimum amount money need guarante win regardless number pick exampl 1 input n 10 output 16 explan win strategi follow rang 110 guess 7 number total 0 otherwis pay 7 number higher rang 810 guess 9 number total 7 otherwis pay 9 number higher must 10 guess 10 total 7 9 16 number lower must 8 guess 8 total 7 9 16 number lower rang 16 guess 3 number total 7 otherwis pay 3 number higher rang 46 guess 5 number total 7 3 10 otherwis pay 5 number higher must 6 guess 6 total 7 3 5 15 number lower must 4 guess 4 total 7 3 5 15 number lower rang 12 guess 1 number total 7 3 10 otherwis pay 1 number higher must 2 guess 2 total 7 3 1 11 worst case scenario pay 16 henc need 16 guarante win exampl 2 input n 1 output 0 explan one possibl number guess 1 pay anyth exampl 3 input n 2 output 1 explan two possibl number 1 2 guess 1 number total 0 otherwis pay 1 number higher must 2 guess 2 total 1 worst case pay 1 constraint 1 n 200 guessnumberhigherorlowerii
given 2d integ array rectangl rectanglesi li hi indic ith rectangl length li height hi also given 2d integ array point pointsj xj yj point coordin xj yj ith rectangl bottomleft corner point coordin 0 0 topright corner point li hi return integ array count length pointslength countj number rectangl contain jth point ith rectangl contain jth point 0 xj li 0 yj hi note point lie edg rectangl also consid contain rectangl exampl 1 input rectangl 122325 point 2114 output 21 explan first rectangl contain point second rectangl contain point 2 1 third rectangl contain point 2 1 1 4 number rectangl contain point 2 1 2 number rectangl contain point 1 4 1 therefor return 2 1 exampl 2 input rectangl 112233 point 1311 output 13 explan first rectangl contain point 1 1 second rectangl contain point 1 1 third rectangl contain point 1 3 1 1 number rectangl contain point 1 3 1 number rectangl contain point 1 1 3 therefor return 1 3 constraint 1 rectangleslength pointslength 5 104 rectanglesilength pointsjlength 2 1 li xj 109 1 hi yj 100 rectangl uniqu point uniqu countnumberofrectanglescontainingeachpoint
origin string consist lowercas english letter encod follow step arbitrarili split sequenc number nonempti substr arbitrarili choos element possibl none sequenc replac length numer string concaten sequenc encod string exampl one way encod origin string abcdefghijklmnop might split sequenc ab cdefghijklmn p choos second third element replac length respect sequenc becom ab 12 1 p concaten element sequenc get encod string ab121p given two encod string s1 s2 consist lowercas english letter digit 19 inclus return true exist origin string could encod s1 s2 otherwis return fals note test case gener number consecut digit s1 s2 exceed 3 exampl 1 input s1 internation s2 i18n output true explan possibl internation origin string internation split internation replac element concaten internation s1 internation split nternationalizatio n replac 18 n concaten i18n s2 exampl 2 input s1 l123e s2 44 output true explan possibl leetcod origin string leetcod split l e et cod e replac l 1 2 3 e concaten l123e s1 leetcod split leet code replac 4 4 concaten 44 s2 exampl 3 input s1 a5b s2 c5b output fals explan imposs origin string encod s1 must start letter origin string encod s2 must start letter c constraint 1 s1length s2length 40 s1 s2 consist digit 19 inclus lowercas english letter number consecut digit s1 s2 exceed 3 checkifanoriginalstringexistsgiventwoencodedstr
visit farm singl row fruit tree arrang left right tree repres integ array fruit fruitsi type fruit ith tree produc want collect much fruit possibl howev owner strict rule must follow two basket basket hold singl type fruit limit amount fruit basket hold start tree choic must pick exactli one fruit everi tree includ start tree move right pick fruit must fit one basket reach tree fruit fit basket must stop given integ array fruit return maximum number fruit pick exampl 1 input fruit 121 output 3 explan pick 3 tree exampl 2 input fruit 0122 output 3 explan pick tree 122 start first tree would pick tree 01 exampl 3 input fruit 12322 output 4 explan pick tree 2322 start first tree would pick tree 12 constraint 1 fruitslength 105 0 fruitsi fruitslength fruitintobasket
n flower seed everi seed must plant first begin grow bloom plant seed take time growth seed given two 0index integ array planttim growtim length n planttimei number full day take plant ith seed everi day work plant exactli one seed work plant seed consecut day plant seed complet work planttimei day plant total growtimei number full day take ith seed grow complet plant last day growth flower bloom stay bloom forev begin day 0 plant seed order return earliest possibl day seed bloom exampl 1 input planttim 143 growtim 231 output 9 explan gray pot repres plant day color pot repres grow day flower repres day bloom one optim way day 0 plant 0th seed seed grow 2 full day bloom day 3 day 1 2 3 4 plant 1st seed seed grow 3 full day bloom day 8 day 5 6 7 plant 2nd seed seed grow 1 full day bloom day 9 thu day 9 seed bloom exampl 2 input planttim 1232 growtim 2121 output 9 explan gray pot repres plant day color pot repres grow day flower repres day bloom one optim way day 1 plant 0th seed seed grow 2 full day bloom day 4 day 0 3 plant 1st seed seed grow 1 full day bloom day 5 day 2 4 5 plant 2nd seed seed grow 2 full day bloom day 8 day 6 7 plant 3rd seed seed grow 1 full day bloom day 9 thu day 9 seed bloom exampl 3 input planttim 1 growtim 1 output 2 explan day 0 plant 0th seed seed grow 1 full day bloom day 2 thu day 2 seed bloom constraint n planttimelength growtimelength 1 n 105 1 planttimei growtimei 104 earliestpossibledayoffullbloom
sql schema tabl movi column name type movieid int titl varchar movieid primari key tabl titl name movi tabl user column name type userid int name varchar userid primari key tabl tabl movier column name type movieid int userid int rate int createdat date movieid userid primari key tabl tabl contain rate movi user review createdat user review date write sql queri find name user rate greatest number movi case tie return lexicograph smaller user name find movi name highest averag rate februari 2020 case tie return lexicograph smaller movi name queri result format follow exampl exampl 1 input movi tabl movieid titl 1 aveng 2 frozen 2 3 joker user tabl userid name 1 daniel 2 monica 3 maria 4 jame movier tabl movieid userid rate createdat 1 1 3 20200112 1 2 4 20200211 1 3 2 20200212 1 4 1 20200101 2 1 5 20200217 2 2 2 20200201 2 3 2 20200301 3 1 3 20200222 3 2 4 20200225 output result daniel frozen 2 explan daniel monica rate 3 movi aveng frozen 2 joker daniel smaller lexicograph frozen 2 joker rate averag 35 februari frozen 2 smaller lexicograph movier
given root binari tree posit integ k level sum tree sum valu node level return kth largest level sum tree necessarili distinct fewer k level tree return 1 note two node level distanc root exampl 1 input root 589213746 k 2 output 13 explan level sum follow level 1 5 level 2 8 9 17 level 3 2 1 3 7 13 level 4 4 6 10 2nd largest level sum 13 exampl 2 input root 12null3 k 1 output 3 explan largest level sum 3 constraint number node tree n 2 n 105 1 nodev 106 1 k n kthlargestsuminabinarytre
singlylink list head want delet node node given node delet node given access first node head valu link list uniqu guarante given node node last node link list delet given node note delet node mean remov memori mean valu given node exist link list number node link list decreas one valu node order valu node order custom test input provid entir link list head node given node node last node list actual node list build link list pass node function output entir list call function exampl 1 input head 4519 node 5 output 419 explan given second node valu 5 link list becom 4 1 9 call function exampl 2 input head 4519 node 1 output 459 explan given third node valu 1 link list becom 4 5 9 call function constraint number node given list rang 2 1000 1000 nodev 1000 valu node list uniqu node delet list tail node deletenodeinalinkedlist
given string return word vertic order appear word return list string complet space necessari trail space allow word would put one column one column one word exampl 1 input output hayoroweu explan word print vertic hay oro weu exampl 2 input output tbontboeroo explan trail space allow tbontb oeroo exampl 3 input contest come output cicoson mt ie ns gt constraint 1 slength 200 contain upper case english letter guarante one space 2 word printwordsvert
let function fs frequenc lexicograph smallest charact nonempti string exampl dcce fs 2 lexicograph smallest charact c frequenc 2 given array string word anoth array queri string queri queri queriesi count number word word fqueriesi fw w word return integ array answer answeri answer ith queri exampl 1 input queri cbd word zaaaz output 1 explan first queri fcbd 1 fzaaaz 3 fcbd fzaaaz exampl 2 input queri bbbcc word aaaaaaaaaa output 12 explan first queri fbbb faaaa second queri faaa faaaa fcc constraint 1 querieslength 2000 1 wordslength 2000 1 queriesilength wordsilength 10 queriesij wordsij consist lowercas english letter comparestringsbyfrequencyofthesmallestcharact
given array integ num integ target return indic two number add target may assum input would exactli one solut may use element twice return answer order exampl 1 input num 271115 target 9 output 01 explan nums0 nums1 9 return 0 1 exampl 2 input num 324 target 6 output 12 exampl 3 input num 33 target 6 output 01 constraint 2 numslength 104 109 numsi 109 109 target 109 one valid answer exist followup come algorithm less on2 time complex twosum
imag repres x n integ grid imag imageij repres pixel valu imag also given three integ sr sc color perform flood fill imag start pixel imagesrsc perform flood fill consid start pixel plu pixel connect 4direct start pixel color start pixel plu pixel connect 4direct pixel also color replac color aforement pixel color return modifi imag perform flood fill exampl 1 input imag 111110101 sr 1 sc 1 color 2 output 222220201 explan center imag posit sr sc 1 1 ie red pixel pixel connect path color start pixel ie blue pixel color new color note bottom corner color 2 4direct connect start pixel exampl 2 input imag 000000 sr 0 sc 0 color 0 output 000000 explan start pixel alreadi color 0 chang made imag constraint imagelength n imageilength 1 n 50 0 imageij color 216 0 sr 0 sc n floodfil
given integ array num return greatest common divisor smallest number largest number num greatest common divisor two number largest posit integ evenli divid number exampl 1 input num 256910 output 2 explan smallest number num 2 largest number num 10 greatest common divisor 2 10 2 exampl 2 input num 75683 output 1 explan smallest number num 3 largest number num 8 greatest common divisor 3 8 1 exampl 3 input num 33 output 3 explan smallest number num 3 largest number num 3 greatest common divisor 3 3 3 constraint 2 numslength 1000 1 numsi 1000 findgreatestcommondivisorofarray
varianc string defin largest differ number occurr 2 charact present string note two charact may may given string consist lowercas english letter return largest varianc possibl among substr substr contigu sequenc charact within string exampl 1 input aababbb output 3 explan possibl varianc along respect substr list varianc 0 substr aa ab abab aababb ba b bb bbb varianc 1 substr aab aba abb aabab ababb aababbb bab varianc 2 substr aaba ababbb abbb babb varianc 3 substr babbb sinc largest possibl varianc 3 return exampl 2 input abcd output 0 explan letter occur varianc everi substr 0 constraint 1 slength 104 consist lowercas english letter substringwithlargestvari
given array string num integ k string num repres integ without lead zero return string repres kth largest integ num note duplic number count distinctli exampl num 122 2 first largest integ 2 secondlargest integ 1 thirdlargest integ exampl 1 input num 36710 k 4 output 3 explan number num sort nondecreas order 36710 4th largest integ num 3 exampl 2 input num 221121 k 3 output 2 explan number num sort nondecreas order 121221 3rd largest integ num 2 exampl 3 input num 00 k 2 output 0 explan number num sort nondecreas order 00 2nd largest integ num 0 constraint 1 k numslength 104 1 numsilength 100 numsi consist digit numsi lead zero findthekthlargestintegerinthearray
cinema n row seat number 1 n ten seat row label 1 10 shown figur given array reservedseat contain number seat alreadi reserv exampl reservedseatsi 38 mean seat locat row 3 label 8 alreadi reserv return maximum number fourperson group assign cinema seat fourperson group occupi four adjac seat one singl row seat across aisl 33 34 consid adjac except case aisl split fourperson group case aisl split fourperson group middl mean two peopl side exampl 1 input n 3 reservedseat 1213182631310 output 4 explan figur show optim alloc four group seat mark blue alreadi reserv contigu seat mark orang one group exampl 2 input n 2 reservedseat 211826 output 2 exampl 3 input n 4 reservedseat 43144617 output 4 constraint 1 n 109 1 reservedseatslength min10n 104 reservedseatsilength 2 1 reservedseatsi0 n 1 reservedseatsi1 10 reservedseatsi distinct cinemaseatalloc
given 0index 2d integ array bracket bracketsi upperi percenti mean ith tax bracket upper bound upperi tax rate percenti bracket sort upper bound ie upperi1 upperi 0 bracketslength tax calcul follow first upper0 dollar earn tax rate percent0 next upper1 upper0 dollar earn tax rate percent1 next upper2 upper1 dollar earn tax rate percent2 given integ incom repres amount money earn return amount money pay tax answer within 105 actual answer accept exampl 1 input bracket 3507101225 incom 10 output 265000 explan base incom 3 dollar 1st tax bracket 4 dollar 2nd tax bracket 3 dollar 3rd tax bracket tax rate three tax bracket 50 10 25 respect total pay 3 50 4 10 3 25 265 tax exampl 2 input bracket 10425550 incom 2 output 025000 explan base incom 1 dollar 1st tax bracket 1 dollar 2nd tax bracket tax rate two tax bracket 0 25 respect total pay 1 0 1 25 025 tax exampl 3 input bracket 250 incom 0 output 000000 explan incom tax pay total 0 tax constraint 1 bracketslength 100 1 upperi 1000 0 percenti 100 0 incom 1000 upperi sort ascend order valu upperi uniqu upper bound last tax bracket greater equal incom calculateamountpaidintax
n citi number 0 n 1 n 1 road one way travel two differ citi network form tree last year ministri transport decid orient road one direct narrow road repres connect connectionsi ai bi repres road citi ai citi bi year big event capit citi 0 mani peopl want travel citi task consist reorient road citi visit citi 0 return minimum number edg chang guarante citi reach citi 0 reorder exampl 1 input n 6 connect 0113234045 output 3 explan chang direct edg show red node reach node 0 capit exampl 2 input n 5 connect 10123234 output 2 explan chang direct edg show red node reach node 0 capit exampl 3 input n 3 connect 1020 output 0 constraint 2 n 5 104 connectionslength n 1 connectionsilength 2 0 ai bi n 1 ai bi reorderroutestomakeallpathsleadtothecityzero
given n x n grid repres field cherri cell one three possibl integ 0 mean cell empti pass 1 mean cell contain cherri pick pass 1 mean cell contain thorn block way return maximum number cherri collect follow rule start posit 0 0 reach n 1 n 1 move right valid path cell cell valu 0 1 reach n 1 n 1 return 0 0 move left valid path cell pass path cell contain cherri pick cell becom empti cell 0 valid path 0 0 n 1 n 1 cherri collect exampl 1 input grid 011101111 output 5 explan player start 0 0 went right right reach 2 2 4 cherri pick singl trip matrix becom 011001000 player went left left return home pick one cherri total number cherri pick 5 maximum possibl exampl 2 input grid 111111111 output 0 constraint n gridlength n gridilength 1 n 50 gridij 1 0 1 grid00 1 gridn 1n 1 1 cherrypickup
given string titl consist one word separ singl space word consist english letter capit string chang capit word length word 1 2 letter chang letter lowercas otherwis chang first letter uppercas remain letter lowercas return capit titl exampl 1 input titl capit titl output capit titl explan sinc word length least 3 first letter word uppercas remain letter lowercas exampl 2 input titl first letter word output first letter word explan word length 2 lowercas remain word length least 3 first letter remain word uppercas remain letter lowercas exampl 3 input titl love leetcod output love leetcod explan word length 1 lowercas remain word length least 3 first letter remain word uppercas remain letter lowercas constraint 1 titlelength 100 titl consist word separ singl space without lead trail space word consist uppercas lowercas english letter nonempti capitalizethetitl
given string integ k return true use charact construct k palindrom string fals otherwis exampl 1 input annabel k 2 output true explan construct two palindrom use charact possibl construct anna elbl anbna ell anellena b exampl 2 input leetcod k 3 output fals explan imposs construct 3 palindrom use charact exampl 3 input true k 4 output true explan possibl solut put charact separ string constraint 1 slength 105 consist lowercas english letter 1 k 105 constructkpalindromestr
given integ array price pricesi price given stock ith day day may decid buy andor sell stock hold one share stock time howev buy immedi sell day find return maximum profit achiev exampl 1 input price 715364 output 7 explan buy day 2 price 1 sell day 3 price 5 profit 51 4 buy day 4 price 3 sell day 5 price 6 profit 63 3 total profit 4 3 7 exampl 2 input price 12345 output 4 explan buy day 1 price 1 sell day 5 price 5 profit 51 4 total profit 4 exampl 3 input price 76431 output 0 explan way make posit profit never buy stock achiev maximum profit 0 constraint 1 priceslength 3 104 0 pricesi 104 besttimetobuyandsellstockii
given function fn return new function ident origin function except ensur fn call first time return function call return result fn everi subsequ time call return undefin exampl 1 input fn abc b c call 123236 output calls1value6 explan const oncefn oncefn oncefn1 2 3 6 oncefn2 3 6 undefin fn call exampl 2 input fn abc b c call 574236468 output calls1value140 explan const oncefn oncefn oncefn5 7 4 140 oncefn2 3 6 undefin fn call oncefn4 6 8 undefin fn call constraint 1 callslength 10 1 callsilength 100 2 jsonstringifycallslength 1000 allowonefunctioncal
given integ array num two integ indexdiff valuediff find pair indic j j absi j indexdiff absnumsi numsj valuediff return true pair exist fals otherwis exampl 1 input num 1231 indexdiff 3 valuediff 0 output true explan choos j 0 3 satisfi three condit j 0 3 absi j indexdiff abs0 3 3 absnumsi numsj valuediff abs1 1 0 exampl 2 input num 159159 indexdiff 2 valuediff 3 output fals explan tri possibl pair j satisfi three condit return fals constraint 2 numslength 105 109 numsi 109 1 indexdiff numslength 0 valuediff 109 containsduplicateiii
given 0index array num length n distinct differ array num array diff length n diffi equal number distinct element suffix numsi 1 n 1 subtract number distinct element prefix nums0 return distinct differ array num note numsi j denot subarray num start index end index j inclus particularli j numsi j denot empti subarray exampl 1 input num 12345 output 31135 explan index 0 1 element prefix 4 distinct element suffix thu diff0 1 4 3 index 1 2 distinct element prefix 3 distinct element suffix thu diff1 2 3 1 index 2 3 distinct element prefix 2 distinct element suffix thu diff2 3 2 1 index 3 4 distinct element prefix 1 distinct element suffix thu diff3 4 1 3 index 4 5 distinct element prefix element suffix thu diff4 5 0 5 exampl 2 input num 32342 output 21023 explan index 0 1 element prefix 3 distinct element suffix thu diff0 1 3 2 index 1 2 distinct element prefix 3 distinct element suffix thu diff1 2 3 1 index 2 2 distinct element prefix 2 distinct element suffix thu diff2 2 2 0 index 3 3 distinct element prefix 1 distinct element suffix thu diff3 3 1 2 index 4 3 distinct element prefix element suffix thu diff4 3 0 3 constraint 1 n numslength 50 1 numsi 50 findthedistinctdifferencearray
given direct graph n node number 0 n 1 node one outgo edg graph repres given 0index array edg size n indic direct edg node node edgesi outgo edg edgesi 1 also given two integ node1 node2 return index node reach node1 node2 maximum distanc node1 node node2 node minim multipl answer return node smallest index possibl answer exist return 1 note edg may contain cycl exampl 1 input edg 2231 node1 0 node2 1 output 2 explan distanc node 0 node 2 1 distanc node 1 node 2 1 maximum two distanc 1 proven get node smaller maximum distanc 1 return node 2 exampl 2 input edg 121 node1 0 node2 2 output 2 explan distanc node 0 node 2 2 distanc node 2 0 maximum two distanc 2 proven get node smaller maximum distanc 2 return node 2 constraint n edgeslength 2 n 105 1 edgesi n edgesi 0 node1 node2 n findclosestnodetogiventwonod
test n type question given integ target 0index 2d integ array type typesi counti marksi indic counti question ith type one worth marksi point return number way earn exactli target point exam sinc answer may larg return modulo 109 7 note question type indistinguish exampl 3 question type solv 1st 2nd question solv 1st 3rd question 2nd 3rd question exampl 1 input target 6 type 613223 output 7 explan earn 6 point one seven way solv 6 question 0th type 1 1 1 1 1 1 6 solv 4 question 0th type 1 question 1st type 1 1 1 1 2 6 solv 2 question 0th type 2 question 1st type 1 1 2 2 6 solv 3 question 0th type 1 question 2nd type 1 1 1 3 6 solv 1 question 0th type 1 question 1st type 1 question 2nd type 1 2 3 6 solv 3 question 1st type 2 2 2 6 solv 2 question 2nd type 3 3 6 exampl 2 input target 5 type 501502505 output 4 explan earn 5 point one four way solv 5 question 0th type 1 1 1 1 1 5 solv 3 question 0th type 1 question 1st type 1 1 1 2 5 solv 1 question 0th type 2 question 1st type 1 2 2 5 solv 1 question 2nd type 5 exampl 3 input target 18 type 613223 output 1 explan earn 18 point answer question constraint 1 target 1000 n typeslength 1 n 50 typesilength 2 1 counti marksi 50 numberofwaystoearnpoint
given string return number uniqu palindrom length three subsequ note even multipl way obtain subsequ still count palindrom string read forward backward subsequ string new string gener origin string charact none delet without chang rel order remain charact exampl ace subsequ abcd exampl 1 input aabca output 3 explan 3 palindrom subsequ length 3 aba subsequ aabca aaa subsequ aabca aca subsequ aabca exampl 2 input adc output 0 explan palindrom subsequ length 3 adc exampl 3 input bbcbaba output 4 explan 4 palindrom subsequ length 3 bbb subsequ bbcbaba bcb subsequ bbcbaba bab subsequ bbcbaba aba subsequ bbcbaba constraint 3 slength 105 consist lowercas english letter uniquelength3palindromicsubsequ
given array digit sort nondecreas order write number use digitsi mani time want exampl digit 135 may write number 13 551 1351315 return number posit integ gener less equal given integ n exampl 1 input digit 1357 n 100 output 20 explan 20 number written 1 3 5 7 11 13 15 17 31 33 35 37 51 53 55 57 71 73 75 77 exampl 2 input digit 149 n 1000000000 output 29523 explan write 3 one digit number 9 two digit number 27 three digit number 81 four digit number 243 five digit number 729 six digit number 2187 seven digit number 6561 eight digit number 19683 nine digit number total 29523 integ written use digit array exampl 3 input digit 7 n 8 output 1 constraint 1 digitslength 9 digitsilength 1 digitsi digit 1 9 valu digit uniqu digit sort nondecreas order 1 n 109 numbersatmostngivendigitset
given 2d integ array group length n also given integ array num ask choos n disjoint subarray array num ith subarray equal groupsi 0index 0 i1th subarray appear ith subarray num ie subarray must order group return true task fals otherwis note subarray disjoint index k numsk belong one subarray subarray contigu sequenc element within array exampl 1 input group 111320 num 110111320 output true explan choos 0th subarray 110111320 1st one 110111320 subarray disjoint share common numsk element exampl 2 input group 1021234 num 1234102 output fals explan note choos subarray 1234102 1234102 incorrect order group 102 must come 1234 exampl 3 input group 12334 num 77123477 output fals explan note choos subarray 77123477 77123477 invalid disjoint share common element nums4 0index constraint groupslength n 1 n 103 1 groupsilength sumgroupsilength 103 1 numslength 103 107 groupsij numsk 107 formarraybyconcatenatingsubarraysofanotherarray
given array point xy plane point pointsi xi yi return minimum area rectangl form point side necessarili parallel x axe rectangl return 0 answer within 105 actual answer accept exampl 1 input point 12211001 output 200000 explan minimum area rectangl occur 12211001 area 2 exampl 2 input point 0121111020 output 100000 explan minimum area rectangl occur 10112120 area 1 exampl 3 input point 0312311321 output 0 explan possibl rectangl form point constraint 1 pointslength 50 pointsilength 2 0 xi yi 4 104 given point uniqu minimumarearectangleii
given list account element accountsi list string first element accountsi0 name rest element email repres email account would like merg account two account definit belong person common email account note even two account name may belong differ peopl peopl could name person number account initi account definit name merg account return account follow format first element account name rest element email sort order account return order exampl 1 input account johnjohnsmithmailcomjohnnewyorkmailcomjohnjohnsmithmailcomjohn00mailcommarymarymailcomjohnjohnnybravomailcom output johnjohn00mailcomjohnnewyorkmailcomjohnsmithmailcommarymarymailcomjohnjohnnybravomailcom explan first second john person common email johnsmithmailcom third john mari differ peopl none email address use account could return list order exampl answer mari marymailcom john johnnybravomailcom john john00mailcom johnnewyorkmailcom johnsmithmailcom would still accept exampl 2 input account gabegabe0mcogabe3mcogabe1mcokevinkevin3mcokevin5mcokevin0mcoethanethan5mcoethan4mcoethan0mcohanzohanzo3mcohanzo1mcohanzo0mcofernfern5mcofern1mcofern0mco output ethanethan0mcoethan4mcoethan5mcogabegabe0mcogabe1mcogabe3mcohanzohanzo0mcohanzo1mcohanzo3mcokevinkevin0mcokevin3mcokevin5mcofernfern0mcofern1mcofern5mco constraint 1 accountslength 1000 2 accountsilength 10 1 accountsijlength 30 accountsi0 consist english letter accountsij j 0 valid email accountsmerg
given two array integ nums1 nums2 possibl differ length valu array 1 6 inclus one oper chang integ valu array valu 1 6 inclus return minimum number oper requir make sum valu nums1 equal sum valu nums2 return 1 possibl make sum two array equal exampl 1 input nums1 123456 nums2 112222 output 3 explan make sum nums1 nums2 equal 3 oper indic 0index chang nums20 6 nums1 123456 nums2 612222 chang nums15 1 nums1 123451 nums2 612222 chang nums12 2 nums1 122451 nums2 612222 exampl 2 input nums1 1111111 nums2 6 output 1 explan way decreas sum nums1 increas sum nums2 make equal exampl 3 input nums1 66 nums2 1 output 3 explan make sum nums1 nums2 equal 3 oper indic 0index chang nums10 2 nums1 26 nums2 1 chang nums11 2 nums1 22 nums2 1 chang nums20 4 nums1 22 nums2 4 constraint 1 nums1length nums2length 105 1 nums1i nums2i 6 equalsumarrayswithminimumnumberofoper
given two 2d integ array items1 items2 repres two set item array item follow properti itemsi valuei weighti valuei repres valu weighti repres weight ith item valu item item uniqu return 2d integ array ret reti valuei weighti weighti sum weight item valu valuei note ret return ascend order valu exampl 1 input items1 114538 items2 3115 output 163945 explan item valu 1 occur items1 weight 1 items2 weight 5 total weight 1 5 6 item valu 3 occur items1 weight 8 items2 weight 1 total weight 8 1 9 item valu 4 occur items1 weight 5 total weight 5 therefor return 163945 exampl 2 input items1 113223 items2 213213 output 142434 explan item valu 1 occur items1 weight 1 items2 weight 3 total weight 1 3 4 item valu 2 occur items1 weight 3 items2 weight 1 total weight 3 1 4 item valu 3 occur items1 weight 2 items2 weight 2 total weight 2 2 4 therefor return 142434 exampl 3 input items1 1322 items2 712214 output 172471 explan item valu 1 occur items1 weight 3 items2 weight 4 total weight 3 4 7 item valu 2 occur items1 weight 2 items2 weight 2 total weight 2 2 4 item valu 7 occur items2 weight 1 total weight 1 therefor return 172471 constraint 1 items1length items2length 1000 items1ilength items2ilength 2 1 valuei weighti 1000 valuei items1 uniqu valuei items2 uniqu mergesimilaritem
given array integ arr three integ b c need find number good triplet triplet arri arrj arrk good follow condit true 0 j k arrlength arri arrj arrj arrk b arri arrk c x denot absolut valu x return number good triplet exampl 1 input arr 301197 7 b 2 c 3 output 4 explan 4 good triplet 301 301 311 011 exampl 2 input arr 11223 0 b 0 c 1 output 0 explan triplet satisfi condit constraint 3 arrlength 100 0 arri 1000 0 b c 1000 countgoodtriplet
given integ array num return number subarray fill 0 subarray contigu nonempti sequenc element within array exampl 1 input num 13002004 output 6 explan 4 occurr 0 subarray 2 occurr 00 subarray occurr subarray size 2 fill 0 therefor return 6 exampl 2 input num 000200 output 9 explan 5 occurr 0 subarray 3 occurr 00 subarray 1 occurr 000 subarray occurr subarray size 3 fill 0 therefor return 9 exampl 3 input num 2102019 output 0 explan subarray fill 0 therefor return 0 constraint 1 numslength 105 109 numsi 109 numberofzerofilledsubarray
given string form digit want map english lowercas charact follow charact repres 1 9 respect charact j z repres 10 26 respect return string form map test case gener uniqu map alway exist exampl 1 input 101112 output jkab explan j 10 k 11 1 b 2 exampl 2 input 1326 output acz constraint 1 slength 1000 consist digit letter valid string map alway possibl decryptstringfromalphabettointegermap
given root binari tree determin valid binari search tree bst valid bst defin follow left subtre node contain node key less node key right subtre node contain node key greater node key left right subtre must also binari search tree exampl 1 input root 213 output true exampl 2 input root 514nullnull36 output fals explan root node valu 5 right child valu 4 constraint number node tree rang 1 104 231 nodev 231 1 validatebinarysearchtre
given array num consist posit integ call subarray num nice bitwis everi pair element differ posit subarray equal 0 return length longest nice subarray subarray contigu part array note subarray length 1 alway consid nice exampl 1 input num 1384810 output 3 explan longest nice subarray 3848 subarray satisfi condit 3 8 0 3 48 0 8 48 0 proven longer nice subarray obtain return 3 exampl 2 input num 3151113 output 1 explan length longest nice subarray 1 subarray length 1 chosen constraint 1 numslength 105 1 numsi 109 longestnicesubarray
n comput number 0 n 1 connect ethernet cabl connect form network connectionsi ai bi repres connect comput ai bi comput reach comput directli indirectli network given initi comput network connect extract certain cabl two directli connect comput place pair disconnect comput make directli connect return minimum number time need order make comput connect possibl return 1 exampl 1 input n 4 connect 010212 output 1 explan remov cabl comput 1 2 place comput 1 3 exampl 2 input n 6 connect 0102031213 output 2 exampl 3 input n 6 connect 01020312 output 1 explan enough cabl constraint 1 n 105 1 connectionslength minn n 1 2 105 connectionsilength 2 0 ai bi n ai bi repeat connect two comput connect one cabl numberofoperationstomakenetworkconnect
given array uniqu integ salari salaryi salari ith employe return averag salari employe exclud minimum maximum salari answer within 105 actual answer accept exampl 1 input salari 4000300010002000 output 250000000 explan minimum salari maximum salari 1000 4000 respect averag salari exclud minimum maximum salari 20003000 2 2500 exampl 2 input salari 100020003000 output 200000000 explan minimum salari maximum salari 1000 3000 respect averag salari exclud minimum maximum salari 2000 1 2000 constraint 3 salarylength 100 1000 salaryi 106 integ salari uniqu averagesalaryexcludingtheminimumandmaximumsalari
given two array rowsum colsum nonneg integ rowsumi sum element ith row colsumj sum element jth column 2d matrix word know element matrix know sum row column find matrix nonneg integ size rowsumlength x colsumlength satisfi rowsum colsum requir return 2d array repres matrix fulfil requir guarante least one matrix fulfil requir exist exampl 1 input rowsum 38 colsum 47 output 30 17 explan 0th row 3 0 3 rowsum0 1st row 1 7 8 rowsum1 0th column 3 1 4 colsum0 1st column 0 7 7 colsum1 row column sum match matrix element nonneg anoth possibl matrix 12 35 exampl 2 input rowsum 5710 colsum 868 output 050 610 208 constraint 1 rowsumlength colsumlength 500 0 rowsumi colsumi 108 sumrowsum sumcolsum findvalidmatrixgivenrowandcolumnsum
string compos l r x charact like rxxlrxrxl move consist either replac one occurr xl lx replac one occurr rx xr given start string start end string end return true exist sequenc move transform one string exampl 1 input start rxxlrxrxl end xrlxxrrlx output true explan transform start end follow step rxxlrxrxl xrxlrxrxl xrlxrxrxl xrlxxrrxl xrlxxrrlx exampl 2 input start x end l output fals constraint 1 startlength 104 startlength endlength start end consist charact l r x swapadjacentinlrstr
given four integ row col rcenter ccenter row x col matrix cell coordin rcenter ccenter return coordin cell matrix sort distanc rcenter ccenter smallest distanc largest distanc may return answer order satisfi condit distanc two cell r1 c1 r2 c2 r1 r2 c1 c2 exampl 1 input row 1 col 2 rcenter 0 ccenter 0 output 0001 explan distanc 0 0 cell 01 exampl 2 input row 2 col 2 rcenter 0 ccenter 1 output 01001110 explan distanc 0 1 cell 0112 answer 01110010 would also accept correct exampl 3 input row 2 col 3 rcenter 1 ccenter 2 output 120211011000 explan distanc 1 2 cell 011223 answer would also accept correct 121102100100 constraint 1 row col 100 0 rcenter row 0 ccenter col matrixcellsindistanceord
design park system park lot park lot three kind park space big medium small fix number slot size implement parkingsystem class parkingsystemint big int medium int small initi object parkingsystem class number slot park space given part constructor bool addcarint cartyp check whether park space cartyp car want get park lot cartyp three kind big medium small repres 1 2 3 respect car park park space cartyp space avail return fals els park car size space return true exampl 1 input parkingsystem addcar addcar addcar addcar 1 1 0 1 2 3 1 output null true true fals fals explan parkingsystem parkingsystem new parkingsystem1 1 0 parkingsystemaddcar1 return true 1 avail slot big car parkingsystemaddcar2 return true 1 avail slot medium car parkingsystemaddcar3 return fals avail slot small car parkingsystemaddcar1 return fals avail slot big car alreadi occupi constraint 0 big medium small 1000 cartyp 1 2 3 1000 call made addcar designparkingsystem
given two integ num1 num2 return sum two integ exampl 1 input num1 12 num2 5 output 17 explan num1 12 num2 5 sum 12 5 17 17 return exampl 2 input num1 10 num2 4 output 6 explan num1 num2 6 6 return constraint 100 num1 num2 100 addtwointeg
given 0index integ array num two integ low high return number nice pair nice pair pair j 0 j numslength low numsi xor numsj high exampl 1 input num 1427 low 2 high 6 output 6 explan nice pair j follow 0 1 nums0 xor nums1 5 0 2 nums0 xor nums2 3 0 3 nums0 xor nums3 6 1 2 nums1 xor nums2 6 1 3 nums1 xor nums3 3 2 3 nums2 xor nums3 5 exampl 2 input num 98421 low 5 high 14 output 8 explan nice pair j follow 0 2 nums0 xor nums2 13 0 3 nums0 xor nums3 11 0 4 nums0 xor nums4 8 1 2 nums1 xor nums2 12 1 3 nums1 xor nums3 10 1 4 nums1 xor nums4 9 2 3 nums2 xor nums3 6 2 4 nums2 xor nums4 5 constraint 1 numslength 2 104 1 numsi 2 104 1 low high 2 104 countpairswithxorinarang
given root node refer bst key delet node given key bst return root node refer possibl updat bst basic delet divid two stage search node remov node found delet node exampl 1 input root 53624null7 key 3 output 5462nullnull7 explan given key delet 3 find node valu 3 delet one valid answer 5462nullnull7 shown bst pleas notic anoth valid answer 526null4null7 also accept exampl 2 input root 53624null7 key 0 output 53624null7 explan tree contain node valu 0 exampl 3 input root key 0 output constraint number node tree rang 0 104 105 nodev 105 node uniqu valu root valid binari search tree 105 key 105 follow could solv time complex oheight tree deletenodeinabst
set n item given two integ array valu label valu label ith element valuesi labelsi respect also given two integ numwant uselimit choos subset n element size subset less equal numwant uselimit item label score subset sum valu subset return maximum score subset exampl 1 input valu 54321 label 11223 numwant 3 uselimit 1 output 9 explan subset chosen first third fifth item exampl 2 input valu 54321 label 13332 numwant 3 uselimit 2 output 12 explan subset chosen first second third item exampl 3 input valu 98876 label 00011 numwant 3 uselimit 1 output 16 explan subset chosen first fourth item constraint n valueslength labelslength 1 n 2 104 0 valuesi labelsi 2 104 1 numwant uselimit n largestvaluesfromlabel
given root binari tree uniqu valu one oper choos two node level swap valu return minimum number oper need make valu level sort strictli increas order level node number edg along path root node exampl 1 input root 1437685nullnullnullnull9null10 output 3 explan swap 4 3 2nd level becom 34 swap 7 5 3rd level becom 5687 swap 8 7 3rd level becom 5678 use 3 oper return 3 proven 3 minimum number oper need exampl 2 input root 1327654 output 3 explan swap 3 2 2nd level becom 23 swap 7 4 3rd level becom 4657 swap 6 5 3rd level becom 4567 use 3 oper return 3 proven 3 minimum number oper need exampl 3 input root 123456 output 0 explan level alreadi sort increas order return 0 constraint number node tree rang 1 105 1 nodev 105 valu tree uniqu minimumnumberofoperationstosortabinarytreebylevel
design hashmap without use builtin hash tabl librari implement myhashmap class myhashmap initi object empti map void putint key int valu insert key valu pair hashmap key alreadi exist map updat correspond valu int getint key return valu specifi key map 1 map contain map key void removekey remov key correspond valu map contain map key exampl 1 input myhashmap put put get get put get remov get 1 1 2 2 1 3 2 1 2 2 2 output null null null 1 1 null 1 null 1 explan myhashmap myhashmap new myhashmap myhashmapput1 1 map 11 myhashmapput2 2 map 11 22 myhashmapget1 return 1 map 11 22 myhashmapget3 return 1 ie found map 11 22 myhashmapput2 1 map 11 21 ie updat exist valu myhashmapget2 return 1 map 11 21 myhashmapremove2 remov map 2 map 11 myhashmapget2 return 1 ie found map 11 constraint 0 key valu 106 104 call made put get remov designhashmap
given array string word integ k return k frequent string return answer sort frequenc highest lowest sort word frequenc lexicograph order exampl 1 input word iloveleetcodeilovecod k 2 output ilov explan love two frequent word note come love due lower alphabet order exampl 2 input word thedayissunnythethethesunnyisi k 4 output theissunnyday explan sunni day four frequent word number occurr 4 3 2 1 respect constraint 1 wordslength 500 1 wordsilength 10 wordsi consist lowercas english letter k rang 1 number uniqu wordsi followup could solv logk time extra space topkfrequentword
given array task tasksi actuali minimumi actuali actual amount energi spend finish ith task minimumi minimum amount energi requir begin ith task exampl task 10 12 current energi 11 start task howev current energi 13 complet task energi 3 finish finish task order like return minimum initi amount energi need finish task exampl 1 input task 122448 output 8 explan start 8 energi finish task follow order 3rd task energi 8 4 4 2nd task energi 4 2 2 1st task energi 2 1 1 notic even though leftov energi start 7 energi work 3rd task exampl 2 input task 13241011101289 output 32 explan start 32 energi finish task follow order 1st task energi 32 1 31 2nd task energi 31 2 29 3rd task energi 29 10 19 4th task energi 19 10 9 5th task energi 9 8 1 exampl 3 input task 172839410511612 output 27 explan start 27 energi finish task follow order 5th task energi 27 5 22 2nd task energi 22 2 20 3rd task energi 20 3 17 1st task energi 17 1 16 4th task energi 16 4 12 6th task energi 12 6 6 constraint 1 taskslength 105 1 actuali minimumi 104 minimuminitialenergytofinishtask
given string contain digit 29 inclus return possibl letter combin number could repres return answer order map digit letter like telephon button given note 1 map letter exampl 1 input digit 23 output adaeafbdbebfcdcecf exampl 2 input digit output exampl 3 input digit 2 output abc constraint 0 digitslength 4 digitsi digit rang 2 9 lettercombinationsofaphonenumb
given integ array num size n return number valu closest 0 num multipl answer return number largest valu exampl 1 input num 42148 output 1 explan distanc 4 0 4 4 distanc 2 0 2 2 distanc 1 0 1 1 distanc 4 0 4 4 distanc 8 0 8 8 thu closest number 0 array 1 exampl 2 input num 211 output 1 explan 1 1 closest number 0 1 larger return constraint 1 n 1000 105 numsi 105 findclosestnumbertozero
given 0index integ array num one oper select nonneg integ x index updat numsi equal numsi numsi xor x note bitwis oper xor bitwis xor oper return maximum possibl bitwis xor element num appli oper number time exampl 1 input num 3246 output 7 explan appli oper x 4 3 num3 6 6 xor 4 6 2 2 num 3 2 4 2 bitwis xor element 3 xor 2 xor 4 xor 2 7 shown 7 maximum possibl bitwis xor note oper may use achiev bitwis xor 7 exampl 2 input num 12392 output 11 explan appli oper zero time bitwis xor element 1 xor 2 xor 3 xor 9 xor 2 11 shown 11 maximum possibl bitwis xor constraint 1 numslength 105 0 numsi 108 maximumxorafteroper
given 0index integ array num return smallest index num mod 10 numsi 1 index exist x mod denot remaind x divid exampl 1 input num 012 output 0 explan i0 0 mod 10 0 nums0 i1 1 mod 10 1 nums1 i2 2 mod 10 2 nums2 indic mod 10 numsi return smallest index 0 exampl 2 input num 4321 output 2 explan i0 0 mod 10 0 nums0 i1 1 mod 10 1 nums1 i2 2 mod 10 2 nums2 i3 3 mod 10 3 nums3 2 index mod 10 numsi exampl 3 input num 1234567890 output 1 explan index satisfi mod 10 numsi constraint 1 numslength 100 0 numsi 9 smallestindexwithequalvalu
given array integ num sort array ascend order return must solv problem without use builtin function onlogn time complex smallest space complex possibl exampl 1 input num 5231 output 1235 explan sort array posit number chang exampl 2 3 posit number chang exampl 1 5 exampl 2 input num 511200 output 001125 explan note valu num necessairli uniqu constraint 1 numslength 5 104 5 104 numsi 5 104 sortanarray
given integ array instruct ask creat sort array element instruct start empti contain num element left right instruct insert num cost insert minimum follow number element current num strictli less instructionsi number element current num strictli greater instructionsi exampl insert element 3 num 1235 cost insert min2 1 element 1 2 less 3 element 5 greater 3 num becom 12335 return total cost insert element instruct num sinc answer may larg return modulo 109 7 exampl 1 input instruct 1562 output 1 explan begin num insert 1 cost min0 0 0 num 1 insert 5 cost min1 0 0 num 15 insert 6 cost min2 0 0 num 156 insert 2 cost min1 2 1 num 1256 total cost 0 0 0 1 1 exampl 2 input instruct 123654 output 3 explan begin num insert 1 cost min0 0 0 num 1 insert 2 cost min1 0 0 num 12 insert 3 cost min2 0 0 num 123 insert 6 cost min3 0 0 num 1236 insert 5 cost min3 1 1 num 12356 insert 4 cost min3 2 2 num 123456 total cost 0 0 0 0 1 2 3 exampl 3 input instruct 133324212 output 4 explan begin num insert 1 cost min0 0 0 num 1 insert 3 cost min1 0 0 num 13 insert 3 cost min1 0 0 num 133 insert 3 cost min1 0 0 num 1333 insert 2 cost min1 3 1 num 12333 insert 4 cost min5 0 0 num 123334 insert 2 cost min1 4 1 num 1223334 insert 1 cost min0 6 0 num 11223334 insert 2 cost min2 4 2 num 112223334 total cost 0 0 0 0 1 0 1 0 2 4 constraint 1 instructionslength 105 1 instructionsi 105 createsortedarraythroughinstruct
given 0index array posit integ num find number triplet j k meet follow condit 0 j k numslength numsi numsj numsk pairwis distinct word numsi numsj numsi numsk numsj numsk return number triplet meet condit exampl 1 input num 44243 output 3 explan follow triplet meet condit 0 2 4 4 2 3 1 2 4 4 2 3 2 3 4 2 4 3 sinc 3 triplet return 3 note 2 0 4 valid triplet 2 0 exampl 2 input num 11111 output 0 explan triplet meet condit return 0 constraint 3 numslength 100 1 numsi 1000 numberofunequaltripletsinarray
sql schema pandan schema tabl activ column name type playerid int deviceid int eventd date gamesplay int sql playerid eventd primari key tabl tabl show activ player game row record player log play number game possibl 0 log someday use devic find first login date player return result tabl order result format follow exampl exampl 1 input activ tabl playerid deviceid eventd gamesplay 1 2 20160301 5 1 2 20160502 6 2 3 20170625 1 3 1 20160302 0 3 4 20180703 5 output playerid firstlogin 1 20160301 2 20170625 3 20160302 gameplayanalysisi
given array posit integ num want eras subarray contain uniqu element score get eras subarray equal sum element return maximum score get eras exactli one subarray array b call subarray form contigu subsequ equal alal1ar lr exampl 1 input num 42456 output 17 explan optim subarray 2456 exampl 2 input num 521252125 output 8 explan optim subarray 521 125 constraint 1 numslength 105 1 numsi 104 maximumerasurevalu
suppos file system store file directori exampl one system repres follow pictur dir directori root dir contain two subdirectori subdir1 subdir2 subdir1 contain file file1ext subdirectori subsubdir1 subdir2 contain subdirectori subsubdir2 contain file file2ext text form look like ⟶ repres tab charact dir ⟶ subdir1 ⟶ ⟶ file1ext ⟶ ⟶ subsubdir1 ⟶ subdir2 ⟶ ⟶ subsubdir2 ⟶ ⟶ ⟶ file2ext write represent code look like dirntsubdir1nttfile1extnttsubsubdir1ntsubdir2nttsubsubdir2ntttfile2ext note n newlin tab charact everi file directori uniqu absolut path file system order directori must open reach filedirectori concaten use exampl absolut path file2ext dirsubdir2subsubdir2file2ext directori name consist letter digit andor space file name form nameextens name extens consist letter digit andor space given string input repres file system explain format return length longest absolut path file abstract file system file system return 0 note testcas gener file system valid file directori name length 0 exampl 1 input input dirntsubdir1ntsubdir2nttfileext output 20 explan one file absolut path dirsubdir2fileext length 20 exampl 2 input input dirntsubdir1nttfile1extnttsubsubdir1ntsubdir2nttsubsubdir2ntttfile2ext output 32 explan two file dirsubdir1file1ext length 21 dirsubdir2subsubdir2file2ext length 32 return 32 sinc longest absolut path file exampl 3 input input output 0 explan file singl directori name constraint 1 inputlength 104 input may contain lowercas uppercas english letter new line charact n tab charact dot space digit file directori name posit length longestabsolutefilepath
given string two integ x perform two type oper number time remov substr ab gain x point exampl remov ab cabxba becom cxbae remov substr ba gain point exampl remov ba cabxba becom cabx return maximum point gain appli oper exampl 1 input cdbcbbaaabab x 4 5 output 19 explan remov ba underlin cdbcbbaaabab cdbcbbaaab 5 point ad score remov ab underlin cdbcbbaaab cdbcbbaa 4 point ad score remov ba underlin cdbcbbaa cdbcba 5 point ad score remov ba underlin cdbcba cdbc 5 point ad score total score 5 4 5 5 19 exampl 2 input aabbaaxybbaabb x 5 4 output 20 constraint 1 slength 105 1 x 104 consist lowercas english letter maximumscorefromremovingsubstr
given root binari tree two integ val depth add row node valu val given depth depth note root node depth 1 ad rule given integ depth null tree node cur depth depth 1 creat two tree node valu val cur left subtre root right subtre root cur origin left subtre left subtre new left subtre root cur origin right subtre right subtre new right subtre root depth 1 mean depth depth 1 creat tree node valu val new root whole origin tree origin tree new root left subtre exampl 1 input root 426315 val 1 depth 2 output 4112nullnull6315 exampl 2 input root 42null31 val 1 depth 3 output 42null113nullnull1 constraint number node tree rang 1 104 depth tree rang 1 104 100 nodev 100 105 val 105 1 depth depth tree 1 addonerowtotre
given 0index string hamster hamstersi either h indic hamster index indic index empti add number food bucket empti indic order feed hamster hamster fed least one food bucket left right formal hamster index fed place food bucket index 1 andor index 1 return minimum number food bucket place empti indic feed hamster 1 imposs feed exampl 1 input hamster hh output 2 explan place two food bucket indic 1 2 shown place one food bucket one hamster fed exampl 2 input hamster hh output 1 explan place one food bucket index 2 exampl 3 input hamster hhh output 1 explan place food bucket everi empti index shown hamster index 2 abl eat constraint 1 hamsterslength 105 hamstersi eitherh minimumnumberoffoodbucketstofeedthehamst
given 0index string consist digit 0 9 string call semirepetit one consecut pair digit insid exampl 0010 002020 0123 2002 54944 semirepetit 00101022 1101234883 return length longest semirepetit substr insid substr contigu nonempti sequenc charact within string exampl 1 input 52233 output 4 explan longest semirepetit substr 5223 start 0 end j 3 exampl 2 input 5494 output 4 explan semireptit string answer 4 exampl 3 input 1111111 output 2 explan longest semirepetit substr 11 start 0 end j 1 constraint 1 slength 50 0 si 9 findthelongestsemirepetitivesubstr
given 0index strictli increas integ array num posit integ diff triplet j k arithmet triplet follow condit met j k numsj numsi diff numsk numsj diff return number uniqu arithmet triplet exampl 1 input num 0146710 diff 3 output 2 explan 1 2 4 arithmet triplet 7 4 3 4 1 3 2 4 5 arithmet triplet 10 7 3 7 4 3 exampl 2 input num 456789 diff 2 output 2 explan 0 2 4 arithmet triplet 8 6 2 6 4 2 1 3 5 arithmet triplet 9 7 2 7 5 2 constraint 3 numslength 200 0 numsi 200 1 diff 50 num strictli increas numberofarithmetictriplet
given array favoritecompani favoritecompaniesi list favorit compani ith person index 0 return indic peopl whose list favorit compani subset list favorit compani must return indic increas order exampl 1 input favoritecompani leetcodegooglefacebookgooglemicrosoftgooglefacebookgoogleamazon output 014 explan person index2 favoritecompanies2googlefacebook subset favoritecompanies0leetcodegooglefacebook correspond person index 0 person index3 favoritecompanies3googl subset favoritecompanies0leetcodegooglefacebook favoritecompanies1googlemicrosoft list favorit compani subset anoth list therefor answer 014 exampl 2 input favoritecompani leetcodegooglefacebookleetcodeamazonfacebookgoogl output 01 explan case favoritecompanies2facebookgoogl subset favoritecompanies0leetcodegooglefacebook therefor answer 01 exampl 3 input favoritecompani leetcodegooglefacebookamazon output 0123 constraint 1 favoritecompanieslength 100 1 favoritecompaniesilength 500 1 favoritecompaniesijlength 20 string favoritecompaniesi distinct list favorit compani distinct sort alphabet list favoritecompaniesi favoritecompaniesj string consist lowercas english letter peoplewhoselistoffavoritecompaniesisnotasubsetofanotherlist
given binari represent integ string return number step reduc 1 follow rule current number even divid 2 current number odd add 1 guarante alway reach one test case exampl 1 input 1101 output 6 explan 1101 corresspond number 13 decim represent step 1 13 odd add 1 obtain 14 step 2 14 even divid 2 obtain 7 step 3 7 odd add 1 obtain 8 step 4 8 even divid 2 obtain 4 step 5 4 even divid 2 obtain 2 step 6 2 even divid 2 obtain 1 exampl 2 input 10 output 1 explan 10 corresspond number 2 decim represent step 1 2 even divid 2 obtain 1 exampl 3 input 1 output 0 constraint 1 slength 500 consist charact 0 1 s0 1 numberofstepstoreduceanumberinbinaryrepresentationtoon
given root binari tree return bottomup level order travers node valu ie left right level level leaf root exampl 1 input root 3920nullnull157 output 1579203 exampl 2 input root 1 output 1 exampl 3 input root output constraint number node tree rang 0 2000 1000 nodev 1000 binarytreelevelordertraversalii
alic bob take turn play game alic start first n stone pile player turn remov stone pile receiv point base stone valu alic bob may valu stone differ given two integ array length n alicevalu bobvalu alicevaluesi bobvaluesi repres alic bob respect valu ith stone winner person point stone chosen player amount point game result draw player play optim player know other valu determin result game alic win return 1 bob win return 1 game result draw return 0 exampl 1 input alicevalu 13 bobvalu 21 output 1 explan alic take stone 1 0index first alic receiv 3 point bob choos stone 0 receiv 2 point alic win exampl 2 input alicevalu 12 bobvalu 31 output 0 explan alic take stone 0 bob take stone 1 1 point draw exampl 3 input alicevalu 243 bobvalu 167 output 1 explan regardless alic play bob abl point alic exampl alic take stone 1 bob take stone 2 alic take stone 0 alic 6 point bob 7 bob win constraint n alicevalueslength bobvalueslength 1 n 105 1 alicevaluesi bobvaluesi 100 stonegamevi
given array nonneg integ num integ k one oper may choos element num increment 1 return maximum product num k oper sinc answer may larg return modulo 109 7 note maxim product take modulo exampl 1 input num 04 k 5 output 20 explan increment first number 5 time num 5 4 product 5 4 20 shown 20 maximum product possibl return 20 note may way increment num maximum product exampl 2 input num 6332 k 2 output 216 explan increment second number 1 time increment fourth number 1 time num 6 4 3 3 product 6 4 3 3 216 shown 216 maximum product possibl return 216 note may way increment num maximum product constraint 1 numslength k 105 0 numsi 106 maximumproductafterkincr
would like make dessert prepar buy ingredi n ice cream base flavor type top choos must follow rule make dessert must exactli one ice cream base add one type top top two type top given three input basecost integ array length n basecostsi repres price ith ice cream base flavor toppingcost integ array length toppingcostsi price one ith top target integ repres target price dessert want make dessert total cost close target possibl return closest possibl cost dessert target multipl return lower one exampl 1 input basecost 17 toppingcost 34 target 10 output 10 explan consid follow combin 0index choos base 1 cost 7 take 1 top 0 cost 1 x 3 3 take 0 top 1 cost 0 x 4 0 total 7 3 0 10 exampl 2 input basecost 23 toppingcost 45100 target 18 output 17 explan consid follow combin 0index choos base 1 cost 3 take 1 top 0 cost 1 x 4 4 take 2 top 1 cost 2 x 5 10 take 0 top 2 cost 0 x 100 0 total 3 4 10 0 17 make dessert total cost 18 exampl 3 input basecost 310 toppingcost 25 target 9 output 8 explan possibl make dessert cost 8 10 return 8 lower cost constraint n basecostslength toppingcostslength 1 n 10 1 basecostsi toppingcostsi 104 1 target 104 closestdessertcost
n ring ring either red green blue ring distribut across ten rod label 0 9 given string ring length 2n describ n ring place onto rod everi two charact ring form colorposit pair use describ ring first charact ith pair denot ith ring color r g b second charact ith pair denot rod ith ring place 0 9 exampl r3g2b1 describ n 3 ring red ring place onto rod label 3 green ring place onto rod label 2 blue ring place onto rod label 1 return number rod three color ring exampl 1 input ring b0b6g0r6r0r6g9 output 1 explan rod label 0 hold 3 ring color red green blue rod label 6 hold 3 ring red blue rod label 9 hold green ring thu number rod three color 1 exampl 2 input ring b0r0g0r9r0b0g0 output 1 explan rod label 0 hold 6 ring color red green blue rod label 9 hold red ring thu number rod three color 1 exampl 3 input ring g4 output 0 explan one ring given thu rod three color constraint ringslength 2 n 1 n 100 ringsi even either r g b 0index ringsi odd digit 0 9 0index ringsandrod
given integ array num 2 n integ need partit num two array length n minim absolut differ sum array partit num put element num one two array return minimum possibl absolut differ exampl 1 input num 3973 output 2 explan one optim partit 39 73 absolut differ sum array abs3 9 7 3 2 exampl 2 input num 3636 output 72 explan one optim partit 36 36 absolut differ sum array abs36 36 72 exampl 3 input num 210429 output 0 explan one optim partit 249 102 absolut differ sum array abs2 4 9 1 0 2 0 constraint 1 n 15 numslength 2 n 107 numsi 107 partitionarrayintotwoarraystominimizesumdiffer
special kind appl tree grow appl everi day n day ith day tree grow applesi appl rot daysi day day daysi appl rotten eaten day appl tree grow appl denot applesi 0 daysi 0 decid eat one appl day keep doctor away note keep eat first n day given two integ array day appl length n return maximum number appl eat exampl 1 input appl 12352 day 32142 output 7 explan eat 7 appl first day eat appl grew first day second day eat appl grew second day third day eat appl grew second day day appl grew third day rot fourth seventh day eat appl grew fourth day exampl 2 input appl 300002 day 300002 output 5 explan eat 5 appl first third day eat appl grew first day noth fouth fifth day sixth seventh day eat appl grew sixth day constraint n appleslength dayslength 1 n 2 104 0 applesi daysi 2 104 daysi 0 applesi 0 maximumnumberofeatenappl
implement snapshotarray support follow interfac snapshotarrayint length initi arraylik data structur given length initi element equal 0 void setindex val set element given index equal val int snap take snapshot array return snapid total number time call snap minu 1 int getindex snapid return valu given index time took snapshot given snapid exampl 1 input snapshotarraysetsnapsetget 3050600 output nullnull0null5 explan snapshotarray snapshotarr new snapshotarray3 set length 3 snapshotarrset05 set array0 5 snapshotarrsnap take snapshot return snapid 0 snapshotarrset06 snapshotarrget00 get valu array0 snapid 0 return 5 constraint 1 length 5 104 0 index length 0 val 109 0 snapid total number time call snap 5 104 call made set snap get snapshotarray
given integ array num may contain duplic return possibl subset power set solut set must contain duplic subset return solut order exampl 1 input num 122 output 112122222 exampl 2 input num 0 output 0 constraint 1 numslength 10 10 numsi 10 subsetsii
write function createcount accept initi integ init return object three function three function increment increas current valu 1 return decrement reduc current valu 1 return reset set current valu init return exampl 1 input init 5 call incrementresetdecr output 654 explan const counter createcounter5 counterincr 6 counterreset 5 counterdecr 4 exampl 2 input init 0 call incrementincrementdecrementresetreset output 12100 explan const counter createcounter0 counterincr 1 counterincr 2 counterdecr 1 counterreset 0 counterreset 0 constraint 1000 init 1000 total call exceed 1000 counterii
use runlength encod ie rle encod sequenc integ runlength encod array even length encod 0index even encodingi tell us number time nonneg integ valu encodingi 1 repeat sequenc exampl sequenc arr 88855 encod encod 3825 encod 380925 encod 281825 also valid rle arr given runlength encod array design iter iter implement rleiter class rleiteratorint encod initi object encod array encod int nextint n exhaust next n element return last element exhaust way element left exhaust return 1 instead exampl 1 input rleiter next next next next 3 8 0 9 2 5 2 1 1 2 output null 8 8 5 1 explan rleiter rleiter new rleiterator3 8 0 9 2 5 map sequenc 88855 rleiteratornext2 exhaust 2 term sequenc return 8 remain sequenc 8 5 5 rleiteratornext1 exhaust 1 term sequenc return 8 remain sequenc 5 5 rleiteratornext1 exhaust 1 term sequenc return 5 remain sequenc 5 rleiteratornext2 exhaust 2 term return 1 first term exhaust 5 second term exist sinc last term exhaust exist return 1 constraint 2 encodinglength 1000 encodinglength even 0 encodingi 109 1 n 109 1000 call made next rleiter
given 0index integ array num length n number way partit num number pivot indic satisfi condit 1 pivot n nums0 nums1 numspivot 1 numspivot numspivot 1 numsn 1 also given integ k choos chang valu one element num k leav array unchang return maximum possibl number way partit num satisfi condit chang one element exampl 1 input num 212 k 3 output 1 explan one optim approach chang nums0 k array becom 312 one way partit array pivot 2 partit 31 2 3 1 2 exampl 2 input num 000 k 1 output 2 explan optim approach leav array unchang two way partit array pivot 1 partit 0 00 0 0 0 pivot 2 partit 00 0 0 0 0 exampl 3 input num 22425201515167191001314 k 33 output 4 explan one optim approach chang nums2 k array becom 22433201515167191001314 four way partit array constraint n numslength 2 n 105 105 k numsi 105 maximumnumberofwaystopartitionanarray
given two integ array starttim endtim given integ querytim ith student start homework time starttimei finish time endtimei return number student homework time querytim formal return number student querytim lay interv starttimei endtimei inclus exampl 1 input starttim 123 endtim 327 querytim 4 output 1 explan 3 student first student start homework time 1 finish time 3 wasnt anyth time 4 second student start homework time 2 finish time 2 also wasnt anyth time 4 third student start homework time 3 finish time 7 student homework time 4 exampl 2 input starttim 4 endtim 4 querytim 4 output 1 explan student homework querytim constraint starttimelength endtimelength 1 starttimelength 100 1 starttimei endtimei 1000 1 querytim 1000 numberofstudentsdoinghomeworkatagiventim
given root binari tree replac valu node tree sum cousin valu two node binari tree cousin depth differ parent return root modifi tree note depth node number edg path root node exampl 1 input root 549110null7 output 00077null11 explan diagram show initi binari tree binari tree chang valu node node valu 5 cousin sum 0 node valu 4 cousin sum 0 node valu 9 cousin sum 0 node valu 1 cousin valu 7 sum 7 node valu 10 cousin valu 7 sum 7 node valu 7 cousin valu 1 10 sum 11 exampl 2 input root 312 output 000 explan diagram show initi binari tree binari tree chang valu node node valu 3 cousin sum 0 node valu 1 cousin sum 0 node valu 2 cousin sum 0 constraint number node tree rang 1 105 1 nodev 104 cousinsinbinarytreeii
given integ array coin repres coin differ denomin integ amount repres total amount money return number combin make amount amount money made combin coin return 0 may assum infinit number kind coin answer guarante fit sign 32bit integ exampl 1 input amount 5 coin 125 output 4 explan four way make amount 55 5221 52111 511111 exampl 2 input amount 3 coin 2 output 0 explan amount 3 made coin 2 exampl 3 input amount 10 coin 10 output 1 constraint 1 coinslength 300 1 coinsi 5000 valu coin uniqu 0 amount 5000 coinchangeii
given array posit integ bean integ repres number magic bean found particular magic bag remov number bean possibl none bag number bean remain nonempti bag still contain least one bean equal bean remov bag allow return bag return minimum number magic bean remov exampl 1 input bean 4165 output 4 explan remov 1 bean bag 1 bean result remain bag 4065 remov 2 bean bag 6 bean result remain bag 4045 remov 1 bean bag 5 bean result remain bag 4044 remov total 1 2 1 4 bean make remain nonempti bag equal number bean solut remov 4 bean fewer exampl 2 input bean 21032 output 7 explan remov 2 bean one bag 2 bean result remain bag 01032 remov 2 bean bag 2 bean result remain bag 01030 remov 3 bean bag 3 bean result remain bag 01000 remov total 2 2 3 7 bean make remain nonempti bag equal number bean solut remov 7 bean fewer constraint 1 beanslength 105 1 beansi 105 removingminimumnumberofmagicbean
given string consist lowercas letter integ k call string ideal follow condit satisfi subsequ string absolut differ alphabet order everi two adjac letter less equal k return length longest ideal string subsequ string deriv anoth string delet charact without chang order remain charact note alphabet order cyclic exampl absolut differ alphabet order z 25 1 exampl 1 input acfgbd k 2 output 4 explan longest ideal string acbd length string 4 4 return note acfgbd ideal c f differ 3 alphabet order exampl 2 input abcd k 3 output 4 explan longest ideal string abcd length string 4 4 return constraint 1 slength 105 0 k 25 consist lowercas english letter longestidealsubsequ
given empti set interv implement data structur add interv set interv count number integ present least one interv implement countinterv class countinterv initi object empti set interv void addint left int right add interv left right set interv int count return number integ present least one interv note interv left right denot integ x left x right exampl 1 input countinterv add add count add count 2 3 7 10 5 8 output null null null 6 null 8 explan countinterv countinterv new countinterv initi object empti set interv countintervalsadd2 3 add 2 3 set interv countintervalsadd7 10 add 7 10 set interv countintervalscount return 6 integ 2 3 present interv 2 3 integ 7 8 9 10 present interv 7 10 countintervalsadd5 8 add 5 8 set interv countintervalscount return 8 integ 2 3 present interv 2 3 integ 5 6 present interv 5 8 integ 7 8 present interv 5 8 7 10 integ 9 10 present interv 7 10 constraint 1 left right 109 105 call total made add count least one call made count countintegersininterv
given head link list valu x partit node less x come node greater equal x preserv origin rel order node two partit exampl 1 input head 143252 x 3 output 122435 exampl 2 input head 21 x 2 output 12 constraint number node list rang 0 200 100 nodev 100 200 x 200 partitionlist
given 0index integ array num length n integ k return number pair j 0 j n numsi numsj j divis k exampl 1 input num 3122213 k 2 output 4 explan 4 pair meet requir nums0 nums6 0 6 0 divis 2 nums2 nums3 2 3 6 divis 2 nums2 nums4 2 4 8 divis 2 nums3 nums4 3 4 12 divis 2 exampl 2 input num 1234 k 1 output 0 explan sinc valu num repeat pair ij meet requir constraint 1 numslength 100 1 numsi k 100 countequalanddivisiblepairsinanarray
n flight label 1 n given array flight book book bookingsi firsti lasti seatsi repres book flight firsti lasti inclus seatsi seat reserv flight rang return array answer length n answeri total number seat reserv flight exampl 1 input book 121023202525 n 5 output 1055452525 explan flight label 1 2 3 4 5 book 1 reserv 10 10 book 2 reserv 20 20 book 3 reserv 25 25 25 25 total seat 10 55 45 25 25 henc answer 1055452525 exampl 2 input book 12102215 n 2 output 1025 explan flight label 1 2 book 1 reserv 10 10 book 2 reserv 15 total seat 10 25 henc answer 1025 constraint 1 n 2 104 1 bookingslength 2 104 bookingsilength 3 1 firsti lasti n 1 seatsi 104 corporateflightbook
n uniquelys stick whose length integ 1 n want arrang stick exactli k stick visibl left stick visibl left longer stick left exampl stick arrang 13254 stick length 1 3 5 visibl left given n k return number arrang sinc answer may larg return modulo 109 7 exampl 1 input n 3 k 2 output 3 explan 132 231 213 arrang exactli 2 stick visibl visibl stick underlin exampl 2 input n 5 k 5 output 1 explan 12345 arrang 5 stick visibl visibl stick underlin exampl 3 input n 20 k 11 output 647427950 explan 647427950 mod 109 7 way rearrang stick exactli 11 stick visibl constraint 1 n 1000 1 k n numberofwaystorearrangestickswithksticksvis
given 0index integ array num two integ key k kdistant index index num exist least one index j j k numsj key return list kdistant indic sort increas order exampl 1 input num 3491395 key 9 k 1 output 123456 explan nums2 key nums5 key index 0 0 2 k 0 5 k j 0 j k numsj key thu 0 kdistant index index 1 1 2 k nums2 key 1 kdistant index index 2 2 2 k nums2 key 2 kdistant index index 3 3 2 k nums2 key 3 kdistant index index 4 4 5 k nums5 key 4 kdistant index index 5 5 5 k nums5 key 5 kdistant index index 6 6 5 k nums5 key 6 kdistant index thu return 123456 sort increas order exampl 2 input num 22222 key 2 k 2 output 01234 explan indic num exist index j j k numsj key everi index kdistant index henc return 01234 constraint 1 numslength 1000 1 numsi 1000 key integ array num 1 k numslength findallkdistantindicesinanarray
given integ n 0index 2d array queri queriesi typei indexi vali initi 0index n x n matrix fill 0s queri must appli one follow chang typei 0 set valu row indexi vali overwrit previou valu typei 1 set valu column indexi vali overwrit previou valu return sum integ matrix queri appli exampl 1 input n 3 queri 001122023104 output 23 explan imag describ matrix queri sum matrix queri appli 23 exampl 2 input n 3 queri 004012101023121 output 17 explan imag describ matrix queri sum matrix queri appli 17 constraint 1 n 104 1 querieslength 5 104 queriesilength 3 0 typei 1 0 indexi n 0 vali 105 sumofmatrixafterqueri
given 0index array posit integ task repres task need complet order tasksi repres type ith task also given posit integ space repres minimum number day must pass complet task anoth task type perform day task complet must either complet next task task take break return minimum number day need complet task exampl 1 input task 121231 space 3 output 9 explan one way complet task 9 day follow day 1 complet 0th task day 2 complet 1st task day 3 take break day 4 take break day 5 complet 2nd task day 6 complet 3rd task day 7 take break day 8 complet 4th task day 9 complet 5th task shown task complet less 9 day exampl 2 input task 5885 space 2 output 6 explan one way complet task 6 day follow day 1 complet 0th task day 2 complet 1st task day 3 take break day 4 take break day 5 complet 2nd task day 6 complet 3rd task shown task complet less 6 day constraint 1 taskslength 105 1 tasksi 109 1 space taskslength taskschedulerii
given array integ stone stonesi weight ith stone play game stone turn choos two stone smash togeth suppos stone weight x x result smash x stone destroy x stone weight x destroy stone weight new weight x end game one stone left return smallest possibl weight left stone stone left return 0 exampl 1 input stone 274181 output 1 explan combin 2 4 get 2 array convert 27181 combin 7 8 get 1 array convert 2111 combin 2 1 get 1 array convert 111 combin 1 1 get 0 array convert 1 that optim valu exampl 2 input stone 3126332140 output 5 constraint 1 stoneslength 30 1 stonesi 100 laststoneweightii
given array num consist nonneg integ let us defin revx revers nonneg integ x exampl rev123 321 rev120 21 pair indic j nice satisfi follow condit 0 j numslength numsi revnumsj numsj revnumsi return number nice pair indic sinc number larg return modulo 109 7 exampl 1 input num 4211197 output 2 explan two pair 03 42 rev97 42 79 121 97 rev42 97 24 121 12 11 rev1 11 1 12 1 rev11 1 11 12 exampl 2 input num 1310352476 output 4 constraint 1 numslength 105 0 numsi 109 countnicepairsinanarray
given x n integ matrix grid move cell adjac cell 4 direct return number strictli increas path grid start cell end cell sinc answer may larg return modulo 109 7 two path consid differ exactli sequenc visit cell exampl 1 input grid 1134 output 8 explan strictli increas path path length 1 1 1 3 4 path length 2 1 3 1 4 3 4 path length 3 1 3 4 total number path 4 3 1 8 exampl 2 input grid 12 output 3 explan strictli increas path path length 1 1 2 path length 2 1 2 total number path 2 1 3 constraint gridlength n gridilength 1 n 1000 1 n 105 1 gridij 105 numberofincreasingpathsinagrid
given binari array num integ goal return number nonempti subarray sum goal subarray contigu part array exampl 1 input num 10101 goal 2 output 4 explan 4 subarray bold underlin 10101 10101 10101 10101 exampl 2 input num 00000 goal 0 output 15 constraint 1 numslength 3 104 numsi either 0 1 0 goal numslength binarysubarrayswithsum
given valid boolean express string express consist charact 10 bitwis oper bitwis oper exampl 11 1 valid 1 10 101 valid express return minimum cost chang final valu express exampl express 11001 valu 11001 1101 101 11 1 want appli oper new express evalu 0 cost chang final valu express number oper perform express type oper describ follow turn 1 0 turn 0 1 turn turn note take preced order calcul evalu parenthes first lefttoright order exampl 1 input express 101 output 1 explan turn 101 101 chang use 1 oper new express evalu 0 exampl 2 input express 00000 output 3 explan turn 00000 01000 use 3 oper new express evalu 1 exampl 3 input express 0101 output 1 explan turn 0101 0001 use 1 oper new express evalu 0 constraint 1 expressionlength 105 express contain 10 parenthes properli match empti parenthes ie substr express minimumcosttochangethefinalvalueofexpress
given integ n return string array answer 1index answeri fizzbuzz divis 3 5 answeri fizz divis 3 answeri buzz divis 5 answeri string none condit true exampl 1 input n 3 output 12fizz exampl 2 input n 5 output 12fizz4buzz exampl 3 input n 15 output 12fizz4buzzfizz78fizzbuzz11fizz1314fizzbuzz constraint 1 n 104 fizzbuzz
given string integ repeatlimit construct new string repeatlimitedstr use charact letter appear repeatlimit time row use charact return lexicograph largest repeatlimitedstr possibl string lexicograph larger string b first posit b differ string letter appear later alphabet correspond letter b first minalength blength charact differ longer string lexicograph larger one exampl 1 input cczazcc repeatlimit 3 output zzcccac explan use charact construct repeatlimitedstr zzcccac letter appear 1 time row letter c appear 3 time row letter z appear 2 time row henc letter appear repeatlimit time row string valid repeatlimitedstr string lexicograph largest repeatlimitedstr possibl return zzcccac note string zzcccca lexicograph larger letter c appear 3 time row valid repeatlimitedstr exampl 2 input aababab repeatlimit 2 output bbabaa explan use charact construct repeatlimitedstr bbabaa letter appear 2 time row letter b appear 2 time row henc letter appear repeatlimit time row string valid repeatlimitedstr string lexicograph largest repeatlimitedstr possibl return bbabaa note string bbabaaa lexicograph larger letter appear 2 time row valid repeatlimitedstr constraint 1 repeatlimit slength 105 consist lowercas english letter constructstringwithrepeatlimit
given three integ n k consid follow algorithm find maximum element array posit integ build array arr follow properti arr exactli n integ 1 arri 0 n appli mention algorithm arr valu searchcost equal k return number way build array arr mention condit answer may grow larg answer must comput modulo 109 7 exampl 1 input n 2 3 k 1 output 6 explan possibl array 1 1 2 1 2 2 3 1 3 2 3 3 exampl 2 input n 5 2 k 3 output 0 explan possibl array satisifi mention condit exampl 3 input n 9 1 k 1 output 1 explan possibl array 1 1 1 1 1 1 1 1 1 constraint 1 n 50 1 100 0 k n buildarraywhereyoucanfindthemaximumexactlykcomparison
given integ array pref size n find return array arr size n satisfi prefi arr0 arr1 arri note denot bitwisexor oper proven answer uniqu exampl 1 input pref 52031 output 57232 explan array 57232 follow pref0 5 pref1 5 7 2 pref2 5 7 2 0 pref3 5 7 2 3 3 pref4 5 7 2 3 2 1 exampl 2 input pref 13 output 13 explan pref0 arr0 13 constraint 1 preflength 105 0 prefi 106 findtheoriginalarrayofprefixxor
given 0index x n integ matrix grid integ k current posit 0 0 want reach posit 1 n 1 move right return number path sum element path divis k sinc answer may larg return modulo 109 7 exampl 1 input grid 524305072 k 3 output 2 explan two path sum element path divis k first path highlight red sum 5 2 4 5 2 18 divis 3 second path highlight blue sum 5 3 0 5 2 15 divis 3 exampl 2 input grid 00 k 5 output 1 explan path highlight red sum 0 0 0 divis 5 exampl 3 input grid 734923622370 k 1 output 10 explan everi integ divis 1 sum element everi possibl path divis k constraint gridlength n gridilength 1 n 5 104 1 n 5 104 0 gridij 100 1 k 50 pathsinmatrixwhosesumisdivisiblebyk
given integ array num find subarray largest product return product test case gener answer fit 32bit integ exampl 1 input num 2324 output 6 explan 23 largest product 6 exampl 2 input num 201 output 0 explan result 2 21 subarray constraint 1 numslength 2 104 10 numsi 10 product prefix suffix num guarante fit 32bit integ maximumproductsubarray
sql schema tabl queri column name type querynam varchar result varchar posit int rate int primari key tabl may duplic row tabl contain inform collect queri databas posit column valu 1 500 rate column valu 1 5 queri rate less 3 poor queri defin queri qualiti averag ratio queri rate posit also defin poor queri percentag percentag queri rate less 3 write sql queri find querynam qualiti poorquerypercentag qualiti poorquerypercentag round 2 decim place return result tabl order queri result format follow exampl exampl 1 input queri tabl querynam result posit rate dog golden retriev 1 5 dog german shepherd 2 5 dog mule 200 1 cat shirazi 5 2 cat siames 3 3 cat sphynx 7 4 output querynam qualiti poorquerypercentag dog 250 3333 cat 066 3333 explan dog queri qualiti 5 1 5 2 1 200 3 250 dog queri poor querypercentag 1 3 100 3333 cat queri qualiti equal 2 5 3 3 4 7 3 066 cat queri poor querypercentag 1 3 100 3333 queriesqualityandpercentag
given 0index integ array arr integ k array arr circular word first element array next element last element last element array previou element first element follow oper number time pick element arr increas decreas 1 return minimum number oper sum subarray length k equal subarray contigu part array exampl 1 input arr 1413 k 2 output 1 explan one oper index 1 make valu equal 3 array oper 1313 subarray start index 0 1 3 sum 4 subarray start index 1 3 1 sum 4 subarray start index 2 1 3 sum 4 subarray start index 3 3 1 sum 4 exampl 2 input arr 2557 k 3 output 5 explan three oper index 0 make valu equal 5 two oper index 3 make valu equal 5 array oper 5555 subarray start index 0 5 5 5 sum 15 subarray start index 1 5 5 5 sum 15 subarray start index 2 5 5 5 sum 15 subarray start index 3 5 5 5 sum 15 constraint 1 k arrlength 105 1 arri 109 makeksubarraysumsequ
special rank system voter give rank highest lowest team particip competit order team decid receiv positionon vote two team tie first posit consid second posit resolv conflict tie continu process tie resolv two team still tie consid posit rank alphabet base team letter given array string vote vote voter rank system sort team accord rank system describ return string team sort rank system exampl 1 input vote abcacbabcacbacb output acb explan team rank first place 5 voter team vote first place team first team team b rank second 2 voter rank third 3 voter team c rank second 3 voter rank third 2 voter voter rank c second team c second team team b third exampl 2 input vote wxyzxyzw output xwyz explan x winner due tiebreak rule x vote w first posit x one vote second posit w vote second posit exampl 3 input vote zmnaguedsjylbophrqicwfxtvk output zmnaguedsjylbophrqicwfxtvk explan one voter vote use rank constraint 1 voteslength 1000 1 votesilength 26 votesilength votesjlength 0 j voteslength votesij english uppercas letter charact votesi uniqu charact occur votes0 also occur votesj 1 j voteslength rankteamsbyvot
given unsort array integ num return length longest consecut element sequenc must write algorithm run time exampl 1 input num 1004200132 output 4 explan longest consecut element sequenc 1 2 3 4 therefor length 4 exampl 2 input num 0372584601 output 9 constraint 0 numslength 105 109 numsi 109 longestconsecutivesequ
given nonempti special binari tree consist node nonneg valu node tree exactli two zero subnod node two subnod node valu smaller valu among two subnod formal properti rootval minrootleftv rootrightv alway hold given binari tree need output second minimum valu set made node valu whole tree second minimum valu exist output 1 instead exampl 1 input root 225nullnull57 output 5 explan smallest valu 2 second smallest valu 5 exampl 2 input root 222 output 1 explan smallest valu 2 isnt second smallest valu constraint number node tree rang 1 25 1 nodev 231 1 rootval minrootleftv rootrightv intern node tree secondminimumnodeinabinarytre
compani plan interview 2n peopl given array cost costsi acosti bcosti cost fli ith person citi acosti cost fli ith person citi b bcosti return minimum cost fli everi person citi exactli n peopl arriv citi exampl 1 input cost 102030200400503020 output 110 explan first person goe citi cost 10 second person goe citi cost 30 third person goe citi b cost 50 fourth person goe citi b cost 20 total minimum cost 10 30 50 20 110 half peopl interview citi exampl 2 input cost 25977044854926667184139840118577469 output 1859 exampl 3 input cost 5155634517135377093438198557794576065035963142 output 3086 constraint 2 n costslength 2 costslength 100 costslength even 1 acosti bcosti 1000 twocityschedul
given two link list list1 list2 size n respect remov list1 node ath node bth node put list2 place blue edg node follow figur indic result build result list return head exampl 1 input list1 012345 3 b 4 list2 100000010000011000002 output 0121000000100000110000025 explan remov node 3 4 put entir list2 place blue edg node figur indic result exampl 2 input list1 0123456 2 b 5 list2 10000001000001100000210000031000004 output 01100000010000011000002100000310000046 explan blue edg node figur indic result constraint 3 list1length 104 1 b list1length 1 1 list2length 104 mergeinbetweenlinkedlist
function signfuncx return 1 x posit 1 x neg 0 x equal 0 given integ array num let product product valu array num return signfuncproduct exampl 1 input num 1234321 output 1 explan product valu array 144 signfunc144 1 exampl 2 input num 15023 output 0 explan product valu array 0 signfunc0 0 exampl 3 input num 11111 output 1 explan product valu array 1 signfunc1 1 constraint 1 numslength 1000 100 numsi 100 signoftheproductofanarray
build string length n one charact time prepend new charact front string string label 1 n string length label si exampl abaca s1 s2 ca s3 aca etc score si length longest common prefix si sn note sn given final string return sum score everi si exampl 1 input babab output 9 explan s1 b longest common prefix b score 1 s2 ab common prefix score 0 s3 bab longest common prefix bab score 3 s4 abab common prefix score 0 s5 babab longest common prefix babab score 5 sum score 1 0 3 0 5 9 return 9 exampl 2 input azbazbzaz output 14 explan s2 az longest common prefix az score 2 s6 azbzaz longest common prefix azb score 3 s9 azbazbzaz longest common prefix azbazbzaz score 9 si score 0 sum score 2 3 9 14 return 14 constraint 1 slength 105 consist lowercas english letter sumofscoresofbuiltstr
design data structur find frequenc given valu given subarray frequenc valu subarray number occurr valu subarray implement rangefreqqueri class rangefreqqueryint arr construct instanc class given 0index integ array arr int queryint left int right int valu return frequenc valu subarray arrleftright subarray contigu sequenc element within array arrleftright denot subarray contain element num indic left right inclus exampl 1 input rangefreqqueri queri queri 12 33 4 56 22 2 34 33 22 12 34 56 1 2 4 0 11 33 output null 1 2 explan rangefreqqueri rangefreqqueri new rangefreqquery12 33 4 56 22 2 34 33 22 12 34 56 rangefreqqueryquery1 2 4 return 1 valu 4 occur 1 time subarray 33 4 rangefreqqueryquery0 11 33 return 2 valu 33 occur 2 time whole array constraint 1 arrlength 105 1 arri valu 104 0 left right arrlength 105 call made queri rangefrequencyqueri
design queue support push pop oper front middl back implement frontmiddleback class frontmiddleback initi queue void pushfrontint val add val front queue void pushmiddleint val add val middl queue void pushbackint val add val back queue int popfront remov front element queue return queue empti return 1 int popmiddl remov middl element queue return queue empti return 1 int popback remov back element queue return queue empti return 1 notic two middl posit choic oper perform frontmost middl posit choic exampl push 6 middl 1 2 3 4 5 result 1 2 6 3 4 5 pop middl 1 2 3 4 5 6 return 3 result 1 2 4 5 6 exampl 1 input frontmiddlebackqueu pushfront pushback pushmiddl pushmiddl popfront popmiddl popmiddl popback popfront 1 2 3 4 output null null null null null 1 3 4 2 1 explan frontmiddlebackqueu q new frontmiddlebackqueu qpushfront1 1 qpushback2 1 2 qpushmiddle3 1 3 2 qpushmiddle4 1 4 3 2 qpopfront return 1 4 3 2 qpopmiddl return 3 4 2 qpopmiddl return 4 2 qpopback return 2 qpopfront return 1 queue empti constraint 1 val 109 1000 call made pushfront pushmiddl pushback popfront popmiddl popback designfrontmiddlebackqueu
given string revers order charact word within sentenc still preserv whitespac initi word order exampl 1 input let take leetcod contest output stel ekat edocteel tsetnoc exampl 2 input god ding output dog gnid constraint 1 slength 5 104 contain printabl ascii charact contain lead trail space least one word word separ singl space reversewordsinastringiii
given root binari search tree bst convert greater tree everi key origin bst chang origin key plu sum key greater origin key bst remind binari search tree tree satisfi constraint left subtre node contain node key less node key right subtre node contain node key greater node key left right subtre must also binari search tree exampl 1 input root 4160257nullnullnull3nullnullnull8 output 30362136352615nullnullnull33nullnullnull8 exampl 2 input root 0null1 output 1null1 constraint number node tree rang 0 104 104 nodev 104 valu tree uniqu root guarante valid binari search tree note question 1038 httpsleetcodecomproblemsbinarysearchtreetogreatersumtre convertbsttogreatertre
two string consid close attain one use follow oper oper 1 swap two exist charact exampl abcd aecdb oper 2 transform everi occurr one exist charact anoth exist charact charact exampl aacabb bbcbaa turn bs bs turn use oper either string mani time necessari given two string word1 word2 return true word1 word2 close fals otherwis exampl 1 input word1 abc word2 bca output true explan attain word2 word1 2 oper appli oper 1 abc acb appli oper 1 acb bca exampl 2 input word1 word2 aa output fals explan imposs attain word2 word1 vice versa number oper exampl 3 input word1 cabbba word2 abbccc output true explan attain word2 word1 3 oper appli oper 1 cabbba caabbb appli oper 2 caabbb baaccc appli oper 2 baaccc abbccc constraint 1 word1length word2length 105 word1 word2 contain lowercas english letter determineiftwostringsareclos
given head link list repeatedli delet consecut sequenc node sum 0 sequenc return head final link list may return answer note exampl sequenc serial listnod object exampl 1 input head 12331 output 31 note answer 121 would also accept exampl 2 input head 12334 output 124 exampl 3 input head 12332 output 1 constraint given link list contain 1 1000 node node link list 1000 nodev 1000 removezerosumconsecutivenodesfromlinkedlist
given nonempti array integ num everi element appear twice except one find singl one must implement solut linear runtim complex use constant extra space exampl 1 input num 221 output 1 exampl 2 input num 41212 output 4 exampl 3 input num 1 output 1 constraint 1 numslength 3 104 3 104 numsi 3 104 element array appear twice except one element appear singlenumb
given binari array num delet one element return size longest nonempti subarray contain 1s result array return 0 subarray exampl 1 input num 1101 output 3 explan delet number posit 2 111 contain 3 number valu 1s exampl 2 input num 011101101 output 5 explan delet number posit 4 01111101 longest subarray valu 1s 11111 exampl 3 input num 111 output 2 explan must delet one element constraint 1 numslength 105 numsi either 0 1 longestsubarrayof1safterdeletingoneel
design number contain system follow insert replac number given index system return smallest index given number system implement numbercontain class numbercontain initi number contain system void changeint index int number fill contain index number alreadi number index replac int findint number return smallest index given number 1 index fill number system exampl 1 input numbercontain find chang chang chang chang find chang find 10 2 10 1 10 3 10 5 10 10 1 20 10 output null 1 null null null null 1 null 2 explan numbercontain nc new numbercontain ncfind10 index fill number 10 therefor return 1 ncchange2 10 contain index 2 fill number 10 ncchange1 10 contain index 1 fill number 10 ncchange3 10 contain index 3 fill number 10 ncchange5 10 contain index 5 fill number 10 ncfind10 number 10 indic 1 2 3 5 sinc smallest index fill 10 1 return 1 ncchange1 20 contain index 1 fill number 20 note index 1 fill 10 replac 20 ncfind10 number 10 indic 2 3 5 smallest index fill 10 2 therefor return 2 constraint 1 index number 109 105 call made total chang find designanumbercontainersystem
alic bob take turn play game alic start first n stone arrang row player turn number stone one follow choos integ x 1 remov leftmost x stone row add sum remov stone valu player score place new stone whose valu equal sum left side row game stop one stone left row score differ alic bob alic score bob score alic goal maxim score differ bob goal minim score differ given integ array stone length n stonesi repres valu ith stone left return score differ alic bob play optim exampl 1 input stone 12345 output 5 explan alic remov first 4 stone add 1 2 3 4 2 score place stone valu 2 left stone 25 bob remov first 2 stone add 2 5 3 score place stone valu 3 left stone 3 differ score 2 3 5 exampl 2 input stone 76510526 output 13 explan alic remov stone add 7 6 5 10 5 2 6 13 score place stone valu 13 left stone 13 differ score 13 0 13 exampl 3 input stone 1012 output 22 explan alic make one move remov stone add 10 12 22 score place stone valu 22 left stone 22 differ score 22 0 22 constraint n stoneslength 2 n 105 104 stonesi 104 stonegameviii
given array price pricesi price given stock ith day find maximum profit achiev may complet two transact note may engag multipl transact simultan ie must sell stock buy exampl 1 input price 33500314 output 6 explan buy day 4 price 0 sell day 6 price 3 profit 30 3 buy day 7 price 1 sell day 8 price 4 profit 41 3 exampl 2 input price 12345 output 4 explan buy day 1 price 1 sell day 5 price 5 profit 51 4 note buy day 1 buy day 2 sell later engag multipl transact time must sell buy exampl 3 input price 76431 output 0 explan case transact done ie max profit 0 constraint 1 priceslength 105 0 pricesi 105 besttimetobuyandsellstockiii
given root binari tree construct 0index x n string matrix re repres format layout tree format layout matrix construct use follow rule height tree height number row equal height 1 number column n equal 2height1 1 place root node middl top row formal locat res0n12 node place matrix posit resrc place left child resr1c2heightr1 right child resr1c2heightr1 continu process node tree place empti cell contain empti string return construct matrix re exampl 1 input root 12 output 1 2 exampl 2 input root 123null4 output 1 23 4 constraint number node tree rang 1 210 99 nodev 99 depth tree rang 1 10 printbinarytre
given 0index integ array num size n posit integ k call index rang k n k good follow condit satisfi k element index nonincreas order k element index nondecreas order return array good indic sort increas order exampl 1 input num 2111341 k 2 output 23 explan two good indic array index 2 subarray 21 nonincreas order subarray 13 nondecreas order index 3 subarray 11 nonincreas order subarray 34 nondecreas order note index 4 good 41 nondecreas exampl 2 input num 2112 k 2 output explan good indic array constraint n numslength 3 n 105 1 numsi 106 1 k n 2 findallgoodindic
given string num consist digit return largest palindrom integ form string form use digit taken num contain lead zero note need use digit num must use least one digit digit reorder exampl 1 input num 444947137 output 7449447 explan use digit 4449477 444947137 form palindrom integ 7449447 shown 7449447 largest palindrom integ form exampl 2 input num 00009 output 9 explan shown 9 largest palindrom integ form note integ return contain lead zero constraint 1 numlength 105 num consist digit largestpalindromicnumb
sql schema pandan schema tabl student column name type studentid int studentnam varchar sql studentid primari key tabl row tabl contain id name one student school tabl subject column name type subjectnam varchar sql subjectnam primari key tabl row tabl contain name one subject school tabl examin column name type studentid int subjectnam varchar tabl may contain duplic word primari key tabl sql student student tabl take everi cours subject tabl row tabl indic student id studentid attend exam subjectnam find number time student attend exam return result tabl order studentid subjectnam result format follow exampl exampl 1 input student tabl studentid studentnam 1 alic 2 bob 13 john 6 alex subject tabl subjectnam math physic program examin tabl studentid subjectnam 1 math 1 physic 1 program 2 program 1 physic 1 math 13 math 13 program 13 physic 2 math 1 math output studentid studentnam subjectnam attendedexam 1 alic math 3 1 alic physic 2 1 alic program 1 2 bob math 1 2 bob physic 0 2 bob program 1 6 alex math 0 6 alex physic 0 6 alex program 0 13 john math 1 13 john physic 1 13 john program 1 explan result tabl contain student subject alic attend math exam 3 time physic exam 2 time program exam 1 time bob attend math exam 1 time program exam 1 time attend physic exam alex attend exam john attend math exam 1 time physic exam 1 time program exam 1 time studentsandexamin
link list size n n even ith node 0index link list known twin n1ith node 0 n 2 1 exampl n 4 node 0 twin node 3 node 1 twin node 2 node twin n 4 twin sum defin sum node twin given head link list even length return maximum twin sum link list exampl 1 input head 5421 output 6 explan node 0 1 twin node 3 2 respect twin sum 6 node twin link list thu maximum twin sum link list 6 exampl 2 input head 4223 output 7 explan node twin present link list node 0 twin node 3 twin sum 4 3 7 node 1 twin node 2 twin sum 2 2 4 thu maximum twin sum link list max7 4 7 exampl 3 input head 1100000 output 100001 explan one node twin link list twin sum 1 100000 100001 constraint number node list even integ rang 2 105 1 nodev 105 maximumtwinsumofalinkedlist
garden repres infinit 2d grid appl tree plant everi integ coordin appl tree plant integ coordin j j appl grow buy axisalign squar plot land center 0 0 given integ neededappl return minimum perimet plot least neededappl appl insid perimet plot valu x defin x x 0 x x 0 exampl 1 input neededappl 1 output 8 explan squar plot side length 1 contain appl howev squar plot side length 2 12 appl insid depict imag perimet 2 4 8 exampl 2 input neededappl 13 output 16 exampl 3 input neededappl 1000000000 output 5040 constraint 1 neededappl 1015 minimumgardenperimetertocollectenoughappl
given string length n integ k task find longest subsequ repeat k time string subsequ string deriv anoth string delet charact without chang order remain charact subsequ seq repeat k time string seq k subsequ seq k repres string construct concaten seq k time exampl bba repeat 2 time string bababcba string bbabba construct concaten bba 2 time subsequ string bababcba return longest subsequ repeat k time string multipl subsequ found return lexicograph largest one subsequ return empti string exampl 1 input letsleetcod k 2 output let explan two longest subsequ repeat 2 time let ete let lexicograph largest one exampl 2 input bb k 2 output b explan longest subsequ repeat 2 time b exampl 3 input ab k 2 output explan subsequ repeat 2 time empti string return constraint n slength 2 n k 2000 2 n k 8 consist lowercas english letter longestsubsequencerepeatedktim
given two integ k stream integ task implement data structur calcul mkaverag stream mkaverag calcul use step number element stream less consid mkaverag 1 otherwis copi last element stream separ contain remov smallest k element largest k element contain calcul averag valu rest element round nearest integ implement mkaverag class mkaverageint int k initi mkaverag object empti stream two integ k void addelementint num insert new element num stream int calculatemkaverag calcul return mkaverag current stream round nearest integ exampl 1 input mkaverag addel addel calculatemkaverag addel calculatemkaverag addel addel addel calculatemkaverag 3 1 3 1 10 5 5 5 output null null null 1 null 3 null null null 5 explan mkaverag obj new mkaverage3 1 objaddelement3 current element 3 objaddelement1 current element 31 objcalculatemkaverag return 1 3 2 element exist objaddelement10 current element 3110 objcalculatemkaverag last 3 element 3110 remov smallest largest 1 element contain 3 averag 3 equal 31 3 return 3 objaddelement5 current element 31105 objaddelement5 current element 311055 objaddelement5 current element 3110555 objcalculatemkaverag last 3 element 555 remov smallest largest 1 element contain 5 averag 5 equal 51 5 return 5 constraint 3 105 1 k2 1 num 105 105 call made addel calculatemkaverag findingmkaverag
given array string word string pref return number string word contain pref prefix prefix string lead contigu substr exampl 1 input word payattentionpracticeattend pref output 2 explan 2 string contain prefix attent attend exampl 2 input word leetcodewinloopssuccess pref code output 0 explan string contain code prefix constraint 1 wordslength 100 1 wordsilength preflength 100 wordsi pref consist lowercas english letter countingwordswithagivenprefix
given 2d integ array rang two integ left right rangesi starti endi repres inclus interv starti endi return true integ inclus rang left right cover least one interv rang return fals otherwis integ x cover interv rangesi starti endi starti x endi exampl 1 input rang 123456 left 2 right 5 output true explan everi integ 2 5 cover 2 cover first rang 3 4 cover second rang 5 cover third rang exampl 2 input rang 1101020 left 21 right 21 output fals explan 21 cover rang constraint 1 rangeslength 50 1 starti endi 50 1 left right 50 checkifalltheintegersinarangearecov
function printnumb call integ paramet print consol exampl call printnumber7 print 7 consol given instanc class zeroevenodd three function zero even odd instanc zeroevenodd pass three differ thread thread call zero output 0s thread b call even output even number thread c call odd output odd number modifi given class output seri 010203040506 length seri must 2n implement zeroevenodd class zeroevenoddint n initi object number n repres number print void zeroprintnumb call printnumb output one zero void evenprintnumb call printnumb output one even number void oddprintnumb call printnumb output one odd number exampl 1 input n 2 output 0102 explan three thread fire asynchron one call zero call even last one call odd 0102 correct output exampl 2 input n 5 output 0102030405 constraint 1 n 1000 printzeroevenodd
given 0index array num distinct integ want rearrang element array everi element rearrang array equal averag neighbor formal rearrang array properti everi rang 1 numslength 1 numsi1 numsi1 2 equal numsi return rearrang num meet requir exampl 1 input num 12345 output 12453 explan i1 numsi 2 averag neighbor 14 2 25 i2 numsi 4 averag neighbor 25 2 35 i3 numsi 5 averag neighbor 43 2 35 exampl 2 input num 62097 output 97620 explan i1 numsi 7 averag neighbor 96 2 75 i2 numsi 6 averag neighbor 72 2 45 i3 numsi 2 averag neighbor 60 2 3 constraint 3 numslength 105 0 numsi 105 arraywithelementsnotequaltoaverageofneighbor
given x n integ matrix grid defin hourglass part matrix follow form return maximum sum element hourglass note hourglass rotat must entir contain within matrix exampl 1 input grid 6213421592874129 output 30 explan cell shown repres hourglass maximum sum 6 2 1 2 9 2 8 30 exampl 2 input grid 123456789 output 35 explan one hourglass matrix sum 1 2 3 5 7 8 9 35 constraint gridlength n gridilength 3 n 150 0 gridij 106 maximumsumofanhourglass
swap defin take two distinct posit array swap valu circular array defin array consid first element last element adjac given binari circular array num return minimum number swap requir group 1s present array togeth locat exampl 1 input num 0101100 output 1 explan way group 1s togeth 0011100 use 1 swap 0111000 use 1 swap 1100001 use 2 swap use circular properti array way group 1s togeth 0 swap thu minimum number swap requir 1 exampl 2 input num 011100110 output 2 explan way group 1s togeth 111000011 use 2 swap use circular properti array 111110000 use 2 swap way group 1s togeth 0 1 swap thu minimum number swap requir 2 exampl 3 input num 11001 output 0 explan 1s alreadi group togeth due circular properti array thu minimum number swap requir 0 constraint 1 numslength 105 numsi either 0 1 minimumswapstogroupall1stogetherii
given string awesom substr nonempti substr make number swap order make palindrom return length maximum length awesom substr exampl 1 input 3242415 output 5 explan 24241 longest awesom substr form palindrom 24142 swap exampl 2 input 12345678 output 1 exampl 3 input 213123 output 6 explan 213123 longest awesom substr form palindrom 231132 swap constraint 1 slength 105 consist digit findlongestawesomesubstr
given two posit integ left right left right calcul product integ inclus rang left right sinc product may larg abbrevi follow step count trail zero product remov let us denot count c exampl 3 trail zero 1000 0 trail zero 546 denot remain number digit product 10 express product presuf pre denot first 5 digit product suf denot last 5 digit product remov trail zero 10 keep unchang exampl express 1234567654321 1234554321 1234567 repres 1234567 final repres product string presufec exampl 12345678987600000 repres 1234589876e5 return string denot abbrevi product integ inclus rang left right exampl 1 input left 1 right 4 output 24e0 explan product 1 × 2 × 3 × 4 24 trail zero 24 remain abbrevi end e0 sinc number digit 2 less 10 abbrevi thu final represent 24e0 exampl 2 input left 2 right 11 output 399168e2 explan product 39916800 2 trail zero remov get 399168 abbrevi end e2 number digit remov trail zero 6 abbrevi henc abbrevi product 399168e2 exampl 3 input left 371 right 375 output 7219856259e3 explan product 7219856259000 constraint 1 left right 104 abbreviatingtheproductofarang
given array string queri string pattern return boolean array answer answeri true queriesi match pattern fals otherwis queri word queriesi match pattern insert lowercas english letter pattern equal queri may insert charact posit may insert charact exampl 1 input queri foobarfoobartestfootballframebufferforcefeedback pattern fb output truefalsetruetruefals explan foobar gener like f oo b ar footbal gener like f oot b framebuff gener like f rame b uffer exampl 2 input queri foobarfoobartestfootballframebufferforcefeedback pattern foba output truefalsetruefalsefals explan foobar gener like fo ba r footbal gener like fo ot ba exampl 3 input queri foobarfoobartestfootballframebufferforcefeedback pattern fobat output falsetruefalsefalsefals explan foobartest gener like fo ba r est constraint 1 patternlength querieslength 100 1 queriesilength 100 queriesi pattern consist english letter camelcasematch
given tree ie connect undirect graph cycl consist n node number 0 n 1 exactli n 1 edg root tree node 0 node tree label lowercas charact given string label ie node number label labelsi edg array given form edgesi ai bi mean edg node ai bi tree return array size n ansi number node subtre ith node label node subtre tree tree consist node descend node exampl 1 input n 7 edg 010214152326 label abaedcd output 2111111 explan node 0 label subtre node 2 label well thu answer 2 notic node part subtre node 1 label b subtre node 1 contain node 14 5 node 4 5 differ label node 1 answer 1 node exampl 2 input n 4 edg 011203 label bbbb output 4211 explan subtre node 2 contain node 2 answer 1 subtre node 3 contain node 3 answer 1 subtre node 1 contain node 1 2 label b thu answer 2 subtre node 0 contain node 0 1 2 3 label b thu answer 4 exampl 3 input n 5 edg 01021304 label aabab output 32111 constraint 1 n 105 edgeslength n 1 edgesilength 2 0 ai bi n ai bi labelslength n label consist lowercas english letter numberofnodesinthesubtreewiththesamelabel
design combinationiter class combinationiteratorstr charact int combinationlength initi object string charact sort distinct lowercas english letter number combinationlength argument next return next combin length combinationlength lexicograph order hasnext return true exist next combin exampl 1 input combinationiter next hasnext next hasnext next hasnext abc 2 output null ab true ac true bc fals explan combinationiter itr new combinationiteratorabc 2 itrnext return ab itrhasnext return true itrnext return ac itrhasnext return true itrnext return bc itrhasnext return fals constraint 1 combinationlength characterslength 15 charact charact uniqu 104 call made next hasnext guarante call function next valid iteratorforcombin
given 0index integ array buse length n busesi repres departur time ith bu also given 0index integ array passeng length passengersj repres arriv time jth passeng bu departur time uniqu passeng arriv time uniqu given integ capac repres maximum number passeng get bu passeng arriv wait line next avail bu get bu depart x minut arriv minut x bu full passeng earliest arriv time get bu first formal bu arriv either capac fewer passeng wait bu get bu capac passeng earliest arriv time get bu return latest time may arriv bu station catch bu arriv time anoth passeng note array buse passeng necessarili sort exampl 1 input buse 1020 passeng 2171819 capac 2 output 16 explan suppos arriv time 16 time 10 first bu depart 0th passeng time 20 second bu depart 1st passeng note may arriv time anoth passeng must arriv 1st passeng catch bu exampl 2 input buse 203010 passeng 1913264251121 capac 2 output 20 explan suppos arriv time 20 time 10 first bu depart 3rd passeng time 20 second bu depart 5th 1st passeng time 30 third bu depart 0th passeng notic arriv later 6th passeng would taken seat third bu constraint n buseslength passengerslength 1 n capac 105 2 busesi passengersi 109 element buse uniqu element passeng uniqu thelatesttimetocatchabu
given sentenc text sentenc string spacesepar word follow format first letter upper case word text separ singl space task rearrang word text word rearrang increas order length two word length arrang origin order return new text follow format shown exampl 1 input text leetcod cool output cool leetcod explan 3 word leetcod length 8 length 2 cool length 4 output order length new first word start capit letter exampl 2 input text keep calm code output keep calm code explan output order follow 2 letter 3 letter keep 4 letter case tie order posit origin text calm 4 letter code 4 letter exampl 3 input text output constraint text begin capit letter contain lowercas letter singl space word 1 textlength 105 rearrangewordsinasent
given tree ie connect undirect graph cycl root node 0 consist n node number 0 n 1 tree repres 0index array parent size n parenti parent node sinc node 0 root parent0 1 also given string length n si charact assign node return length longest path tree pair adjac node path charact assign exampl 1 input parent 100112 abacb output 3 explan longest path two adjac node differ charact tree path 0 1 3 length path 3 3 return proven longer path satisfi condit exampl 2 input parent 1000 aabc output 3 explan longest path two adjac node differ charact path 2 0 3 length path 3 3 return constraint n parentlength slength 1 n 105 0 parenti n 1 1 parent0 1 parent repres valid tree consist lowercas english letter longestpathwithdifferentadjacentcharact
given array integ num sort array increas order base frequenc valu multipl valu frequenc sort decreas order return sort array exampl 1 input num 112223 output 311222 explan 3 frequenc 1 1 frequenc 2 2 frequenc 3 exampl 2 input num 23132 output 13322 explan 2 3 frequenc 2 sort decreas order exampl 3 input num 116456141 output 514466111 constraint 1 numslength 100 100 numsi 100 sortarraybyincreasingfrequ
given multidimension array arr depth n return flatten version array multidimension array recurs data structur contain integ multidimension array flatten array version array subarray remov replac actual element subarray flatten oper done current depth nest less n depth element first array consid 0 pleas solv without builtin arrayflat method exampl 1 input arr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n 0 output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 explan pass depth n0 alway result origin array smallest possibl depth subarray 0 less n0 thu subarray flatten exampl 2 input arr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n 1 output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 explan subarray start 4 7 13 flatten depth 0 less 1 howev 9 10 11 remain unflatten depth 1 exampl 3 input arr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n 2 output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 explan maximum depth subarray 1 thu flatten constraint 0 count number arr 105 0 count subarray arr 105 maxdepth 1000 1000 number 1000 0 n 1000 flattendeeplynestedarray
play guess game game follow pick number 1 n guess number pick everi time guess wrong tell whether number pick higher lower guess call predefin api int guessint num return three possibl result 1 guess higher number pick ie num pick 1 guess lower number pick ie num pick 0 guess equal number pick ie num pick return number pick exampl 1 input n 10 pick 6 output 6 exampl 2 input n 1 pick 1 output 1 exampl 3 input n 2 pick 1 output 1 constraint 1 n 231 1 1 pick n guessnumberhigherorlow
given integ array num everi element appear three time except one appear exactli find singl element return must implement solut linear runtim complex use constant extra space exampl 1 input num 2232 output 3 exampl 2 input num 01010199 output 99 constraint 1 numslength 3 104 231 numsi 231 1 element num appear exactli three time except one element appear singlenumberii
n coin want build staircas coin staircas consist k row ith row exactli coin last row staircas may incomplet given integ n return number complet row staircas build exampl 1 input n 5 output 2 explan 3rd row incomplet return 2 exampl 2 input n 8 output 3 explan 4th row incomplet return 3 constraint 1 n 231 1 arrangingcoin
given array num integ return length longest arithmet subsequ num note subsequ array deriv anoth array delet element without chang order remain element sequenc seq arithmet seqi 1 seqi valu 0 seqlength 1 exampl 1 input num 36912 output 4 explan whole array arithmet sequenc step length 3 exampl 2 input num 947210 output 3 explan longest arithmet subsequ 4710 exampl 3 input num 2011531058 output 4 explan longest arithmet subsequ 2015105 constraint 2 numslength 1000 0 numsi 500 longestarithmeticsubsequ
nbit gray code sequenc sequenc 2n integ everi integ inclus rang 0 2n 1 first integ 0 integ appear sequenc binari represent everi pair adjac integ differ exactli one bit binari represent first last integ differ exactli one bit given integ n return valid nbit gray code sequenc exampl 1 input n 2 output 0132 explan binari represent 0132 00011110 00 01 differ one bit 01 11 differ one bit 11 10 differ one bit 10 00 differ one bit 0231 also valid gray code sequenc whose binari represent 00101101 00 10 differ one bit 10 11 differ one bit 11 01 differ one bit 01 00 differ one bit exampl 2 input n 1 output 01 constraint 1 n 16 graycod
given root binari tree find maximum valu v exist differ node b v aval bval ancestor b node ancestor b either child equal b child ancestor b exampl 1 input root 831016null14nullnull4713 output 7 explan variou ancestornod differ given 8 3 5 3 7 4 8 1 7 10 13 3 among possibl differ maximum valu 7 obtain 8 1 7 exampl 2 input root 1null2null03 output 3 constraint number node tree rang 2 5000 0 nodev 105 maximumdifferencebetweennodeandancestor
given 0index x n binari matrix matrix integ numselect denot number distinct column must select matrix let us consid c1 c2 cnumselect set column select row row cover cell matrixrowcol 0 col n 1 matrixrowcol 1 col present cell row valu 1 need choos numselect column number row cover maxim return maximum number row cover set numselect column exampl 1 input matrix 000101011001 numselect 2 output 3 explan one possibl way cover 3 row shown diagram choos 0 2 row 0 cover occurr 1 row 1 cover column valu 1 ie 0 2 present row 2 cover matrix21 1 1 present row 3 cover matrix22 1 2 present thu cover three row note 1 2 also cover 3 row shown three row cover exampl 2 input matrix 10 numselect 1 output 2 explan select column result row cover sinc entir matrix select therefor return 2 constraint matrixlength n matrixilength 1 n 12 matrixij either 0 1 1 numselect n maximumrowscoveredbycolumn
given integ array num find three number whose product maximum return maximum product exampl 1 input num 123 output 6 exampl 2 input num 1234 output 24 exampl 3 input num 123 output 6 constraint 3 numslength 104 1000 numsi 1000 maximumproductofthreenumb
ant task ad n new room number 0 n1 coloni given expans plan 0index integ array length n prevroom prevroomi indic must build room prevroomi build room two room must connect directli room 0 alreadi built prevroom0 1 expans plan given room built everi room reachabl room 0 build one room time travel freeli room alreadi built connect choos build room long previou room alreadi built return number differ order build room sinc answer may larg return modulo 109 7 exampl 1 input prevroom 101 output 1 explan one way build addit room 0 → 1 → 2 exampl 2 input prevroom 10012 output 6 explan 6 way 0 → 1 → 3 → 2 → 4 0 → 2 → 4 → 1 → 3 0 → 1 → 2 → 3 → 4 0 → 1 → 2 → 4 → 3 0 → 2 → 1 → 3 → 4 0 → 2 → 1 → 4 → 3 constraint n prevroomlength 2 n 105 prevroom0 1 0 prevroomi n 1 n everi room reachabl room 0 room built countwaystobuildroomsinanantcoloni
given posit integ n find return longest distanc two adjac 1s binari represent n two adjac 1s return 0 two 1s adjac 0s separ possibl 0s distanc two 1s absolut differ bit posit exampl two 1s 1001 distanc 3 exampl 1 input n 22 output 2 explan 22 binari 10110 first adjac pair 1s 10110 distanc 2 second adjac pair 1s 10110 distanc 1 answer largest two distanc 2 note 10110 valid pair sinc 1 separ two 1s underlin exampl 2 input n 8 output 0 explan 8 binari 1000 adjac pair 1s binari represent 8 return 0 exampl 3 input n 5 output 2 explan 5 binari 101 constraint 1 n 109 binarygap
given array event eventsi startdayi enddayi valuei ith event start startdayi end enddayi attend event receiv valu valuei also given integ k repres maximum number event attend attend one event time choos attend event must attend entir event note end day inclus attend two event one start end day return maximum sum valu receiv attend event exampl 1 input event 124343231 k 2 output 7 explan choos green event 0 1 0index total valu 4 3 7 exampl 2 input event 1243432310 k 2 output 10 explan choos event 2 total valu 10 notic attend event overlap attend k event exampl 3 input event 111222333444 k 3 output 9 explan although event overlap attend 3 event pick highest valu three constraint 1 k eventslength 1 k eventslength 106 1 startdayi enddayi 109 1 valuei 106 maximumnumberofeventsthatcanbeattendedii
given root binari tree n node node uniqu assign valu 1 n also given sequenc n valu voyag desir preorder travers binari tree node binari tree flip swap left right subtre exampl flip node 1 follow effect flip smallest number node preorder travers tree match voyag return list valu flip node may return answer order imposs flip node tree make preorder travers match voyag return list 1 exampl 1 input root 12 voyag 21 output 1 explan imposs flip node preorder travers match voyag exampl 2 input root 123 voyag 132 output 1 explan flip node 1 swap node 2 3 preorder travers match voyag exampl 3 input root 123 voyag 123 output explan tree preorder travers alreadi match voyag node need flip constraint number node tree n n voyagelength 1 n 100 1 nodev voyagei n valu tree uniqu valu voyag uniqu flipbinarytreetomatchpreordertravers
given date return correspond day week date input given three integ repres day month year respect return answer one follow valu sunday monday tuesday wednesday thursday friday saturday exampl 1 input day 31 month 8 year 2019 output saturday exampl 2 input day 18 month 7 year 1999 output sunday exampl 3 input day 15 month 8 year 1993 output sunday constraint given date valid date year 1971 2100 dayoftheweek
given array time timei denot time taken ith bu complet one trip bu make multipl trip success next trip start immedi complet current trip also bu oper independ trip one bu influenc trip bu also given integ totaltrip denot number trip buse make total return minimum time requir buse complet least totaltrip trip exampl 1 input time 123 totaltrip 5 output 3 explan time 1 number trip complet bu 100 total number trip complet 1 0 0 1 time 2 number trip complet bu 210 total number trip complet 2 1 0 3 time 3 number trip complet bu 311 total number trip complet 3 1 1 5 minimum time need buse complet least 5 trip 3 exampl 2 input time 2 totaltrip 1 output 2 explan one bu complet first trip 2 minimum time need complet 1 trip 2 constraint 1 timelength 105 1 timei totaltrip 107 minimumtimetocompletetrip
given x n integ matrix grid rhombu sum sum element form border regular rhombu shape grid rhombu must shape squar rotat 45 degre corner center grid cell imag four valid rhombu shape correspond color cell includ rhombu sum note rhombu area 0 depict purpl rhombu bottom right corner return biggest three distinct rhombu sum grid descend order less three distinct valu return exampl 1 input grid 3451333423203020040101554143225 output 228216211 explan rhombu shape three biggest distinct rhombu sum depict blue 20 3 200 5 228 red 200 2 10 4 216 green 5 200 4 2 211 exampl 2 input grid 123456789 output 2098 explan rhombu shape three biggest distinct rhombu sum depict blue 4 2 6 8 20 red 9 area 0 rhombu bottom right corner green 8 area 0 rhombu bottom middl exampl 3 input grid 777 output 7 explan three possibl rhombu sum return 7 constraint gridlength n gridilength 1 n 50 1 gridij 105 getbiggestthreerhombussumsinagrid
given posit integ n find pivot integ x sum element 1 x inclus equal sum element x n inclus return pivot integ x integ exist return 1 guarante one pivot index given input exampl 1 input n 8 output 6 explan 6 pivot integ sinc 1 2 3 4 5 6 6 7 8 21 exampl 2 input n 1 output 1 explan 1 pivot integ sinc 1 1 exampl 3 input n 4 output 1 explan prove integ exist constraint 1 n 1000 findthepivotinteg
given root binari tree return sum valu deepest leav exampl 1 input root 12345null67nullnullnullnull8 output 15 exampl 2 input root 67827139null14nullnullnull5 output 19 constraint number node tree rang 1 104 1 nodev 100 deepestleavessum
string sequenc string word krepeat word concaten k time substr sequenc word maximum krepeat valu highest valu k word krepeat sequenc word substr sequenc word maximum krepeat valu 0 given string sequenc word return maximum krepeat valu word sequenc exampl 1 input sequenc ababc word ab output 2 explan abab substr ababc exampl 2 input sequenc ababc word ba output 1 explan ba substr ababc baba substr ababc exampl 3 input sequenc ababc word ac output 0 explan ac substr ababc constraint 1 sequencelength 100 1 wordlength 100 sequenc word contain lowercas english letter maximumrepeatingsubstr
given integ n must transform 0 use follow oper number time chang rightmost 0th bit binari represent n chang ith bit binari represent n i1th bit set 1 i2th 0th bit set 0 return minimum number oper transform n 0 exampl 1 input n 3 output 2 explan binari represent 3 11 11 01 2nd oper sinc 0th bit 1 01 00 1st oper exampl 2 input n 6 output 4 explan binari represent 6 110 110 010 2nd oper sinc 1st bit 1 0th 0th bit 0 010 011 1st oper 011 001 2nd oper sinc 0th bit 1 001 000 1st oper constraint 0 n 109 minimumonebitoperationstomakeintegerszero
given n x n array integ matrix return minimum sum fall path matrix fall path start element first row choos element next row either directli diagon leftright specif next element posit row col row 1 col 1 row 1 col row 1 col 1 exampl 1 input matrix 213654789 output 13 explan two fall path minimum sum shown exampl 2 input matrix 1957405 output 59 explan fall path minimum sum shown constraint n matrixlength matrixilength 1 n 100 100 matrixij 100 minimumfallingpathsum
complet binari tree binari tree everi level except possibl last complet fill node far left possibl design algorithm insert new node complet binari tree keep complet insert implement cbtinsert class cbtinsertertreenod root initi data structur root complet binari tree int insertint v insert treenod tree valu nodev val tree remain complet return valu parent insert treenod treenod getroot return root node tree exampl 1 input cbtinsert insert insert getroot 1 2 3 4 output null 1 2 1 2 3 4 explan cbtinsert cbtinsert new cbtinserter1 2 cbtinserterinsert3 return 1 cbtinserterinsert4 return 2 cbtinsertergetroot return 1 2 3 4 constraint number node tree rang 1 1000 0 nodev 5000 root complet binari tree 0 val 5000 104 call made insert getroot completebinarytreeinsert
want split group n peopl label 1 n two group size person may dislik peopl go group given integ n array dislik dislikesi ai bi indic person label ai like person label bi return true possibl split everyon two group way exampl 1 input n 4 dislik 121324 output true explan first group 14 second group 23 exampl 2 input n 3 dislik 121323 output fals explan need least 3 group divid put two group constraint 1 n 2000 0 dislikeslength 104 dislikesilength 2 1 ai bi n pair dislik uniqu possiblebipartit
sql schema tabl employe column name type employeeid int name varchar managerid int salari int employeeid primari key tabl tabl contain inform employe salari id manag employe manag managerid null write sql queri report id employe whose salari strictli less 30000 whose manag left compani manag leav compani inform delet employe tabl report still managerid set manag left return result tabl order employeeid queri result format follow exampl exampl 1 input employe tabl employeeid name managerid salari 3 mila 9 60301 12 antonella null 31000 13 emeri null 67084 1 kalel 11 21241 9 mikaela null 50937 11 joziah 6 28485 output employeeid 11 explan employe salari less 30000 1 kalel 11 joziah kalel manag employe 11 still compani joziah joziah manag employe 6 left compani row employe 6 delet employeeswhosemanagerleftthecompani
given two x n binari matric grid1 grid2 contain 0s repres water 1s repres land island group 1s connect 4direct horizont vertic cell outsid grid consid water cell island grid2 consid subisland island grid1 contain cell make island grid2 return number island grid2 consid subisland exampl 1 input grid1 1110001111000001000011011 grid2 1110000111010001011001010 output 3 explan pictur grid left grid1 grid right grid2 1s color red grid2 consid part subisland three subisland exampl 2 input grid1 1010111111000001111110101 grid2 0000011111010100101010001 output 2 explan pictur grid left grid1 grid right grid2 1s color red grid2 consid part subisland two subisland constraint grid1length grid2length n grid1ilength grid2ilength 1 n 500 grid1ij grid2ij either 0 1 countsubisland
given binari string return number nonempti substr number 0s 1s 0s 1s substr group consecut substr occur multipl time count number time occur exampl 1 input 00110011 output 6 explan 6 substr equal number consecut 1s 0s 0011 01 1100 10 0011 01 notic substr repeat count number time occur also 00110011 valid substr 0s 1s group togeth exampl 2 input 10101 output 4 explan 4 substr 10 01 10 01 equal number consecut 1s 0s constraint 1 slength 105 si either 0 1 countbinarysubstr
given x n binari matrix mat return number submatric one exampl 1 input mat 101110110 output 13 explan 6 rectangl side 1x1 2 rectangl side 1x2 3 rectangl side 2x1 1 rectangl side 2x2 1 rectangl side 3x1 total number rectangl 6 2 3 1 1 13 exampl 2 input mat 011001111110 output 24 explan 8 rectangl side 1x1 5 rectangl side 1x2 2 rectangl side 1x3 4 rectangl side 2x1 2 rectangl side 2x2 2 rectangl side 3x1 1 rectangl side 3x2 total number rectangl 8 5 2 4 2 2 1 24 constraint 1 n 150 matij either 0 1 countsubmatriceswithallon
given root binari tree consist exactli 3 node root left child right child return true valu root equal sum valu two children fals otherwis exampl 1 input root 1046 output true explan valu root left child right child 10 4 6 respect 10 equal 4 6 return true exampl 2 input root 531 output fals explan valu root left child right child 5 3 1 respect 5 equal 3 1 return fals constraint tree consist root left child right child 100 nodev 100 rootequalssumofchildren
given integ array roll length n integ k roll k side dice number 1 k n time result ith roll rollsi return length shortest sequenc roll taken roll sequenc roll length len result roll k side dice len time note sequenc taken consecut long order exampl 1 input roll 421233241 k 4 output 3 explan everi sequenc roll length 1 1 2 3 4 taken roll everi sequenc roll length 2 1 1 1 2 4 4 taken roll sequenc 1 4 2 taken roll return 3 note sequenc taken roll exampl 2 input roll 1122 k 2 output 2 explan everi sequenc roll length 1 1 2 taken roll sequenc 2 1 taken roll return 2 note sequenc taken roll 2 1 shortest exampl 3 input roll 11322233 k 4 output 1 explan sequenc 4 taken roll return 1 note sequenc taken roll 4 shortest constraint n rollslength 1 n 105 1 rollsi k 105 shortestimpossiblesequenceofrol
given head link list revers node list k time return modifi list k posit integ less equal length link list number node multipl k leftout node end remain may alter valu list node node may chang exampl 1 input head 12345 k 2 output 21435 exampl 2 input head 12345 k 3 output 32145 constraint number node list n 1 k n 5000 0 nodev 1000 followup solv problem o1 extra memori space reversenodesinkgroup
given integ n count total number digit 1 appear nonneg integ less equal n exampl 1 input n 13 output 6 exampl 2 input n 0 output 0 constraint 0 n 109 numberofdigiton
manag basketbal team upcom tournament want choos team highest overal score score team sum score player team howev basketbal team allow conflict conflict exist younger player strictli higher score older player conflict occur player age given two list score age scoresi agesi repres score age ith player respect return highest overal score possibl basketbal team exampl 1 input score 1351015 age 12345 output 34 explan choos player exampl 2 input score 4565 age 2121 output 16 explan best choos last 3 player notic allow choos multipl peopl age exampl 3 input score 1235 age 89101 output 6 explan best choos first 3 player constraint 1 scoreslength ageslength 1000 scoreslength ageslength 1 scoresi 106 1 agesi 1000 bestteamwithnoconflict
given integ n return list possibl full binari tree n node node tree answer must nodev 0 element answer root node one possibl tree may return final list tree order full binari tree binari tree node exactli 0 2 children exampl 1 input n 7 output 000nullnull00nullnull00000nullnull0000000000000000nullnullnullnull0000000nullnull00 exampl 2 input n 3 output 000 constraint 1 n 20 allpossiblefullbinarytre
newli design keypad test tester press sequenc n key one time given string keyspress length n keyspressedi ith key press test sequenc sort list releasetim releasetimesi time ith key releas array 0index 0th key press time 0 everi subsequ key press exact time previou key releas tester want know key keypress longest durat ith keypress durat releasetimesi releasetimesi 1 0th keypress durat releasetimes0 note key could press multipl time test multipl press key may durat return key keypress longest durat multipl keypress return lexicograph largest key keypress exampl 1 input releasetim 9294950 keyspress cbcd output c explan keypress follow keypress c durat 9 press time 0 releas time 9 keypress b durat 29 9 20 press time 9 right releas previou charact releas time 29 keypress c durat 49 29 20 press time 29 right releas previou charact releas time 49 keypress durat 50 49 1 press time 49 right releas previou charact releas time 50 longest keypress b second keypress c durat 20 c lexicograph larger b answer c exampl 2 input releasetim 1223364662 keyspress spuda output explan keypress follow keypress durat 12 keypress p durat 23 12 11 keypress u durat 36 23 13 keypress durat 46 36 10 keypress durat 62 46 16 longest keypress durat 16 constraint releasetimeslength n keyspressedlength n 2 n 1000 1 releasetimesi 109 releasetimesi releasetimesi1 keyspress contain lowercas english letter slowestkey
given integ num find closest two integ absolut differ whose product equal num 1 num 2 return two integ order exampl 1 input num 8 output 33 explan num 1 9 closest divisor 3 3 num 2 10 closest divisor 2 5 henc 3 3 chosen exampl 2 input num 123 output 525 exampl 3 input num 999 output 4025 constraint 1 num 109 closestdivisor
given 0index array string num string equal length consist digit also given 0index 2d integ array queri queriesi ki trimi queriesi need trim number num rightmost trimi digit determin index kith smallest trim number num two trim number equal number lower index consid smaller reset number num origin length return array answer length queri answeri answer ith queri note trim rightmost x digit mean keep remov leftmost digit x digit remain string num may contain lead zero exampl 1 input num 102473251814 queri 11234212 output 2210 explan 1 trim last digit num 2314 smallest number 1 index 2 2 trim last 3 digit num unchang 2nd smallest number 251 index 2 3 trim last 2 digit num 02735114 4th smallest number 73 4 trim last 2 digit smallest number 2 index 0 note trim number 02 evalu 2 exampl 2 input num 24379604 queri 2122 output 30 explan 1 trim last digit num 4764 2nd smallest number 4 index 3 two occurr 4 one index 0 consid smaller one index 3 2 trim last 2 digit num unchang 2nd smallest number 24 constraint 1 numslength 100 1 numsilength 100 numsi consist digit numsilength equal 1 querieslength 100 queriesilength 2 1 ki numslength 1 trimi numsilength follow could use radix sort algorithm solv problem complex solut querykthsmallesttrimmednumb
given 1index x n integ matrix mat select cell matrix start cell start cell move cell row column valu destin cell strictli greater valu current cell repeat process mani time possibl move cell cell longer make move task find maximum number cell visit matrix start cell return integ denot maximum number cell visit exampl 1 input mat 3134 output 2 explan imag show visit 2 cell start row 1 column 2 shown visit 2 cell matter start answer 2 exampl 2 input mat 1111 output 1 explan sinc cell must strictli increas visit one cell exampl exampl 3 input mat 316957 output 4 explan imag show visit 4 cell start row 2 column 1 shown visit 4 cell matter start answer 4 constraint matlength n matilength 1 n 105 1 n 105 105 matij 105 maximumstrictlyincreasingcellsinamatrix
given sort integ array arr two integ k x return k closest integ x array result also sort ascend order integ closer x integ b x b x x b x b exampl 1 input arr 12345 k 4 x 3 output 1234 exampl 2 input arr 12345 k 4 x 1 output 1234 constraint 1 k arrlength 1 arrlength 104 arr sort ascend order 104 arri x 104 findkclosestel
given string text split k substr subtext1 subtext2 subtextk subtexti nonempti string concaten substr equal text ie subtext1 subtext2 subtextk text subtexti subtextk 1 valid valu ie 1 k return largest possibl valu k exampl 1 input text ghiabcdefhelloadamhelloabcdefghi output 7 explan split string ghiabcdefhelloadamhelloabcdefghi exampl 2 input text merchant output 1 explan split string merchant exampl 3 input text antaprezatepzapreanta output 11 explan split string antaprezatepzapreanta constraint 1 textlength 1000 text consist lowercas english charact longestchunkedpalindromedecomposit
given x n matrix mat integ k return matrix answer answerij sum element matrc k r k j k c j k r c valid posit matrix exampl 1 input mat 123456789 k 1 output 122116274533243928 exampl 2 input mat 123456789 k 2 output 454545454545454545 constraint matlength n matilength 1 n k 100 1 matij 100 matrixblocksum
given two posit integ b return number common factor b integ x common factor b x divid b exampl 1 input 12 b 6 output 4 explan common factor 12 6 1 2 3 6 exampl 2 input 25 b 30 output 2 explan common factor 25 30 1 5 constraint 1 b 1000 numberofcommonfactor
given integ array num return number longest increas subsequ notic sequenc strictli increas exampl 1 input num 13547 output 2 explan two longest increas subsequ 1 3 4 7 1 3 5 7 exampl 2 input num 22222 output 5 explan length longest increas subsequ 1 5 increas subsequ length 1 output 5 constraint 1 numslength 2000 106 numsi 106 numberoflongestincreasingsubsequ
given input string pattern p implement regular express match support match singl charact match zero preced element match cover entir input string partial exampl 1 input aa p output fals explan match entir string aa exampl 2 input aa p output true explan mean zero preced element therefor repeat becom aa exampl 3 input ab p output true explan mean zero charact constraint 1 slength 20 1 plength 20 contain lowercas english letter p contain lowercas english letter guarante appear charact previou valid charact match regularexpressionmatch
nn grid snake span 2 cell start move top left corner 0 0 0 1 grid empti cell repres zero block cell repres one snake want reach lower right corner n1 n2 n1 n1 one move snake move one cell right block cell move keep horizontalvert posit snake move one cell block cell move keep horizontalvert posit snake rotat clockwis horizont posit two cell empti case snake move r c r c1 r c r1 c rotat counterclockwis vertic posit two cell right empti case snake move r c r1 c r c r c1 return minimum number move reach target way reach target return 1 exampl 1 input grid 000001 110010 000011 001010 011000 011000 output 11 explan one possibl solut right right rotat clockwis right rotat counterclockwis right exampl 2 input grid 001111 000011 110001 111001 111001 111000 output 9 constraint 2 n 100 0 gridij 1 guarante snake start empti cell minimummovestoreachtargetwithrot
given head link list return list sort ascend order exampl 1 input head 4213 output 1234 exampl 2 input head 15340 output 10345 exampl 3 input head output constraint number node list rang 0 5 104 105 nodev 105 follow sort link list logn time o1 memori ie constant space sortlist
given root binari tree node valu rang 0 25 repres letter z return lexicograph smallest string start leaf tree end root remind shorter prefix string lexicograph smaller exampl ab lexicograph smaller aba leaf node node children exampl 1 input root 0123434 output dba exampl 2 input root 25131302 output adz exampl 3 input root 221null10null0 output abc constraint number node tree rang 1 8500 0 nodev 25 smalleststringstartingfromleaf
instal billboard want largest height billboard two steel support one side steel support must equal height given collect rod weld togeth exampl rod length 1 2 3 weld togeth make support length 6 return largest possibl height billboard instal support billboard return 0 exampl 1 input rod 1236 output 6 explan two disjoint subset 123 6 sum 6 exampl 2 input rod 123456 output 10 explan two disjoint subset 235 46 sum 10 exampl 3 input rod 12 output 0 explan billboard support return 0 constraint 1 rodslength 20 1 rodsi 1000 sumrodsi 5000 tallestbillboard
given string consist charact b delet number charact make balanc balanc pair indic ij j si b sj return minimum number delet need make balanc exampl 1 input aababbab output 2 explan either delet charact 0index posit 2 6 aababbab aaabbb delet charact 0index posit 3 6 aababbab aabbbb exampl 2 input bbaaaaabb output 2 explan solut delet first two charact constraint 1 slength 105 si b minimumdeletionstomakestringbalanc
given 0index integ array num numsi digit 0 9 inclus triangular sum num valu element present num follow process termin let num compris n element n 1 end process otherwis creat new 0index integ array newnum length n 1 index 0 n 1 assign valu newnumsi numsi numsi1 10 denot modulo oper replac array num newnum repeat entir process start step 1 return triangular sum num exampl 1 input num 12345 output 8 explan diagram depict process obtain triangular sum array exampl 2 input num 5 output 5 explan sinc one element num triangular sum valu element constraint 1 numslength 1000 0 numsi 9 findtriangularsumofanarray
thief found new place thieveri one entranc area call root besid root hous one one parent hous tour smart thief realiz hous place form binari tree automat contact polic two directlylink hous broken night given root binari tree return maximum amount money thief rob without alert polic exampl 1 input root 323null3null1 output 7 explan maximum amount money thief rob 3 3 1 7 exampl 2 input root 34513null1 output 9 explan maximum amount money thief rob 4 5 9 constraint number node tree rang 1 104 0 nodev 104 houserobberiii
given integ rowindex return rowindexth 0index row pascal triangl pascal triangl number sum two number directli shown exampl 1 input rowindex 3 output 1331 exampl 2 input rowindex 0 output 1 exampl 3 input rowindex 1 output 11 constraint 0 rowindex 33 follow could optim algorithm use orowindex extra space pascalstriangleii
given integ array num length n integ numslot 2 numslot n numslot slot number 1 numslot place n integ slot slot contain two number sum given placement sum bitwis everi number respect slot number exampl sum place number 1 3 slot 1 4 6 slot 2 equal 1 1 3 1 4 2 6 2 1 1 0 2 4 return maximum possibl sum num given numslot slot exampl 1 input num 123456 numslot 3 output 9 explan one possibl placement 1 4 slot 1 2 6 slot 2 3 5 slot 3 give maximum sum 1 1 4 1 2 2 6 2 3 3 5 3 1 0 2 2 3 1 9 exampl 2 input num 1310471 numslot 9 output 24 explan one possibl placement 1 1 slot 1 3 slot 3 4 slot 4 7 slot 7 10 slot 9 give maximum sum 1 1 1 1 3 3 4 4 7 7 10 9 1 1 3 4 7 8 24 note slot 2 5 6 8 empti permit constraint n numslength 1 numslot 9 1 n 2 numslot 1 numsi 15 maximumandsumofarray
n employe uniqu id 0 n 1 given 2d integ array log logsi idi leavetimei idi id employe work ith task leavetimei time employe finish ith task valu leavetimei uniqu note ith task start moment right 1th task end 0th task start time 0 return id employe work task longest time tie two employe return smallest id among exampl 1 input n 10 log 032509115 output 1 explan task 0 start 0 end 3 3 unit time task 1 start 3 end 5 2 unit time task 2 start 5 end 9 4 unit time task 3 start 9 end 15 6 unit time task longest time task 3 employe id 1 one work return 1 exampl 2 input n 26 log 1137212717 output 3 explan task 0 start 0 end 1 1 unit time task 1 start 1 end 7 6 unit time task 2 start 7 end 12 5 unit time task 3 start 12 end 17 5 unit time task longest time task 1 employe work 3 return 3 exampl 3 input n 2 log 010120 output 0 explan task 0 start 0 end 10 10 unit time task 1 start 10 end 20 10 unit time task longest time task 0 1 employe work 0 1 return smallest id 0 constraint 2 n 500 1 logslength 500 logsilength 2 0 idi n 1 1 leavetimei 500 idi idi1 leavetimei sort strictli increas order theemployeethatworkedonthelongesttask
given 0index integ array num contain n distinct posit integ permut num call special index 0 n 1 either numsi numsi1 0 numsi1 numsi 0 return total number special permut answer could larg return modulo 109 7 exampl 1 input num 236 output 2 explan 362 263 two special permut num exampl 2 input num 143 output 2 explan 314 413 two special permut num constraint 2 numslength 14 1 numsi 109 specialpermut
given 0index integ array num size n find maximum differ numsi numsj ie numsj numsi 0 j n numsi numsj return maximum differ j exist return 1 exampl 1 input num 7154 output 4 explan maximum differ occur 1 j 2 numsj numsi 5 1 4 note 1 j 0 differ numsj numsi 7 1 6 j valid exampl 2 input num 9432 output 1 explan j j numsi numsj exampl 3 input num 15210 output 9 explan maximum differ occur 0 j 3 numsj numsi 10 1 9 constraint n numslength 2 n 1000 1 numsi 109 maximumdifferencebetweenincreasingel
write code enhanc array call arraygroupbyfn method array return group version array group array object key output fnarri valu array contain item origin array key provid callback fn accept item array return string key order valu list order item appear array order key accept pleas solv without lodash groupbi function exampl 1 input array id1 id1 id2 fn function item return itemid output 1 id 1 id 1 2 id 2 explan output arraygroupbyfn selector function get id item array two object id 1 object put first array one object id 2 object put second array exampl 2 input array 1 2 3 1 3 5 1 5 9 fn function list return stringlist0 output 1 1 2 3 1 3 5 1 5 9 explan array type case selector function defin key first element array array 1 first element group togeth 1 1 2 3 1 3 5 1 5 9 exampl 3 input array 1 2 3 4 5 6 7 8 9 10 fn function n return stringn 5 output true 6 7 8 9 10 fals 1 2 3 4 5 explan selector function split array whether number greater 5 constraint 0 arraylength 105 fn return string groupbi
given integ hoursbefor number hour travel meet arriv meet travel n road road length given integ array dist length n disti describ length ith road kilomet addit given integ speed speed kmh travel travel road must rest wait next integ hour begin travel next road note rest travel last road alreadi meet exampl travel road take 14 hour must wait 2 hour mark travel next road travel road take exactli 2 hour need wait howev allow skip rest abl arriv time mean need wait next integ hour note mean may finish travel futur road differ hour mark exampl suppos travel first road take 14 hour travel second road take 06 hour skip rest first road mean finish travel second road right 2 hour mark let start travel third road immedi return minimum number skip requir arriv meet time 1 imposs exampl 1 input dist 132 speed 4 hoursbefor 2 output 1 explan without skip rest arriv 14 34 34 14 24 25 hour skip first rest arriv 14 0 34 0 24 15 hour note second rest shorten finish travel second road integ hour due skip first rest exampl 2 input dist 7355 speed 2 hoursbefor 10 output 2 explan without skip rest arriv 72 12 32 12 52 12 52 115 hour skip first third rest arriv 72 0 32 0 52 0 52 10 hour exampl 3 input dist 7355 speed 1 hoursbefor 10 output 1 explan imposs arriv meet time even skip rest constraint n distlength 1 n 1000 1 disti 105 1 speed 106 1 hoursbefor 107 minimumskipstoarriveatmeetingontim
given posit integ 0index array num subset array num squarefre product element squarefre integ squarefre integ integ divis squar number 1 return number squarefre nonempti subset array num sinc answer may larg return modulo 109 7 nonempti subset num array obtain delet possibl none element num two subset differ chosen indic delet differ exampl 1 input num 3445 output 3 explan 3 squarefre subset exampl subset consist 0th element 3 product element 3 squarefre integ subset consist 3rd element 5 product element 5 squarefre integ subset consist 0th 3rd element 35 product element 15 squarefre integ proven 3 squarefre subset given array exampl 2 input num 1 output 1 explan 1 squarefre subset exampl subset consist 0th element 1 product element 1 squarefre integ proven 1 squarefre subset given array constraint 1 numslength 1000 1 numsi 30 countthenumberofsquarefreesubset
given integ array num 0index two integ target start find index numsi target absi start minim note absx absolut valu x return absi start guarante target exist num exampl 1 input num 12345 target 5 start 3 output 1 explan nums4 5 valu equal target answer abs4 3 1 exampl 2 input num 1 target 1 start 0 output 0 explan nums0 1 valu equal target answer abs0 0 0 exampl 3 input num 1111111111 target 1 start 0 output 0 explan everi valu num 1 nums0 minim absi start abs0 0 0 constraint 1 numslength 1000 1 numsi 104 0 start numslength target num minimumdistancetothetargetel
addit number string whose digit form addit sequenc valid addit sequenc contain least three number except first two number subsequ number sequenc must sum preced two given string contain digit return true addit number fals otherwis note number addit sequenc lead zero sequenc 1 2 03 1 02 3 invalid exampl 1 input 112358 output true explan digit form addit sequenc 1 1 2 3 5 8 1 1 2 1 2 3 2 3 5 3 5 8 exampl 2 input 199100199 output true explan addit sequenc 1 99 100 199 1 99 100 99 100 199 constraint 1 numlength 35 num consist digit follow would handl overflow larg input integ additivenumb
n task assign task time repres integ array task length n ith task take tasksi hour finish work session work sessiontim consecut hour take break finish given task way satisfi follow condit start task work session must complet work session start new task immedi finish previou one may complet task order given task sessiontim return minimum number work session need finish task follow condit test gener sessiontim greater equal maximum element tasksi exampl 1 input task 123 sessiontim 3 output 2 explan finish task two work session first work session finish first second task 1 2 3 hour second work session finish third task 3 hour exampl 2 input task 31311 sessiontim 8 output 2 explan finish task two work session first work session finish task except last one 3 1 3 1 8 hour second work session finish last task 1 hour exampl 3 input task 12345 sessiontim 15 output 1 explan finish task one work session constraint n taskslength 1 n 14 1 tasksi 10 maxtasksi sessiontim 15 minimumnumberofworksessionstofinishthetask
school tri take annual photo student student ask stand singl file line nondecreas order height let order repres integ array expect expectedi expect height ith student line given integ array height repres current order student stand heightsi height ith student line 0index return number indic heightsi expectedi exampl 1 input height 114213 output 3 explan height 114213 expect 111234 indic 2 4 5 match exampl 2 input height 51234 output 5 explan height 51234 expect 12345 indic match exampl 3 input height 12345 output 0 explan height 12345 expect 12345 indic match constraint 1 heightslength 100 1 heightsi 100 heightcheck
given integ array uniqu posit integ num consid follow graph numslength node label nums0 numsnumslength 1 undirect edg numsi numsj numsi numsj share common factor greater 1 return size largest connect compon graph exampl 1 input num 461535 output 4 exampl 2 input num 2050963 output 2 exampl 3 input num 23674122139 output 8 constraint 1 numslength 2 104 1 numsi 105 valu num uniqu largestcomponentsizebycommonfactor
given array num n posit integ perform two type oper element array number time element even divid 2 exampl array 1234 oper last element array 1232 element odd multipli 2 exampl array 1234 oper first element array 2234 deviat array maximum differ two element array return minimum deviat array perform number oper exampl 1 input num 1234 output 1 explan transform array 1232 2232 deviat 3 2 1 exampl 2 input num 415203 output 3 explan transform array two oper 42553 deviat 5 2 3 exampl 3 input num 2108 output 3 constraint n numslength 2 n 5 104 1 numsi 109 minimizedeviationinarray
given 0index string repeatedli perform follow oper number time choos index string let c charact posit delet closest occurr c left closest occurr c right task minim length perform oper number time return integ denot length minim string exampl 1 input aaabc output 3 explan exampl aaabc start select charact index 1 remov closest left index 1 index 0 closest right index 1 index 2 oper string becom abc oper perform string leav unchang therefor length minim string 3 exampl 2 input cbbd output 3 explan start charact b index 1 occurr b left index 1 one right index 2 delet b index 2 string becom cbd oper leav unchang henc minim length 3 exampl 3 input dddaaa output 2 explan start charact index 1 closest occurr left index 0 closest occurr right index 2 delet index 0 2 string becom daaa new string select charact index 2 closest occurr left index 1 closest occurr right index 3 delet string becom da minim minim length 2 constraint 1 slength 100 contain lowercas english letter minimizestringlength
sql schema tabl seat column name type id int student varchar id primari key column tabl row tabl indic name id student id continu increment write sql queri swap seat id everi two consecut student number student odd id last student swap return result tabl order id ascend order queri result format follow exampl exampl 1 input seat tabl id student 1 abbot 2 dori 3 emerson 4 green 5 jeam output id student 1 dori 2 abbot 3 green 4 emerson 5 jeam explan note number student odd need chang last one seat exchangeseat
given integ array num return triplet numsi numsj numsk j k j k numsi numsj numsk 0 notic solut set must contain duplic triplet exampl 1 input num 101214 output 112101 explan nums0 nums1 nums2 1 0 1 0 nums1 nums2 nums4 0 1 1 0 nums0 nums3 nums4 1 2 1 0 distinct triplet 101 112 notic order output order triplet matter exampl 2 input num 011 output explan possibl triplet sum 0 exampl 3 input num 000 output 000 explan possibl triplet sum 0 constraint 3 numslength 3000 105 numsi 105 3sum
password said strong satisfi follow criteria least 8 charact contain least one lowercas letter contain least one uppercas letter contain least one digit contain least one special charact special charact charact follow string contain 2 charact adjac posit ie aab violat condit aba given string password return true strong password otherwis return fals exampl 1 input password ilovele3tcod output true explan password meet requir therefor return true exampl 2 input password meyouismydream output fals explan password contain digit also contain 2 charact adjac posit therefor return fals exampl 3 input password 1ab output fals explan password meet length requir therefor return fals constraint 1 passwordlength 100 password consist letter digit special charact strongpasswordcheckerii
given array arr replac everi element array greatest element among element right replac last element 1 return array exampl 1 input arr 17185461 output 1866611 explan index 0 greatest element right index 0 index 1 18 index 1 greatest element right index 1 index 4 6 index 2 greatest element right index 2 index 4 6 index 3 greatest element right index 3 index 4 6 index 4 greatest element right index 4 index 5 1 index 5 element right index 5 put 1 exampl 2 input arr 400 output 1 explan element right index 0 constraint 1 arrlength 104 1 arri 105 replaceelementswithgreatestelementonrightsid
given binari tree root integ target delet leaf node valu target note delet leaf node valu target parent node becom leaf node valu target also delet need continu exampl 1 input root 1232null24 target 2 output 1null3null4 explan leaf node green valu target 2 remov pictur left remov new node becom leaf node valu target 2 pictur center exampl 2 input root 13332 target 3 output 13nullnull2 exampl 3 input root 12null2null2 target 2 output 1 explan leaf node green valu target 2 remov step constraint number node tree rang 1 3000 1 nodev target 1000 deleteleaveswithagivenvalu
given integ n return string n charact charact string occur odd number time return string must contain lowercas english letter multipl valid string return exampl 1 input n 4 output pppz explan pppz valid string sinc charact p occur three time charact z occur note mani valid string ohhh love exampl 2 input n 2 output xy explan xy valid string sinc charact x occur note mani valid string ag ur exampl 3 input n 7 output holasss constraint 1 n 500 generateastringwithcharactersthathaveoddcount
given encod string decod string tape encod string read one charact time follow step taken charact read letter letter written onto tape charact read digit entir current tape repeatedli written 1 time total given integ k return kth letter 1index decod string exampl 1 input leet2code3 k 10 output explan decod string leetleetcodeleetleetcodeleetleetcod 10th letter string exampl 2 input ha22 k 5 output h explan decod string hahahaha 5th letter h exampl 3 input a2345678999999999999999 k 1 output explan decod string repeat 8301530446056247680 time 1st letter constraint 2 slength 100 consist lowercas english letter digit 2 9 start letter 1 k 109 guarante k less equal length decod string decod string guarante less 263 letter decodedstringatindex
given array string num contain n uniqu binari string length n return binari string length n appear num multipl answer may return exampl 1 input num 0110 output 11 explan 11 appear num 00 would also correct exampl 2 input num 0001 output 11 explan 11 appear num 10 would also correct exampl 3 input num 111011001 output 101 explan 101 appear num 000 010 100 110 would also correct constraint n numslength 1 n 16 numsilength n numsi either 0 1 string num uniqu finduniquebinarystr
given array posit integ arr perform oper possibl none arr satisfi condit valu first element arr must 1 absolut differ 2 adjac element must less equal 1 word absarri arri 1 1 1 arrlength 0index absx absolut valu x 2 type oper perform number time decreas valu element arr smaller posit integ rearrang element arr order return maximum possibl valu element arr perform oper satisfi condit exampl 1 input arr 22121 output 2 explan satisfi condit rearrang arr becom 12221 largest element arr 2 exampl 2 input arr 10011000 output 3 explan one possibl way satisfi condit follow 1 rearrang arr becom 11001000 2 decreas valu second element 2 3 decreas valu third element 3 arr 123 satisfi condit largest element arr 3 exampl 3 input arr 12345 output 5 explan array alreadi satisfi condit largest element 5 constraint 1 arrlength 105 1 arri 109 maximumelementafterdecreasingandrearrang
demon captur princess imprison bottomright corner dungeon dungeon consist x n room laid 2d grid valiant knight initi posit topleft room must fight way dungeon rescu princess knight initi health point repres posit integ point health point drop 0 die immedi room guard demon repres neg integ knight lose health upon enter room room either empti repres 0 contain magic orb increas knight health repres posit integ reach princess quickli possibl knight decid move rightward downward step return knight minimum initi health rescu princess note room contain threat powerup even first room knight enter bottomright room princess imprison exampl 1 input dungeon 233510110305 output 7 explan initi health knight must least 7 follow optim path right right exampl 2 input dungeon 0 output 1 constraint dungeonlength n dungeonilength 1 n 200 1000 dungeonij 1000 dungeongam
happi string string consist letter set b c si si 1 valu 1 slength 1 string 1index exampl string abc ac b abcbabcbcb happi string string aa baa ababbc happi string given two integ n k consid list happi string length n sort lexicograph order return kth string list return empti string less k happi string length n exampl 1 input n 1 k 3 output c explan list b c contain happi string length 1 third string c exampl 2 input n 1 k 4 output explan 3 happi string length 1 exampl 3 input n 3 k 9 output cab explan 12 differ happi string length 3 aba abc aca acb bab bac bca bcb cab cac cba cbc find 9th string cab constraint 1 n 10 1 k 100 thekthlexicographicalstringofallhappystringsoflengthn
given integ n indic n specialti retail store product type vari amount given 0index integ array quantiti quantitiesi repres number product ith product type need distribut product retail store follow rule store given one product type given amount distribut store given number product possibl 0 let x repres maximum number product given store want x small possibl ie want minim maximum number product given store return minimum possibl x exampl 1 input n 6 quantiti 116 output 3 explan one optim way 11 product type 0 distribut first four store amount 2 3 3 3 6 product type 1 distribut two store amount 3 3 maximum number product given store max2 3 3 3 3 3 3 exampl 2 input n 7 quantiti 151010 output 5 explan one optim way 15 product type 0 distribut first three store amount 5 5 5 10 product type 1 distribut next two store amount 5 5 10 product type 2 distribut last two store amount 5 5 maximum number product given store max5 5 5 5 5 5 5 5 exampl 3 input n 1 quantiti 100000 output 100000 explan optim way 100000 product type 0 distribut store maximum number product given store max100000 100000 constraint quantitieslength 1 n 105 1 quantitiesi 105 minimizedmaximumofproductsdistributedtoanystor
given 0index integ array candi element array denot pile candi size candiesi divid pile number sub pile merg two pile togeth also given integ k alloc pile candi k children child get number candi child take one pile candi pile candi may go unus return maximum number candi child get exampl 1 input candi 586 k 3 output 5 explan divid candies1 2 pile size 5 3 candies2 2 pile size 5 1 five pile candi size 5 5 3 5 1 alloc 3 pile size 5 3 children proven child receiv 5 candi exampl 2 input candi 25 k 11 output 0 explan 11 children 7 candi total imposs ensur child receiv least one candi thu child get candi answer 0 constraint 1 candieslength 105 1 candiesi 107 1 k 1012 maximumcandiesallocatedtokchildren
robot infinit xyplan start point 0 0 face north robot receiv sequenc three possibl type command 2 turn left 90 degre 1 turn right 90 degre 1 k 9 move forward k unit one unit time grid squar obstacl ith obstacl grid point obstaclesi xi yi robot run obstacl instead stay current locat move next command return maximum euclidean distanc robot ever get origin squar ie distanc 5 return 25 note north mean direct east mean x direct south mean direct west mean x direct exampl 1 input command 413 obstacl output 25 explan robot start 0 0 1 move north 4 unit 0 4 2 turn right 3 move east 3 unit 3 4 furthest point robot ever get origin 3 4 squar 32 42 25 unit away exampl 2 input command 41424 obstacl 24 output 65 explan robot start 0 0 1 move north 4 unit 0 4 2 turn right 3 move east 1 unit get block obstacl 2 4 robot 1 4 4 turn left 5 move north 4 unit 1 8 furthest point robot ever get origin 1 8 squar 12 82 65 unit away exampl 3 input command 6116 obstacl output 36 explan robot start 0 0 1 move north 6 unit 0 6 2 turn right 3 turn right 4 move south 6 unit 0 0 furthest point robot ever get origin 0 6 squar 62 36 unit away constraint 1 commandslength 104 commandsi either 2 1 integ rang 1 9 0 obstacleslength 104 3 104 xi yi 3 104 answer guarante less 231 walkingrobotsimul
design timebas keyvalu data structur store multipl valu key differ time stamp retriev key valu certain timestamp implement timemap class timemap initi object data structur void setstr key string valu int timestamp store key key valu valu given time timestamp string getstr key int timestamp return valu set call previous timestampprev timestamp multipl valu return valu associ largest timestampprev valu return exampl 1 input timemap set get get set get get foo bar 1 foo 1 foo 3 foo bar2 4 foo 4 foo 5 output null null bar bar null bar2 bar2 explan timemap timemap new timemap timemapsetfoo bar 1 store key foo valu bar along timestamp 1 timemapgetfoo 1 return bar timemapgetfoo 3 return bar sinc valu correspond foo timestamp 3 timestamp 2 valu timestamp 1 bar timemapsetfoo bar2 4 store key foo valu bar2 along timestamp 4 timemapgetfoo 4 return bar2 timemapgetfoo 5 return bar2 constraint 1 keylength valuelength 100 key valu consist lowercas english letter digit 1 timestamp 107 timestamp timestamp set strictli increas 2 105 call made set get timebasedkeyvaluestor
given x n matrix distinct number return lucki number matrix order lucki number element matrix minimum element row maximum column exampl 1 input matrix 37891113151617 output 15 explan 15 lucki number sinc minimum row maximum column exampl 2 input matrix 11042938715161712 output 12 explan 12 lucki number sinc minimum row maximum column exampl 3 input matrix 7812 output 7 explan 7 lucki number sinc minimum row maximum column constraint matlength n matilength 1 n 50 1 matrixij 105 element matrix distinct luckynumbersinamatrix
n worker given two integ array qualiti wage qualityi qualiti ith worker wagei minimum wage expect ith worker want hire exactli k worker form paid group hire group k worker must pay accord follow rule everi worker paid group paid ratio qualiti compar worker paid group everi worker paid group must paid least minimum wage expect given integ k return least amount money need form paid group satisfi condit answer within 105 actual answer accept exampl 1 input qualiti 10205 wage 705030 k 2 output 10500000 explan pay 70 0th worker 35 2nd worker exampl 2 input qualiti 3110101 wage 48227 k 3 output 3066667 explan pay 4 0th worker 1333333 2nd 3rd worker separ constraint n qualitylength wagelength 1 k n 104 1 qualityi wagei 104 minimumcosttohirekwork
given list string length word string target task form target use given word follow rule target form left right form ith charact 0index target choos kth charact jth string word targeti wordsjk use kth charact jth string word longer use xth charact string word x k word charact left index k becom unusu everi string repeat process form string target notic use multipl charact string word provid condit met return number way form target word sinc answer may larg return modulo 109 7 exampl 1 input word accabbbbcaca target aba output 6 explan 6 way form target aba index 0 acca index 1 bbbb index 3 caca aba index 0 acca index 2 bbbb index 3 caca aba index 0 acca index 1 bbbb index 3 acca aba index 0 acca index 2 bbbb index 3 acca aba index 1 caca index 2 bbbb index 3 acca aba index 1 caca index 2 bbbb index 3 caca exampl 2 input word abbabaab target bab output 4 explan 4 way form target bab index 0 baab index 1 baab index 2 abba bab index 0 baab index 1 baab index 3 baab bab index 0 baab index 2 baab index 3 baab bab index 1 abba index 2 baab index 3 baab constraint 1 wordslength 1000 1 wordsilength 1000 string word length 1 targetlength 1000 wordsi target contain lowercas english letter numberofwaystoformatargetstringgivenadictionari
given stream n video repres distinct number 1 n need upload server need implement data structur calcul length longest upload prefix variou point upload process consid upload prefix video rang 1 inclus upload server longest upload prefix maximum valu satisfi definit implement luprefix class luprefixint n initi object stream n video void uploadint video upload video server int longest return length longest upload prefix defin exampl 1 input luprefix upload longest upload longest upload longest 4 3 1 2 output null null 0 null 1 null 3 explan luprefix server new luprefix4 initi stream 4 video serverupload3 upload video 3 serverlongest sinc video 1 upload yet prefix return 0 serverupload1 upload video 1 serverlongest prefix 1 longest upload prefix return 1 serverupload2 upload video 2 serverlongest prefix 123 longest upload prefix return 3 constraint 1 n 105 1 video n valu video distinct 2 105 call total made upload longest least one call made longest longestuploadedprefix
given 0index array num consist n distinct posit integ appli oper array ith oper replac number operationsi0 operationsi1 guarante ith oper operationsi0 exist num operationsi1 exist num return array obtain appli oper exampl 1 input num 1246 oper 134761 output 3271 explan perform follow oper num replac number 1 3 num becom 3246 replac number 4 7 num becom 3276 replac number 6 1 num becom 3271 return final array 3271 exampl 2 input num 12 oper 132132 output 21 explan perform follow oper num replac number 1 3 num becom 32 replac number 2 1 num becom 31 replac number 3 2 num becom 21 return array 21 constraint n numslength operationslength 1 n 105 valu num distinct operationsilength 2 1 numsi operationsi0 operationsi1 106 operationsi0 exist num appli ith oper operationsi1 exist num appli ith oper replaceelementsinanarray
given binari tree determin heightbalanc exampl 1 input root 3920nullnull157 output true exampl 2 input root 12233nullnull44 output fals exampl 3 input root output true constraint number node tree rang 0 5000 104 nodev 104 balancedbinarytre
given array asteroid integ repres asteroid row asteroid absolut valu repres size sign repres direct posit mean right neg mean left asteroid move speed find state asteroid collis two asteroid meet smaller one explod size explod two asteroid move direct never meet exampl 1 input asteroid 5105 output 510 explan 10 5 collid result 10 5 10 never collid exampl 2 input asteroid 88 output explan 8 8 collid explod exampl 3 input asteroid 1025 output 10 explan 2 5 collid result 5 10 5 collid result 10 constraint 2 asteroidslength 104 1000 asteroidsi 1000 asteroidsi 0 asteroidcollis
given string consist lowercas english letter allow perform oper one oper replac charact anoth lowercas english letter task make palindrom minimum number oper possibl multipl palindrom made use minimum number oper make lexicograph smallest one string lexicograph smaller string b length first posit b differ string letter appear earlier alphabet correspond letter b return result palindrom string exampl 1 input egcf output efcf explan minimum number oper make egcf palindrom 1 lexicograph smallest palindrom string get modifi one charact efcf chang g exampl 2 input abcd output abba explan minimum number oper make abcd palindrom 2 lexicograph smallest palindrom string get modifi two charact abba exampl 3 input seven output neven explan minimum number oper make seven palindrom 1 lexicograph smallest palindrom string get modifi one charact neven constraint 1 slength 1000 consist lowercas english letter lexicographicallysmallestpalindrom
given sentenc consist word separ singl space searchword check searchword prefix word sentenc return index word sentenc 1index searchword prefix word searchword prefix one word return index first word minimum index word return 1 prefix string lead contigu substr exampl 1 input sentenc love eat burger searchword burg output 4 explan burg prefix burger 4th word sentenc exampl 2 input sentenc problem easi problem searchword pro output 2 explan pro prefix problem 2nd 6th word sentenc return 2 minim index exampl 3 input sentenc tire searchword output 1 explan prefix word sentenc constraint 1 sentencelength 100 1 searchwordlength 10 sentenc consist lowercas english letter space searchword consist lowercas english letter checkifawordoccursasaprefixofanywordinasent
given seri video clip sport event last time second video clip overlap vari length video clip describ array clip clipsi starti endi indic ith clip start starti end endi cut clip segment freeli exampl clip 0 7 cut segment 0 1 1 3 3 7 return minimum number clip need cut clip segment cover entir sport event 0 time task imposs return 1 exampl 1 input clip 0246810191559 time 10 output 3 explan take clip 02 810 19 total 3 clip reconstruct sport event follow cut 19 segment 12 28 89 segment 02 28 810 cover sport event 0 10 exampl 2 input clip 0112 time 5 output 1 explan cover 05 01 12 exampl 3 input clip 01680256040367134714252634455769 time 9 output 3 explan take clip 04 47 69 constraint 1 clipslength 100 0 starti endi 100 1 time 100 videostitch
given head singli link list revers list return revers list exampl 1 input head 12345 output 54321 exampl 2 input head 12 output 21 exampl 3 input head output constraint number node list rang 0 5000 5000 nodev 5000 follow link list revers either iter recurs could implement reverselinkedlist
given binari string posit integ n return true binari represent integ rang 1 n substr fals otherwis substr contigu sequenc charact within string exampl 1 input 0110 n 3 output true exampl 2 input 0110 n 4 output fals constraint 1 slength 1000 si either 0 1 1 n 109 binarystringwithsubstringsrepresenting1ton
nearli everyon use multipl tabl multipl tabl size x n integ matrix mat matij j 1index given three integ n k return kth smallest element x n multipl tabl exampl 1 input 3 n 3 k 5 output 3 explan 5th smallest number 3 exampl 2 input 2 n 3 k 6 output 6 explan 6th smallest number 6 constraint 1 n 3 104 1 k n kthsmallestnumberinmultiplicationt
given two integ array preorder postord preorder preorder travers binari tree distinct valu postord postord travers tree reconstruct return binari tree exist multipl answer return exampl 1 input preorder 1245367 postord 4526731 output 1234567 exampl 2 input preorder 1 postord 1 output 1 constraint 1 preorderlength 30 1 preorderi preorderlength valu preorder uniqu postorderlength preorderlength 1 postorderi postorderlength valu postord uniqu guarante preorder postord preorder travers postord travers binari tree constructbinarytreefrompreorderandpostordertravers
two fruit basket contain n fruit given two 0index integ array basket1 basket2 repres cost fruit basket want make basket equal use follow oper mani time want chose two indic j swap ith fruit basket1 jth fruit basket2 cost swap minbasket1ibasket2j two basket consid equal sort accord fruit cost make exactli basket return minimum cost make basket equal 1 imposs exampl 1 input basket1 4222 basket2 1412 output 1 explan swap index 1 basket1 index 0 basket2 cost 1 basket1 4122 basket2 2412 rearrang array make equal exampl 2 input basket1 2341 basket2 3251 output 1 explan shown imposs make basket equal constraint basket1length bakste2length 1 basket1length 105 1 basket1ibasket2i 109 rearrangingfruit
perfect number posit integ equal sum posit divisor exclud number divisor integ x integ divid x evenli given integ n return true n perfect number otherwis return fals exampl 1 input num 28 output true explan 28 1 2 4 7 14 1 2 4 7 14 divisor 28 exampl 2 input num 7 output fals constraint 1 num 108 perfectnumb
design data structur support ad new word find string match previous ad string implement worddictionari class worddictionari initi object void addwordword add word data structur match later bool searchword return true string data structur match word fals otherwis word may contain dot dot match letter exampl input worddictionaryaddwordaddwordaddwordsearchsearchsearchsearch baddadmadpadbadadb output nullnullnullnullfalsetruetruetru explan worddictionari worddictionari new worddictionari worddictionaryaddwordbad worddictionaryaddworddad worddictionaryaddwordmad worddictionarysearchpad return fals worddictionarysearchbad return true worddictionarysearchad return true worddictionarysearchb return true constraint 1 wordlength 25 word addword consist lowercas english letter word search consist lowercas english letter 2 dot word search queri 104 call made addword search designaddandsearchwordsdatastructur
given singl posit integ x write express form x op1 x op2 x op3 x oper op1 op2 etc either addit subtract multipl divis exampl x 3 might write 3 3 3 3 3 valu 3 write express adher follow convent divis oper return ration number parenthes place anywher use usual order oper multipl divis happen addit subtract allow use unari negat oper exampl x x valid express use subtract x x use negat would like write express least number oper express equal given target return least number oper use exampl 1 input x 3 target 19 output 5 explan 3 3 3 3 3 3 express contain 5 oper exampl 2 input x 5 target 501 output 8 explan 5 5 5 5 5 5 5 5 5 express contain 8 oper exampl 3 input x 100 target 100000000 output 3 explan 100 100 100 100 express contain 3 oper constraint 2 x 100 1 target 2 108 leastoperatorstoexpressnumb
n task worker task strength requir store 0index integ array task ith task requir tasksi strength complet strength worker store 0index integ array worker jth worker workersj strength worker assign singl task must strength greater equal task strength requir ie workersj tasksi addit pill magic pill increas worker strength strength decid worker receiv magic pill howev may give worker one magic pill given 0index integ array task worker integ pill strength return maximum number task complet exampl 1 input task 321 worker 033 pill 1 strength 1 output 3 explan assign magic pill task follow give magic pill worker 0 assign worker 0 task 2 0 1 1 assign worker 1 task 1 3 2 assign worker 2 task 0 3 3 exampl 2 input task 54 worker 000 pill 1 strength 5 output 1 explan assign magic pill task follow give magic pill worker 0 assign worker 0 task 0 0 5 5 exampl 3 input task 101530 worker 010101010 pill 3 strength 10 output 2 explan assign magic pill task follow give magic pill worker 0 worker 1 assign worker 0 task 0 0 10 10 assign worker 1 task 1 10 10 15 last pill given make worker strong enough last task constraint n taskslength workerslength 1 n 5 104 0 pill 0 tasksi workersj strength 109 maximumnumberoftasksyoucanassign
given root binari tree split binari tree two subtre remov one edg product sum subtre maxim return maximum product sum two subtre sinc answer may larg return modulo 109 7 note need maxim answer take mod take exampl 1 input root 123456 output 110 explan remov red edg get 2 binari tree sum 11 10 product 110 1110 exampl 2 input root 1null234nullnull56 output 90 explan remov red edg get 2 binari tree sum 15 6their product 90 156 constraint number node tree rang 2 5 104 1 nodev 104 maximumproductofsplittedbinarytre
bomb defus time run inform provid circular array code length n key k decrypt code must replac everi number number replac simultan k 0 replac ith number sum next k number k 0 replac ith number sum previou k number k 0 replac ith number 0 code circular next element coden1 code0 previou element code0 coden1 given circular array code integ key k return decrypt code defus bomb exampl 1 input code 5714 k 3 output 12101613 explan number replac sum next 3 number decrypt code 714 145 457 571 notic number wrap around exampl 2 input code 1234 k 0 output 0000 explan k zero number replac 0 exampl 3 input code 2493 k 2 output 125613 explan decrypt code 39 23 42 94 notic number wrap around k neg sum previou number constraint n codelength 1 n 100 1 codei 100 n 1 k n 1 defusethebomb
given root binari tree return preorder travers node valu exampl 1 input root 1null23 output 123 exampl 2 input root output exampl 3 input root 1 output 1 constraint number node tree rang 0 100 100 nodev 100 follow recurs solut trivial could iter binarytreepreordertravers
design stack support increment oper element implement customstack class customstackint maxsiz initi object maxsiz maximum number element stack void pushint x add x top stack stack reach maxsiz int pop pop return top stack 1 stack empti void incint k int val increment bottom k element stack val less k element stack increment element stack exampl 1 input customstackpushpushpoppushpushpushincrementincrementpoppoppoppop 31223451002100 output nullnullnull2nullnullnullnullnull1032022011 explan customstack stk new customstack3 stack empti stkpush1 stack becom 1 stkpush2 stack becom 1 2 stkpop return 2 return top stack 2 stack becom 1 stkpush2 stack becom 1 2 stkpush3 stack becom 1 2 3 stkpush4 stack still 1 2 3 add anoth element size 4 stkincrement5 100 stack becom 101 102 103 stkincrement2 100 stack becom 201 202 103 stkpop return 103 return top stack 103 stack becom 201 202 stkpop return 202 return top stack 202 stack becom 201 stkpop return 201 return top stack 201 stack becom stkpop return 1 stack empti return 1 constraint 1 maxsiz x k 1000 0 val 100 1000 call made method increment push pop separ designastackwithincrementoper
given 0index integ array num even length long num empti must repetit find minimum number num remov find maximum number num remov calcul averag two remov number averag two number b b 2 exampl averag 2 3 2 3 2 25 return number distinct averag calcul use process note tie minimum maximum number remov exampl 1 input num 414035 output 2 explan 1 remov 0 5 averag 0 5 2 25 num 4143 2 remov 1 4 averag 1 4 2 25 num 43 3 remov 3 4 averag 3 4 2 35 sinc 2 distinct number among 25 25 35 return 2 exampl 2 input num 1100 output 1 explan one averag calcul remov 1 100 return 1 constraint 2 numslength 100 numslength even 0 numsi 100 numberofdistinctaverag
given 0index integ array num whose length power 2 appli follow algorithm num let n length num n 1 end process otherwis creat new 0index integ array newnum length n 2 everi even index 0 n 2 assign valu newnumsi minnums2 nums2 1 everi odd index 0 n 2 assign valu newnumsi maxnums2 nums2 1 replac array num newnum repeat entir process start step 1 return last number remain num appli algorithm exampl 1 input num 13524822 output 1 explan follow array result appli algorithm repeatedli first num 1542 second num 14 third num 1 1 last remain number return 1 exampl 2 input num 3 output 3 explan 3 alreadi last remain number return 3 constraint 1 numslength 1024 1 numsi 109 numslength power 2 minmaxgam
given integ array digit element digit array may contain duplic need find uniqu integ follow given requir integ consist concaten three element digit arbitrari order integ lead zero integ even exampl given digit 1 2 3 integ 132 312 follow requir return sort array uniqu integ exampl 1 input digit 2130 output 102120130132210230302310312320 explan possibl integ follow requir output array notic odd integ integ lead zero exampl 2 input digit 22882 output 222228282288822828882 explan digit use mani time appear digit exampl digit 8 use twice time 288 828 882 exampl 3 input digit 375 output explan even integ form use given digit constraint 3 digitslength 100 0 digitsi 9 finding3digitevennumb
given root binari tree integ targetsum return roottoleaf path sum node valu path equal targetsum path return list node valu node refer roottoleaf path path start root end leaf node leaf node children exampl 1 input root 54811null13472nullnull51 targetsum 22 output 541125845 explan two path whose sum equal targetsum 5 4 11 2 22 5 8 4 5 22 exampl 2 input root 123 targetsum 5 output exampl 3 input root 12 targetsum 0 output constraint number node tree rang 0 5000 1000 nodev 1000 1000 targetsum 1000 pathsumii
alic throw n dart larg wall given array dart dartsi xi yi posit ith dart alic threw wall bob know posit n dart wall want place dartboard radiu r wall maximum number dart alic throw lie dartboard given integ r return maximum number dart lie dartboard exampl 1 input dart 20200202 r 2 output 4 explan circl dartboard center 00 radiu 2 contain point exampl 2 input dart 303026540978 r 5 output 5 explan circl dartboard center 04 radiu 5 contain point except point 78 constraint 1 dartslength 100 dartsilength 2 104 xi yi 104 dart uniqu 1 r 5000 maximumnumberofdartsinsideofacirculardartboard
bit flip number x choos bit binari represent x flip either 0 1 1 0 exampl x 7 binari represent 111 may choos bit includ lead zero shown flip flip first bit right get 110 flip second bit right get 101 flip fifth bit right lead zero get 10111 etc given two integ start goal return minimum number bit flip convert start goal exampl 1 input start 10 goal 7 output 3 explan binari represent 10 7 1010 0111 respect convert 10 7 3 step flip first bit right 1010 1011 flip third bit right 1011 1111 flip fourth bit right 1111 0111 shown convert 10 7 less 3 step henc return 3 exampl 2 input start 3 goal 4 output 3 explan binari represent 3 4 011 100 respect convert 3 4 3 step flip first bit right 011 010 flip second bit right 010 000 flip third bit right 000 100 shown convert 3 4 less 3 step henc return 3 constraint 0 start goal 109 minimumbitflipstoconvertnumb
write code enhanc array call arraylast method array return last element element array return 1 may assum array output jsonpars exampl 1 input num null 3 output 3 explan call numslast return last element 3 exampl 2 input num output 1 explan element return 1 constraint 0 arrlength 1000 arrayprototypelast
kmirror number posit integ without lead zero read forward backward base10 well basek exampl 9 2mirror number represent 9 base10 base2 9 1001 respect read forward backward contrari 4 2mirror number represent 4 base2 100 read forward backward given base k number n return sum n smallest kmirror number exampl 1 input k 2 n 5 output 25 explan 5 smallest 2mirror number represent base2 list follow base10 base2 1 1 3 11 5 101 7 111 9 1001 sum 1 3 5 7 9 25 exampl 2 input k 3 n 7 output 499 explan 7 smallest 3mirror number represent base3 list follow base10 base3 1 1 2 2 4 11 8 22 121 11111 151 12121 212 21212 sum 1 2 4 8 121 151 212 499 exampl 3 input k 7 n 17 output 20379000 explan 17 smallest 7mirror number 1 2 3 4 5 6 8 121 171 242 292 16561 65656 2137312 4602064 6597956 6958596 constraint 2 k 9 1 n 30 sumofkmirrornumb
two player play turn base game binari tree given root binari tree number node n tree n odd node distinct valu 1 n initi first player name valu x 1 x n second player name valu 1 n x first player color node valu x red second player color node valu blue player take turn start first player turn player choos node color red player 1 blue player 2 color uncolor neighbor chosen node either left child right child parent chosen node player choos node way must pass turn player pass turn game end winner player color node second player possibl choos ensur win game return true possibl return fals exampl 1 input root 1234567891011 n 11 x 3 output true explan second player choos node valu 2 exampl 2 input root 123 n 3 x 1 output fals constraint number node tree n 1 x n 100 n odd 1 nodev n valu tree uniqu binarytreecoloringgam
given two integ n k return possibl combin k number chosen rang 1 n may return answer order exampl 1 input n 4 k 2 output 121314232434 explan 4 choos 2 6 total combin note combin unord ie 12 21 consid combin exampl 2 input n 1 k 1 output 1 explan 1 choos 1 1 total combin constraint 1 n 20 1 k n combin
n comput given integ n 0index integ array batteri ith batteri run comput batteriesi minut interest run n comput simultan use given batteri initi insert one batteri comput integ time moment remov batteri comput insert anoth batteri number time insert batteri total new batteri batteri anoth comput may assum remov insert process take time note batteri recharg return maximum number minut run n comput simultan exampl 1 input n 2 batteri 333 output 4 explan initi insert batteri 0 first comput batteri 1 second comput two minut remov batteri 1 second comput insert batteri 2 instead note batteri 1 still run one minut end third minut batteri 0 drain need remov first comput insert batteri 1 instead end fourth minut batteri 1 also drain first comput longer run run two comput simultan 4 minut return 4 exampl 2 input n 2 batteri 1111 output 2 explan initi insert batteri 0 first comput batteri 2 second comput one minut batteri 0 batteri 2 drain need remov insert batteri 1 first comput batteri 3 second comput anoth minut batteri 1 batteri 3 also drain first second comput longer run run two comput simultan 2 minut return 2 constraint 1 n batterieslength 105 1 batteriesi 109 maximumrunningtimeofncomput
given x n matrix matrix integ k return max sum rectangl matrix sum larger k guarante rectangl sum larger k exampl 1 input matrix 101023 k 2 output 2 explan sum blue rectangl 0 1 2 3 2 2 max number larger k k 2 exampl 2 input matrix 221 k 3 output 3 constraint matrixlength n matrixilength 1 n 100 100 matrixij 100 105 k 105 follow number row much larger number column maxsumofrectanglenolargerthank
list arr integ rang 1 n sort strictli increas order appli follow algorithm arr start left right remov first number everi number afterward reach end list repeat previou step time right left remov rightmost number everi number remain number keep repeat step altern left right right left singl number remain given integ n return last number remain arr exampl 1 input n 9 output 6 explan arr 1 2 3 4 5 6 7 8 9 arr 2 4 6 8 arr 2 6 arr 6 exampl 2 input n 1 output 1 constraint 1 n 109 eliminationgam
given n x n integ matrix board cell label 1 n2 boustrophedon style start bottom left board ie boardn 10 altern direct row start squar 1 board move start squar curr follow choos destin squar next label rang curr 1 mincurr 6 n2 choic simul result standard 6side die roll ie alway 6 destin regardless size board next snake ladder must move destin snake ladder otherwis move next game end reach squar n2 board squar row r column c snake ladder boardrc 1 destin snake ladder boardrc squar 1 n2 snake ladder note take snake ladder per move destin snake ladder start anoth snake ladder follow subsequ snake ladder exampl suppos board 1413 first move destin squar 2 follow ladder squar 3 follow subsequ ladder 4 return least number move requir reach squar n2 possibl reach squar return 1 exampl 1 input board 111111111111111111135111311111111151111 output 4 explan begin start squar 1 row 5 column 0 decid move squar 2 must take ladder squar 15 decid move squar 17 must take snake squar 13 decid move squar 14 must take ladder squar 35 decid move squar 36 end game lowest possibl number move reach last squar return 4 exampl 2 input board 1113 output 1 constraint n boardlength boardilength 2 n 20 boardij either 1 rang 1 n2 squar label 1 n2 ladder snake snakesandladd
given posit integ n find sum integ rang 1 n inclus divis 3 5 7 return integ denot sum number given rang satisfi constraint exampl 1 input n 7 output 21 explan number rang 1 7 divis 3 5 7 3 5 6 7 sum number 21 exampl 2 input n 10 output 40 explan number rang 1 10 divis 3 5 7 3 5 6 7 9 10 sum number 40 exampl 3 input n 9 output 30 explan number rang 1 9 divis 3 5 7 3 5 6 7 9 sum number 30 constraint 1 n 103 summultipl
design data structur follow constraint least recent use lru cach implement lrucach class lrucacheint capac initi lru cach posit size capac int getint key return valu key key exist otherwis return 1 void putint key int valu updat valu key key exist otherwis add keyvalu pair cach number key exce capac oper evict least recent use key function get put must run o1 averag time complex exampl 1 input lrucach put put get put get put get get get 2 1 1 2 2 1 3 3 2 4 4 1 3 4 output null null null 1 null 1 null 1 3 4 explan lrucach lrucach new lrucache2 lrucacheput1 1 cach 11 lrucacheput2 2 cach 11 22 lrucacheget1 return 1 lrucacheput3 3 lru key 2 evict key 2 cach 11 33 lrucacheget2 return 1 found lrucacheput4 4 lru key 1 evict key 1 cach 44 33 lrucacheget1 return 1 found lrucacheget3 return 3 lrucacheget4 return 4 constraint 1 capac 3000 0 key 104 0 valu 105 2 105 call made get put lrucach
given 2d integ array interv intervalsi starti endi repres integ starti endi inclus contain set array num interv interv least two integ num exampl interv 13 37 89 124789 23489 contain set return minimum possibl size contain set exampl 1 input interv 133789 output 5 explan let num 2 3 4 8 9 shown contain array size 4 exampl 2 input interv 13142535 output 3 explan let num 2 3 4 shown contain array size 2 exampl 3 input interv 12232445 output 5 explan let num 1 2 3 4 5 shown contain array size 4 constraint 1 intervalslength 3000 intervalsilength 2 0 starti endi 108 setintersectionsizeatleasttwo
sql schema pandan schema tabl activ column name type selldat date product varchar tabl may contain duplic word primari key tabl sql row tabl contain product name date sold market find date number differ product sold name sold product name date sort lexicograph return result tabl order selldat result format follow exampl exampl 1 input activ tabl selldat product 20200530 headphon 20200601 pencil 20200602 mask 20200530 basketbal 20200601 bibl 20200602 mask 20200530 tshirt output selldat numsold product 20200530 3 basketballheadphonetshirt 20200601 2 biblepencil 20200602 1 mask explan 20200530 sold item headphon basketbal tshirt sort lexicograph separ comma 20200601 sold item pencil bibl sort lexicograph separ comma 20200602 sold item mask return groupsoldproductsbythed
given integ array num initi posit array first index element array repres maximum jump length posit return true reach last index fals otherwis exampl 1 input num 23114 output true explan jump 1 step index 0 1 3 step last index exampl 2 input num 32104 output fals explan alway arriv index 3 matter maximum jump length 0 make imposs reach last index constraint 1 numslength 104 0 numsi 105 jumpgam
direct graph n color node edg node number 0 n 1 given string color colorsi lowercas english letter repres color ith node graph 0index also given 2d array edg edgesj aj bj indic direct edg node aj node bj valid path graph sequenc node x1 x2 x3 xk direct edg xi xi1 everi 1 k color valu path number node color frequent occur color along path return largest color valu valid path given graph 1 graph contain cycl exampl 1 input color abaca edg 01022334 output 3 explan path 0 2 3 4 contain 3 node color red imag exampl 2 input color edg 00 output 1 explan cycl 0 0 constraint n colorslength edgeslength 1 n 105 0 105 color consist lowercas english letter 0 aj bj n largestcolorvalueinadirectedgraph
given 2d array integ envelop envelopesi wi hi repres width height envelop one envelop fit anoth width height one envelop greater envelop width height return maximum number envelop russian doll ie put one insid note rotat envelop exampl 1 input envelop 54646723 output 3 explan maximum number envelop russian doll 3 23 54 67 exampl 2 input envelop 111111 output 1 constraint 1 envelopeslength 105 envelopesilength 2 1 wi hi 105 russiandollenvelop
sql schema pandan schema tabl employe column name type id int name varchar salari int departmentid int sql id primari key column tabl departmentid foreign key join key panda id depart tabl row tabl indic id name salari employe also contain id depart tabl depart column name type id int name varchar sql id primari key column tabl guarante depart name null row tabl indic id depart name find employe highest salari depart return result tabl order result format follow exampl exampl 1 input employe tabl id name salari departmentid 1 joe 70000 1 2 jim 90000 1 3 henri 80000 2 4 sam 60000 2 5 max 90000 1 depart tabl id name 1 2 sale output depart employe salari jim 90000 sale henri 80000 max 90000 explan max jim highest salari depart henri highest salari sale depart departmenthighestsalari
given 0index integ array num length n integ k return number pair j 0 j n 1 numsi numsj divis k exampl 1 input num 12345 k 2 output 7 explan 7 pair indic whose correspond product divis 2 0 1 0 3 1 2 1 3 1 4 2 3 3 4 product 2 4 6 8 10 12 20 respect pair 0 2 2 4 product 3 15 respect divis 2 exampl 2 input num 1234 k 5 output 0 explan exist pair indic whose correspond product divis 5 constraint 1 numslength 105 1 numsi k 105 countarraypairsdivisiblebyk
wonder string string one letter appear odd number time exampl ccjjc abab wonder ab given string word consist first ten lowercas english letter j return number wonder nonempti substr word substr appear multipl time word count occurr separ substr contigu sequenc charact string exampl 1 input word aba output 4 explan four wonder substr underlin aba aba b aba aba aba exampl 2 input word aabb output 9 explan nine wonder substr underlin aabb aabb aa aabb aab aabb aabb aabb aabb abb aabb b aabb bb aabb b exampl 3 input word output 2 explan two wonder substr underlin h e constraint 1 wordlength 105 word consist lowercas english letter j numberofwonderfulsubstr
car capac empti seat vehicl drive east ie turn around drive west given integ capac array trip tripsi numpassengersi fromi toi indic ith trip numpassengersi passeng locat pick drop fromi toi respect locat given number kilomet due east car initi locat return true possibl pick drop passeng given trip fals otherwis exampl 1 input trip 215337 capac 4 output fals exampl 2 input trip 215337 capac 5 output true constraint 1 tripslength 1000 tripsilength 3 1 numpassengersi 100 0 fromi toi 1000 1 capac 105 carpool
given string length n contain four kind charact q w e r string said balanc charact appear n 4 time n length string return minimum length substr replac string length make balanc alreadi balanc return 0 exampl 1 input qwer output 0 explan alreadi balanc exampl 2 input qqwe output 1 explan need replac q r rqwe qrwe balanc exampl 3 input qqqw output 2 explan replac first qq er constraint n slength 4 n 105 n multipl 4 contain q w e r replacethesubstringforbalancedstr
fanci string string three consecut charact equal given string delet minimum possibl number charact make fanci return final string delet shown answer alway uniqu exampl 1 input leeetcod output leetcod explan remov e first group es creat leetcod three consecut charact equal return leetcod exampl 2 input aaabaaaa output aabaa explan remov first group creat aabaaaa remov two second group creat aabaa three consecut charact equal return aabaa exampl 3 input aab output aab explan three consecut charact equal return aab constraint 1 slength 105 consist lowercas english letter deletecharacterstomakefancystr
given posit integ array skill even length n skilli denot skill ith player divid player n 2 team size 2 total skill team equal chemistri team equal product skill player team return sum chemistri team return 1 way divid player team total skill team equal exampl 1 input skill 325134 output 22 explan divid player follow team 1 5 2 4 3 3 team total skill 6 sum chemistri team 1 5 2 4 3 3 5 8 9 22 exampl 2 input skill 34 output 12 explan two player form team total skill 7 chemistri team 3 4 12 exampl 3 input skill 1123 output 1 explan way divid player team total skill team equal constraint 2 skilllength 105 skilllength even 1 skilli 1000 divideplayersintoteamsofequalskil
given array price pricesi price given stock ith day integ fee repres transact fee find maximum profit achiev may complet mani transact like need pay transact fee transact note may engag multipl transact simultan ie must sell stock buy transact fee charg stock purchas sale exampl 1 input price 132849 fee 2 output 8 explan maximum profit achiev buy prices0 1 sell prices3 8 buy prices4 4 sell prices5 9 total profit 8 1 2 9 4 2 8 exampl 2 input price 1375103 fee 3 output 6 constraint 1 priceslength 5 104 1 pricesi 5 104 0 fee 5 104 besttimetobuyandsellstockwithtransactionfe
given integ array num uniqu element array element appear exactli array return sum uniqu element num exampl 1 input num 1232 output 4 explan uniqu element 13 sum 4 exampl 2 input num 11111 output 0 explan uniqu element sum 0 exampl 3 input num 12345 output 15 explan uniqu element 12345 sum 15 constraint 1 numslength 100 1 numsi 100 sumofuniqueel
given string contain charact determin input string valid input string valid open bracket must close type bracket open bracket must close correct order everi close bracket correspond open bracket type exampl 1 input output true exampl 2 input output true exampl 3 input output fals constraint 1 slength 104 consist parenthes validparenthes
robot start posit 0 0 origin 2d plane given sequenc move judg robot end 0 0 complet move given string move repres move sequenc robot movesi repres ith move valid move r right l left u return true robot return origin finish move fals otherwis note way robot face irrelev r alway make robot move right l alway make move left etc also assum magnitud robot movement move exampl 1 input move ud output true explan robot move move magnitud end origin start therefor return true exampl 2 input move output fals explan robot move left twice end two move left origin return fals origin end move constraint 1 moveslength 2 104 move contain charact u l r robotreturntoorigin
given 0index string lowercas english letter even indic digit odd indic function shiftc x c charact x digit return xth charact c exampl shifta 5 f shiftx 0 x everi odd index want replac digit si shiftsi1 si return replac digit guarante shiftsi1 si never exceed z exampl 1 input a1c1e1 output abcdef explan digit replac follow s1 shifta1 b s3 shiftc1 s5 shifte1 f exampl 2 input a1b2c3d4 output abbdcfdh explan digit replac follow s1 shifta1 b s3 shiftb2 s5 shiftc3 f s7 shiftd4 h constraint 1 slength 100 consist lowercas english letter digit shiftsi1 si z odd indic replacealldigitswithcharact
given integ array num element sort ascend order convert heightbalanc binari search tree exampl 1 input num 103059 output 03910null5 explan 0105null3null9 also accept exampl 2 input num 13 output 31 explan 1null3 31 heightbalanc bst constraint 1 numslength 104 104 numsi 104 num sort strictli increas order convertsortedarraytobinarysearchtre
sequenc x1 x2 xn fibonaccilik n 3 xi xi1 xi2 2 n given strictli increas array arr posit integ form sequenc return length longest fibonaccilik subsequ arr one exist return 0 subsequ deriv anoth sequenc arr delet number element includ none arr without chang order remain element exampl 3 5 8 subsequ 3 4 5 6 7 8 exampl 1 input arr 12345678 output 5 explan longest subsequ fibonaccilik 12358 exampl 2 input arr 13711121418 output 3 explan longest subsequ fibonaccilik 11112 31114 71118 constraint 3 arrlength 1000 1 arri arri 1 109 lengthoflongestfibonaccisubsequ
sql schema tabl activ column name type userid int sessionid int activityd date activitytyp enum primari key tabl may duplic row activitytyp column enum type opensess endsess scrolldown sendmessag tabl show user activ social media websit note session belong exactli one user write sql queri find daili activ user count period 30 day end 20190727 inclus user activ someday made least one activ day return result tabl order queri result format follow exampl exampl 1 input activ tabl userid sessionid activityd activitytyp 1 1 20190720 opensess 1 1 20190720 scrolldown 1 1 20190720 endsess 2 4 20190720 opensess 2 4 20190721 sendmessag 2 4 20190721 endsess 3 2 20190721 opensess 3 2 20190721 sendmessag 3 2 20190721 endsess 4 3 20190625 opensess 4 3 20190625 endsess output day activeus 20190720 2 20190721 2 explan note care day zero activ user useractivityforthepast30daysi
given fixedlength integ array arr duplic occurr zero shift remain element right note element beyond length origin array written modif input array place return anyth exampl 1 input arr 10230450 output 10023004 explan call function input array modifi 10023004 exampl 2 input arr 123 output 123 explan call function input array modifi 123 constraint 1 arrlength 104 0 arri 9 duplicatezero
given 2d integ grid size x n integ x one oper add x subtract x element grid univalu grid grid element equal return minimum number oper make grid univalu possibl return 1 exampl 1 input grid 2468 x 2 output 4 explan make everi element equal 4 follow add x 2 subtract x 6 subtract x 8 twice total 4 oper use exampl 2 input grid 1523 x 1 output 5 explan make everi element equal 3 exampl 3 input grid 1234 x 2 output 1 explan imposs make everi element equal constraint gridlength n gridilength 1 n 105 1 n 105 1 x gridij 104 minimumoperationstomakeaunivaluegrid
given singli link list return random node valu link list node must probabl chosen implement solut class solutionlistnod head initi object head singlylink list head int getrandom choos node randomli list return valu node list equal like chosen exampl 1 input solut getrandom getrandom getrandom getrandom getrandom 1 2 3 output null 1 3 2 2 3 explan solut solut new solution1 2 3 solutiongetrandom return 1 solutiongetrandom return 3 solutiongetrandom return 2 solutiongetrandom return 2 solutiongetrandom return 3 getrandom return either 1 2 3 randomli element equal probabl return constraint number node link list rang 1 104 104 nodev 104 104 call made getrandom follow link list extrem larg length unknown could solv effici without use extra space linkedlistrandomnod
squar matrix said xmatrix follow condit hold element diagon matrix nonzero element 0 given 2d integ array grid size n x n repres squar matrix return true grid xmatrix otherwis return fals exampl 1 input grid 2001031005204002 output true explan refer diagram xmatrix green element diagon nonzero red element 0 thu grid xmatrix exampl 2 input grid 570031050 output fals explan refer diagram xmatrix green element diagon nonzero red element 0 thu grid xmatrix constraint n gridlength gridilength 3 n 100 0 gridij 105 checkifmatrixisxmatrix
given 0index array num compris n nonneg integ one oper must choos integ 1 n numsi 0 decreas numsi 1 increas numsi 1 1 return minimum possibl valu maximum integ num perform number oper exampl 1 input num 3716 output 5 explan one set optim oper follow 1 choos 1 num becom 4616 2 choos 3 num becom 4625 3 choos 1 num becom 5525 maximum integ num 5 shown maximum number less 5 therefor return 5 exampl 2 input num 101 output 10 explan optim leav num sinc 10 maximum valu return 10 constraint n numslength 2 n 105 0 numsi 109 minimizemaximumofarray
given 0index array num n integ integ k kradiu averag subarray num center index radiu k averag element num indic k k inclus less k element index kradiu averag 1 build return array avg length n avgsi kradiu averag subarray center index averag x element sum x element divid x use integ divis integ divis truncat toward zero mean lose fraction part exampl averag four element 2 3 1 5 2 3 1 5 4 11 4 275 truncat 2 exampl 1 input num 743918526 k 3 output 111544111 explan avg0 avg1 avg2 1 less k element index sum subarray center index 3 radiu 3 7 4 3 9 1 8 5 37 use integ divis avg3 37 7 5 subarray center index 4 avg4 4 3 9 1 8 5 2 7 4 subarray center index 5 avg5 3 9 1 8 5 2 6 7 4 avg6 avg7 avg8 1 less k element index exampl 2 input num 100000 k 0 output 100000 explan sum subarray center index 0 radiu 0 100000 avg0 100000 1 100000 exampl 3 input num 8 k 100000 output 1 explan avg0 1 less k element index 0 constraint n numslength 1 n 105 0 numsi k 105 kradiussubarrayaverag
keyboard layout shown xy plane english uppercas letter locat coordin exampl letter locat coordin 0 0 letter b locat coordin 0 1 letter p locat coordin 2 3 letter z locat coordin 4 1 given string word return minimum total distanc type string use two finger distanc coordin x1 y1 x2 y2 x1 x2 y1 y2 note initi posit two finger consid free count toward total distanc also two finger start first letter first two letter exampl 1 input word cake output 3 explan use two finger one optim way type cake finger 1 letter c cost 0 finger 1 letter cost distanc letter c letter 2 finger 2 letter k cost 0 finger 2 letter e cost distanc letter k letter e 1 total distanc 3 exampl 2 input word happi output 6 explan use two finger one optim way type happi finger 1 letter h cost 0 finger 1 letter cost distanc letter h letter 2 finger 2 letter p cost 0 finger 2 letter p cost distanc letter p letter p 0 finger 1 letter cost distanc letter letter 4 total distanc 6 constraint 2 wordlength 300 word consist uppercas english letter minimumdistancetotypeawordusingtwofing
leetcod store n item sell item price howev special offer special offer consist one differ kind item sale price given integ array price pricei price ith item integ array need needsi number piec ith item want buy also given array special speciali size n 1 specialij number piec jth item ith offer specialin ie last integ array price ith offer return lowest price pay exactli certain item given could make optim use special offer allow buy item want even would lower overal price could use special offer mani time want exampl 1 input price 25 special 3051210 need 32 output 14 explan two kind item b price 2 5 respect special offer 1 pay 5 3a 0b special offer 2 pay 10 1a 2b need buy 3a 2b may pay 10 1a 2b special offer 2 4 2a exampl 2 input price 234 special 11042219 need 121 output 11 explan price 2 3 b 4 c may pay 4 1a 1b 9 2a 2b 1c need buy 1a 2b 1c may pay 4 1a 1b special offer 1 3 1b 4 1c add item though 9 2a 2b 1c constraint n pricelength needslength 1 n 6 0 pricei needsi 10 1 speciallength 100 specialilength n 1 0 specialij 50 shoppingoff
link list length n given node contain addit random pointer could point node list null construct deep copi list deep copi consist exactli n brand new node new node valu set valu correspond origin node next random pointer new node point new node copi list pointer origin list copi list repres list state none pointer new list point node origin list exampl two node x origin list xrandom correspond two node x copi list xrandom return head copi link list link list repres inputoutput list n node node repres pair val randomindex val integ repres nodev randomindex index node rang 0 n1 random pointer point null point node code given head origin link list exampl 1 input head 7null13011410210 output 7null13011410210 exampl 2 input head 1121 output 1121 exampl 3 input head 3null303nul output 3null303nul constraint 0 n 1000 104 nodev 104 noderandom null point node link list copylistwithrandompoint
given array peopl peoplei weight ith person infinit number boat boat carri maximum weight limit boat carri two peopl time provid sum weight peopl limit return minimum number boat carri everi given person exampl 1 input peopl 12 limit 3 output 1 explan 1 boat 1 2 exampl 2 input peopl 3221 limit 3 output 3 explan 3 boat 1 2 2 3 exampl 3 input peopl 3534 limit 5 output 4 explan 4 boat 3 3 4 5 constraint 1 peoplelength 5 104 1 peoplei limit 3 104 boatstosavepeopl
given array num posit integ one oper choos number num reduc exactli half number note may choos reduc number futur oper return minimum number oper reduc sum num least half exampl 1 input num 51981 output 3 explan initi sum num equal 5 19 8 1 33 follow one way reduc sum least half pick number 19 reduc 95 pick number 95 reduc 475 pick number 8 reduc 4 final array 5 475 4 1 total sum 5 475 4 1 1475 sum num reduc 33 1475 1825 least half initi sum 1825 332 165 overal 3 oper use return 3 shown reduc sum least half less 3 oper exampl 2 input num 3820 output 3 explan initi sum num equal 3 8 20 31 follow one way reduc sum least half pick number 20 reduc 10 pick number 10 reduc 5 pick number 3 reduc 15 final array 15 8 5 total sum 15 8 5 145 sum num reduc 31 145 165 least half initi sum 165 312 155 overal 3 oper use return 3 shown reduc sum least half less 3 oper constraint 1 numslength 105 1 numsi 107 minimumoperationstohalvearraysum
given binari string 2d integ array queri queriesi firsti secondi ith queri find shortest substr whose decim valu val yield secondi bitwis xore firsti word val firsti secondi answer ith queri endpoint 0index substr lefti righti 1 1 substr exist multipl answer choos one minimum lefti return array an ansi lefti righti answer ith queri substr contigu nonempti sequenc charact within string exampl 1 input 101101 queri 0512 output 0223 explan first queri substr rang 02 101 decim valu 5 5 0 5 henc answer first queri 02 second queri substr rang 23 11 decim valu 3 3 1 2 23 return second queri exampl 2 input 0101 queri 128 output 11 explan exampl substr answer queri henc 11 return exampl 3 input 1 queri 45 output 00 explan exampl substr rang 00 decim valu 1 1 4 5 answer 00 constraint 1 slength 104 si either 0 1 1 querieslength 105 0 firsti secondi 109 substringxorqueri
given 2d integ array tile tilesi li ri repres everi tile j rang li j ri color white also given integ carpetlen length singl carpet place anywher return maximum number white tile cover carpet exampl 1 input tile 151011121820253032 carpetlen 10 output 9 explan place carpet start tile 10 cover 9 white tile return 9 note may place carpet cover 9 white tile shown carpet cover 9 white tile exampl 2 input tile 101111 carpetlen 2 output 2 explan place carpet start tile 10 cover 2 white tile return 2 constraint 1 tileslength 5 104 tilesilength 2 1 li ri 109 1 carpetlen 109 tile nonoverlap maximumwhitetilescoveredbyacarpet
sql schema tabl user column name type userid int usernam varchar userid primari key tabl row tabl contain name id user tabl regist column name type contestid int userid int contestid userid primari key tabl row tabl contain id user contest regist write sql queri find percentag user regist contest round two decim return result tabl order percentag descend order case tie order contestid ascend order queri result format follow exampl exampl 1 input user tabl userid usernam 6 alic 2 bob 7 alex regist tabl contestid userid 215 6 209 2 208 2 210 6 208 6 209 7 209 6 215 7 208 7 210 2 207 2 210 7 output contestid percentag 208 1000 209 1000 210 1000 215 6667 207 3333 explan user regist contest 208 209 210 percentag 100 sort answer tabl contestid ascend order alic alex regist contest 215 percentag 23 100 6667 bob regist contest 207 percentag 13 100 3333 percentageofusersattendedacontest
parti n friend number 0 n 1 attend infinit number chair parti number 0 infin friend arriv parti sit unoccupi chair smallest number exampl chair 0 1 5 occupi friend come sit chair number 2 friend leav parti chair becom unoccupi moment leav anoth friend arriv moment sit chair given 0index 2d integ array time timesi arrivali leavingi indic arriv leav time ith friend respect integ targetfriend arriv time distinct return chair number friend number targetfriend sit exampl 1 input time 142346 targetfriend 1 output 1 explan friend 0 arriv time 1 sit chair 0 friend 1 arriv time 2 sit chair 1 friend 1 leav time 3 chair 1 becom empti friend 0 leav time 4 chair 0 becom empti friend 2 arriv time 4 sit chair 0 sinc friend 1 sat chair 1 return 1 exampl 2 input time 3101526 targetfriend 0 output 2 explan friend 1 arriv time 1 sit chair 0 friend 2 arriv time 2 sit chair 1 friend 0 arriv time 3 sit chair 2 friend 1 leav time 5 chair 0 becom empti friend 2 leav time 6 chair 1 becom empti friend 0 leav time 10 chair 2 becom empti sinc friend 0 sat chair 2 return 2 constraint n timeslength 2 n 104 timesilength 2 1 arrivali leavingi 105 0 targetfriend n 1 arrivali time distinct thenumberofthesmallestunoccupiedchair
n car infinit long road car number 0 n 1 left right car present uniqu point given 0index string direct length n directionsi either l r denot whether ith car move toward left toward right stay current point respect move car speed number collis calcul follow two car move opposit direct collid number collis increas 2 move car collid stationari car number collis increas 1 collis car involv longer move stay point collid car chang state direct motion return total number collis happen road exampl 1 input direct rlrsll output 5 explan collis happen road car 0 1 collid sinc move opposit direct number collis becom 0 2 2 car 2 3 collid sinc car 3 stationari number collis becom 2 1 3 car 3 4 collid sinc car 3 stationari number collis becom 3 1 4 car 4 5 collid car 4 collid car 3 stay point collis get hit car 5 number collis becom 4 1 5 thu total number collis happen road 5 exampl 2 input direct llrr output 0 explan car collid thu total number collis happen road 0 constraint 1 directionslength 105 directionsi either l r countcollisionsonaroad
given two string p p subsequ also given distinct 0index integ array remov contain subset indic also 0index want choos integ k 0 k removablelength remov k charact use first k indic remov p still subsequ formal mark charact sremovablei 0 k remov mark charact check p still subsequ return maximum k choos p still subsequ remov subsequ string new string gener origin string charact none delet without chang rel order remain charact exampl 1 input abcacb p ab remov 310 output 2 explan remov charact indic 3 1 abcacb becom accb ab subsequ accb remov charact indic 3 1 0 abcacb becom ccb ab longer subsequ henc maximum k 2 exampl 2 input abcbddddd p abcd remov 321456 output 1 explan remov charact index 3 abcbddddd becom abcddddd abcd subsequ abcddddd exampl 3 input abcab p abc remov 01234 output 0 explan remov first index array remov abc longer subsequ constraint 1 plength slength 105 0 removablelength slength 0 removablei slength p subsequ p consist lowercas english letter element remov distinct maximumnumberofremovablecharact
given list 24hour clock time point hhmm format return minimum minut differ two timepoint list exampl 1 input timepoint 23590000 output 1 exampl 2 input timepoint 000023590000 output 0 constraint 2 timepointslength 2 104 timepointsi format hhmm minimumtimediffer
tree ie connect undirect graph cycl consist n node number 0 n 1 exactli n 1 edg given 0index integ array val length n valsi denot valu ith node also given 2d integ array edg edgesi ai bi denot exist undirect edg connect node ai bi good path simpl path satisfi follow condit start node end node valu node start node end node valu less equal start node ie start node valu maximum valu along path return number distinct good path note path revers count path exampl 0 1 consid 1 0 singl node also consid valid path exampl 1 input val 13213 edg 01022324 output 6 explan 5 good path consist singl node 1 addit good path 1 0 2 4 revers path 4 2 0 1 treat 1 0 2 4 note 0 2 3 good path vals2 vals0 exampl 2 input val 11223 edg 01122324 output 7 explan 5 good path consist singl node 2 addit good path 0 1 2 3 exampl 3 input val 1 edg output 1 explan tree consist one node one good path constraint n valslength 1 n 3 104 0 valsi 105 edgeslength n 1 edgesilength 2 0 ai bi n ai bi edg repres valid tree numberofgoodpath
given 0index integ array num find 0index integ array answer answerlength numslength answeri leftsumi rightsumi leftsumi sum element left index array num element leftsumi 0 rightsumi sum element right index array num element rightsumi 0 return array answer exampl 1 input num 10483 output 1511122 explan array leftsum 0101422 array rightsum 151130 array answer 0 1510 1114 322 0 1511122 exampl 2 input num 1 output 0 explan array leftsum 0 array rightsum 0 array answer 0 0 0 constraint 1 numslength 1000 1 numsi 105 leftandrightsumdiffer
boolean express express evalu either true fals one follow shape evalu true f evalu fals subexpr evalu logic inner express subexpr subexpr1 subexpr2 subexprn evalu logic inner express subexpr1 subexpr2 subexprn n 1 subexpr1 subexpr2 subexprn evalu logic inner express subexpr1 subexpr2 subexprn n 1 given string express repres boolean express return evalu express guarante given express valid follow given rule exampl 1 input express f output fals explan first evalu f f express f evalu f f express f final return fals exampl 2 input express ffft output true explan evalu fals fals fals true true exampl 3 input express ft output true explan first evalu ft fals true fals f express f evalu f fals true return true constraint 1 expressionlength 2 104 expressioni one follow charact f parsingabooleanexpress
bidirect graph n vertic vertex label 0 n 1 inclus edg graph repres 2d integ array edg edgesi ui vi denot bidirect edg vertex ui vertex vi everi vertex pair connect one edg vertex edg want determin valid path exist vertex sourc vertex destin given edg integ n sourc destin return true valid path sourc destin fals otherwis exampl 1 input n 3 edg 011220 sourc 0 destin 2 output true explan two path vertex 0 vertex 2 0 → 1 → 2 0 → 2 exampl 2 input n 6 edg 0102355443 sourc 0 destin 5 output fals explan path vertex 0 vertex 5 constraint 1 n 2 105 0 edgeslength 2 105 edgesilength 2 0 ui vi n 1 ui vi 0 sourc destin n 1 duplic edg self edg findifpathexistsingraph
given integ n number node direct graph node label 0 n 1 edg red blue graph could selfedg parallel edg given two array rededg blueedg rededgesi ai bi indic direct red edg node ai node bi graph blueedgesj uj vj indic direct blue edg node uj node vj graph return array answer length n answerx length shortest path node 0 node x edg color altern along path 1 path exist exampl 1 input n 3 rededg 0112 blueedg output 011 exampl 2 input n 3 rededg 01 blueedg 21 output 011 constraint 1 n 100 0 rededgeslength blueedgeslength 400 rededgesilength blueedgesjlength 2 0 ai bi uj vj n shortestpathwithalternatingcolor
suppos class public class foo public void first printfirst public void second printsecond public void third printthird instanc foo pass three differ thread thread call first thread b call second thread c call third design mechan modifi program ensur second execut first third execut second note know thread schedul oper system even though number input seem impli order input format see mainli ensur test comprehens exampl 1 input num 123 output firstsecondthird explan three thread fire asynchron input 123 mean thread call first thread b call second thread c call third firstsecondthird correct output exampl 2 input num 132 output firstsecondthird explan input 132 mean thread call first thread b call third thread c call second firstsecondthird correct output constraint num permut 1 2 3 printinord
score array defin product sum length exampl score 1 2 3 4 5 1 2 3 4 5 5 75 given posit integ array num integ k return number nonempti subarray num whose score strictli less k subarray contigu sequenc element within array exampl 1 input num 21435 k 10 output 6 explan 6 subarray score less 10 2 score 2 1 2 1 score 1 1 1 4 score 4 1 4 3 score 3 1 3 5 score 5 1 5 21 score 2 1 2 6 note subarray 14 435 consid score 10 36 respect need score strictli less 10 exampl 2 input num 111 k 5 output 5 explan everi subarray except 111 score less 5 111 score 1 1 1 3 9 greater 5 thu 5 subarray score less 5 constraint 1 numslength 105 1 numsi 105 1 k 1015 countsubarrayswithscorelessthank
2 x 3 board five tile label 1 5 empti squar repres 0 move consist choos 0 4direct adjac number swap state board solv board 123450 given puzzl board board return least number move requir state board solv imposs state board solv return 1 exampl 1 input board 123405 output 1 explan swap 0 5 one move exampl 2 input board 123540 output 1 explan number move make board solv exampl 3 input board 412503 output 5 explan 5 smallest number move solv board exampl path move 0 412503 move 1 412053 move 2 012453 move 3 102453 move 4 120453 move 5 123450 constraint boardlength 2 boardilength 3 0 boardij 5 valu boardij uniqu slidingpuzzl
given integ array arr integ k modifi array repeat k time exampl arr 1 2 k 3 modifi array 1 2 1 2 1 2 return maximum subarray sum modifi array note length subarray 0 sum case 0 answer larg return answer modulo 109 7 exampl 1 input arr 12 k 3 output 9 exampl 2 input arr 121 k 5 output 2 exampl 3 input arr 12 k 7 output 0 constraint 1 arrlength 105 1 k 105 104 arri 104 kconcatenationmaximumsum
winston given mysteri function func integ array arr integ target want find valu l r make valu funcarr l r target minimum possibl return minimum possibl valu funcarr l r target notic func call valu l r 0 l r arrlength exampl 1 input arr 9123715 target 5 output 2 explan call func pair lr 001122334401122334021324031404 winston got follow result 91237158037003000 valu closest 5 7 3 thu minimum differ 2 exampl 2 input arr 100000010000001000000 target 1 output 999999 explan winston call func possibl valu lr alway got 1000000 thu min differ 999999 exampl 3 input arr 124816 target 0 output 0 constraint 1 arrlength 105 1 arri 106 0 target 107 findavalueofamysteriousfunctionclosesttotarget
given integ money denot amount money dollar anoth integ children denot number children must distribut money distribut money accord follow rule money must distribut everyon must receiv least 1 dollar nobodi receiv 4 dollar return maximum number children may receiv exactli 8 dollar distribut money accord aforement rule way distribut money return 1 exampl 1 input money 20 children 3 output 1 explan maximum number children 8 dollar 1 one way distribut money 8 dollar first child 9 dollar second child 3 dollar third child proven distribut exist number children get 8 dollar greater 1 exampl 2 input money 16 children 2 output 2 explan child given 8 dollar constraint 1 money 200 2 children 30 distributemoneytomaximumchildren
given posit integ n find smallest integ exactli digit exist integ n greater valu n posit integ exist return 1 note return integ fit 32bit integ valid answer fit 32bit integ return 1 exampl 1 input n 12 output 21 exampl 2 input n 21 output 1 constraint 1 n 231 1 nextgreaterelementiii
antitheft secur devic activ insid bank given 0index binari string array bank repres floor plan bank x n 2d matrix banki repres ith row consist 0s 1s 0 mean cell empti while1 mean cell secur devic one laser beam two secur devic condit met two devic locat two differ row r1 r2 r1 r2 row r1 r2 secur devic ith row laser beam independ ie one beam interfer join anoth return total number laser beam bank exampl 1 input bank 011001000000010100001000 output 8 explan follow devic pair one beam total 8 beam bank01 bank21 bank01 bank23 bank02 bank21 bank02 bank23 bank05 bank21 bank05 bank23 bank21 bank32 bank23 bank32 note beam devic 0th row 3rd row 2nd row contain secur devic break second condit exampl 2 input bank 000111000 output 0 explan exist two devic locat two differ row constraint banklength n bankilength 1 n 500 bankij either 0 1 numberoflaserbeamsinabank
given array num nonneg integ num consid special exist number x exactli x number num greater equal x notic x element num return x array special otherwis return 1 proven num special valu x uniqu exampl 1 input num 35 output 2 explan 2 valu 3 5 greater equal 2 exampl 2 input num 00 output 1 explan number fit criteria x x 0 0 number x 2 x 1 1 number x 0 x 2 2 number x 0 x greater sinc 2 number num exampl 3 input num 04304 output 3 explan 3 valu greater equal 3 constraint 1 numslength 100 0 numsi 1000 specialarraywithxelementsgreaterthanorequalx
given string revers string accord follow rule charact english letter remain posit english letter lowercas uppercas revers return revers exampl 1 input abcd output dcba exampl 2 input abcdefghij output jihgfedcba exampl 3 input test1ngleetcodeq output qedo1cteelgntset constraint 1 slength 100 consist charact ascii valu rang 33 122 contain reverseonlylett
assign put amount box onto one truck given 2d array boxtyp boxtypesi numberofboxesi numberofunitsperboxi numberofboxesi number box type numberofunitsperboxi number unit box type also given integ trucksiz maximum number box put truck choos box put truck long number box exceed trucksiz return maximum total number unit put truck exampl 1 input boxtyp 132231 trucksiz 4 output 8 explan 1 box first type contain 3 unit 2 box second type contain 2 unit 3 box third type contain 1 unit take box first second type one box third type total number unit 1 3 2 2 1 1 8 exampl 2 input boxtyp 510254739 trucksiz 10 output 91 constraint 1 boxtypeslength 1000 1 numberofboxesi numberofunitsperboxi 1000 1 trucksiz 106 maximumunitsonatruck
given integ n return true n exactli three posit divisor otherwis return fals integ divisor n exist integ k n k exampl 1 input n 2 output fals explant 2 two divisor 1 2 exampl 2 input n 4 output true explant 4 three divisor 1 2 4 constraint 1 n 104 threedivisor
given array variabl pair equat array real number valu equationsi ai bi valuesi repres equat ai bi valuesi ai bi string repres singl variabl also given queri queriesj cj dj repres jth queri must find answer cj dj return answer queri singl answer determin return 10 note input alway valid may assum evalu queri result divis zero contradict exampl 1 input equat abbc valu 2030 queri acbaaeaaxx output 600000050000100000100000100000 explan given b 20 b c 30 queri c b e x x return 60 05 10 10 10 exampl 2 input equat abbcbccd valu 152550 queri accbbccdcdbc output 375000040000500000020000 exampl 3 input equat ab valu 05 queri abbaacxi output 050000200000100000100000 constraint 1 equationslength 20 equationsilength 2 1 ailength bilength 5 valueslength equationslength 00 valuesi 200 1 querieslength 20 queriesilength 2 1 cjlength djlength 5 ai bi cj dj consist lower case english letter digit evaluatedivis
given two promis promise1 promise2 return new promis promise1 promise2 resolv number return promis resolv sum two number exampl 1 input promise1 new promiseresolv settimeout resolve2 20 promise2 new promiseresolv settimeout resolve5 60 output 7 explan two input promis resolv valu 2 5 respect return promis resolv valu 2 5 7 time return promis resolv judg problem exampl 2 input promise1 new promiseresolv settimeout resolve10 50 promise2 new promiseresolv settimeout resolve12 30 output 2 explan two input promis resolv valu 10 12 respect return promis resolv valu 10 12 2 constraint promise1 promise2 promis resolv number addtwopromis
given n n matrix grid 0s 1s want repres grid quadtre return root quadtre repres grid quadtre tree data structur intern node exactli four children besid node two attribut val true node repres grid 1s fals node repres grid 0s notic assign val true fals isleaf fals accept answer isleaf true node leaf node tree fals node four children class node public boolean val public boolean isleaf public node topleft public node topright public node bottomleft public node bottomright construct quadtre twodimension area use follow step current grid valu ie 1s 0s set isleaf true set val valu grid set four children null stop current grid differ valu set isleaf fals set val valu divid current grid four subgrid shown photo recurs children proper subgrid want know quadtre refer wiki quadtre format dont need read section solv problem want understand output format output repres serial format quadtre use level order travers null signifi path termin node exist similar serial binari tree differ node repres list isleaf val valu isleaf val true repres 1 list isleaf val valu isleaf val fals repres 0 exampl 1 input grid 0110 output 0110111110 explan explan exampl shown notic 0 represnt fals 1 repres true photo repres quadtre exampl 2 input grid 1111000011110000111111111111111111110000111100001111000011110000 output 0111011110nullnullnullnull10101111 explan valu grid divid grid four subgrid topleft bottomleft bottomright valu topright differ valu divid 4 subgrid valu explan shown photo constraint n gridlength gridilength n 2x 0 x 6 constructquadtre
given two string length one step choos charact replac anoth charact return minimum number step make anagram anagram string string contain charact differ order exampl 1 input bab aba output 1 explan replac first b bba anagram exampl 2 input leetcod practic output 5 explan replac p r c proper charact make anagram exampl 3 input anagram mangaar output 0 explan anagram mangaar anagram constraint 1 slength 5 104 slength tlength consist lowercas english letter minimumnumberofstepstomaketwostringsanagram
given two 0index integ array nums1 nums2 length n choos two integ left right 0 left right n swap subarray nums1leftright subarray nums2leftright exampl nums1 12345 nums2 1112131415 choos left 1 right 2 nums1 becom 1121345 nums2 becom 11231415 may choos appli mention oper anyth score array maximum sumnums1 sumnums2 sumarr sum element array arr return maximum possibl score subarray contigu sequenc element within array arrleftright denot subarray contain element num indic left right inclus exampl 1 input nums1 606060 nums2 109010 output 210 explan choos left 1 right 1 nums1 609060 nums2 106010 score maxsumnums1 sumnums2 max210 80 210 exampl 2 input nums1 2040207030 nums2 5020504020 output 220 explan choos left 3 right 4 nums1 2040204020 nums2 5020507030 score maxsumnums1 sumnums2 max140 220 220 exampl 3 input nums1 71113 nums2 111 output 31 explan choos swap subarray score maxsumnums1 sumnums2 max31 3 31 constraint n nums1length nums2length 1 n 105 1 nums1i nums2i 104 maximumscoreofsplicedarray
1 million 1 million grid xyplan coordin grid squar x start sourc sx sy squar want reach target tx ty squar also array block squar blockedi xi yi repres block squar coordin xi yi move walk one squar north east south west squar array block squar also allow walk outsid grid return true possibl reach target squar sourc squar sequenc valid move exampl 1 input block 0110 sourc 00 target 02 output fals explan target squar inaccess start sourc squar move move north east squar block move south west go outsid grid exampl 2 input block sourc 00 target 999999999999 output true explan block cell possibl reach target squar constraint 0 blockedlength 200 blockedilength 2 0 xi yi 106 sourcelength targetlength 2 0 sx sy tx ty 106 sourc target guarante sourc target block escapealargemaz
given integ array num integ k return maximum sum nonempti subsequ array everi two consecut integ subsequ numsi numsj j condit j k satisfi subsequ array obtain delet number element zero array leav remain element origin order exampl 1 input num 10210520 k 2 output 37 explan subsequ 10 2 5 20 exampl 2 input num 123 k 1 output 1 explan subsequ must nonempti choos largest number exampl 3 input num 10210520 k 2 output 23 explan subsequ 10 2 5 20 constraint 1 k numslength 105 104 numsi 104 constrainedsubsequencesum
given integ array num integ k return number subarray num least common multipl subarray element k subarray contigu nonempti sequenc element within array least common multipl array smallest posit integ divis array element exampl 1 input num 36271 k 6 output 4 explan subarray num 6 least common multipl subarray element 36271 36271 36271 36271 exampl 2 input num 3 k 2 output 0 explan subarray num 2 least common multipl subarray element constraint 1 numslength 1000 1 numsi k 1000 numberofsubarrayswithlcmequaltok
given 0index integ array num length n integ k oper choos element multipli 2 return maximum possibl valu nums0 nums1 numsn 1 obtain appli oper num k time note b denot bitwis two integ b exampl 1 input num 129 k 1 output 30 explan appli oper index 1 new array num equal 1218 thu return bitwis 12 18 30 exampl 2 input num 812 k 2 output 35 explan appli oper twice index 0 yield new array 3212 thu return 3212 35 constraint 1 numslength 105 1 numsi 109 1 k 15 maximumor
n children stand line child assign rate valu given integ array rate give candi children subject follow requir child must least one candi children higher rate get candi neighbor return minimum number candi need distribut candi children exampl 1 input rate 102 output 5 explan alloc first second third child 2 1 2 candi respect exampl 2 input rate 122 output 4 explan alloc first second third child 1 2 1 candi respect third child get 1 candi satisfi two condit constraint n ratingslength 1 n 2 104 0 ratingsi 2 104 candi
3 lane road length n consist n 1 point label 0 n frog start point 0 second lane want jump point n howev could obstacl along way given array obstacl length n 1 obstaclesi rang 0 3 describ obstacl lane obstaclesi point obstaclesi 0 obstacl point one obstacl 3 lane point exampl obstacles2 1 obstacl lane 1 point 2 frog travel point point 1 lane obstacl lane point 1 avoid obstacl frog also perform side jump jump anoth lane even adjac point obstacl new lane exampl frog jump lane 3 point 3 lane 1 point 3 return minimum number side jump frog need reach lane point n start lane 2 point 0 note obstacl point 0 n exampl 1 input obstacl 01230 output 2 explan optim solut shown arrow 2 side jump red arrow note frog jump obstacl make side jump shown point 2 exampl 2 input obstacl 011330 output 0 explan obstacl lane 2 side jump requir exampl 3 input obstacl 021030 output 2 explan optim solut shown arrow 2 side jump constraint obstacleslength n 1 1 n 5 105 0 obstaclesi 3 obstacles0 obstaclesn 0 minimumsidewayjump
given string return number distinct nonempti subsequ sinc answer may larg return modulo 109 7 subsequ string new string form origin string delet none charact without disturb rel posit remain charact ie ace subsequ abcd aec exampl 1 input abc output 7 explan 7 distinct subsequ b c ab ac bc abc exampl 2 input aba output 6 explan 6 distinct subsequ b ab aa ba aba exampl 3 input aaa output 3 explan 3 distinct subsequ aa aaa constraint 1 slength 2000 consist lowercas english letter distinctsubsequencesii
given x n binari matrix mat find 0index posit row contain maximum count one number one row case multipl row maximum count one row smallest row number select return array contain index row number one exampl 1 input mat 0110 output 01 explan row number 1s return index smaller row 0 maximum count one 1 answer 01 exampl 2 input mat 000011 output 12 explan row index 1 maximum count one 2 return index 1 count answer 12 exampl 3 input mat 001100 output 12 explan row index 1 maximum count one 2 answer 12 constraint matlength n matilength 1 n 100 matij either 0 1 rowwithmaximumon
given three integ array nums1 nums2 nums3 return distinct array contain valu present least two three array may return valu order exampl 1 input nums1 1132 nums2 23 nums3 3 output 32 explan valu present least two array 3 three array 2 nums1 nums2 exampl 2 input nums1 31 nums2 23 nums3 12 output 231 explan valu present least two array 2 nums2 nums3 3 nums1 nums2 1 nums1 nums3 exampl 3 input nums1 122 nums2 433 nums3 5 output explan valu present least two array constraint 1 nums1length nums2length nums3length 100 1 nums1i nums2j nums3k 100 twooutofthre
given x n grid fill nonneg number find path top left bottom right minim sum number along path note move either right point time exampl 1 input grid 131151421 output 7 explan path 1 → 3 → 1 → 1 → 1 minim sum exampl 2 input grid 123456 output 12 constraint gridlength n gridilength 1 n 200 0 gridij 200 minimumpathsum
one charact screen notepad perform one two oper notepad step copi copi charact present screen partial copi allow past past charact copi last time given integ n return minimum number oper get charact exactli n time screen exampl 1 input n 3 output 3 explan initi one charact step 1 use copi oper step 2 use past oper get aa step 3 use past oper get aaa exampl 2 input n 1 output 0 constraint 1 n 1000 2keyskeyboard
given two 0index integ array nums1 nums2 length n 1index 2d array queri queriesi xi yi ith queri find maximum valu nums1j nums2j among indic j 0 j n nums1j xi nums2j yi 1 j satisfi constraint return array answer answeri answer ith queri exampl 1 input nums1 4312 nums2 2495 queri 411325 output 6107 explan 1st queri xi 4 yi 1 select index j 0 sinc nums1j 4 nums2j 1 sum nums1j nums2j 6 show 6 maximum obtain 2nd queri xi 1 yi 3 select index j 2 sinc nums1j 1 nums2j 3 sum nums1j nums2j 10 show 10 maximum obtain 3rd queri xi 2 yi 5 select index j 3 sinc nums1j 2 nums2j 5 sum nums1j nums2j 7 show 7 maximum obtain therefor return 6107 exampl 2 input nums1 325 nums2 234 queri 443211 output 999 explan exampl use index j 2 queri sinc satisfi constraint queri exampl 3 input nums1 21 nums2 23 queri 33 output 1 explan one queri exampl xi 3 yi 3 everi index j either nums1j xi nums2j yi henc solut constraint nums1length nums2length n nums1length 1 n 105 1 nums1i nums2i 109 1 querieslength 105 queriesilength 2 xi queriesi1 yi queriesi2 1 xi yi 109 maximumsumqueri
given parenthes string contain charact parenthes string balanc left parenthesi must correspond two consecut right parenthesi left parenthesi must go correspond two consecut right parenthesi word treat open parenthesi close parenthesi exampl balanc balanc insert charact posit string balanc need return minimum number insert need make balanc exampl 1 input output 1 explan second two match first match need add one end string balanc exampl 2 input output 0 explan string alreadi balanc exampl 3 input output 3 explan add match first add match last constraint 1 slength 105 consist minimuminsertionstobalanceaparenthesesstr
implement myatoistr function convert string 32bit sign integ similar cc atoi function algorithm myatoistr follow read ignor lead whitespac check next charact alreadi end string read charact either determin final result neg posit respect assum result posit neither present read next charact next nondigit charact end input reach rest string ignor convert digit integ ie 123 123 0032 32 digit read integ 0 chang sign necessari step 2 integ 32bit sign integ rang 231 231 1 clamp integ remain rang specif integ less 231 clamp 231 integ greater 231 1 clamp 231 1 return integ final result note space charact consid whitespac charact ignor charact lead whitespac rest string digit exampl 1 input 42 output 42 explan underlin charact read caret current reader posit step 1 42 charact read lead whitespac step 2 42 charact read neither step 3 42 42 read pars integ 42 sinc 42 rang 231 231 1 final result 42 exampl 2 input 42 output 42 explan step 1 42 lead whitespac read ignor step 2 42 read result neg step 3 42 42 read pars integ 42 sinc 42 rang 231 231 1 final result 42 exampl 3 input 4193 word output 4193 explan step 1 4193 word charact read lead whitespac step 2 4193 word charact read neither step 3 4193 word 4193 read read stop next charact nondigit pars integ 4193 sinc 4193 rang 231 231 1 final result 4193 constraint 0 slength 200 consist english letter lowercas uppercas digit 09 stringtointegeratoi
given integ array num integ k find longest subsequ num meet follow requir subsequ strictli increas differ adjac element subsequ k return length longest subsequ meet requir subsequ array deriv anoth array delet element without chang order remain element exampl 1 input num 4214345815 k 3 output 5 explan longest subsequ meet requir 13458 subsequ length 5 return 5 note subsequ 1345815 meet requir 15 8 7 larger 3 exampl 2 input num 745181247 k 5 output 4 explan longest subsequ meet requir 45812 subsequ length 4 return 4 exampl 3 input num 15 k 1 output 1 explan longest subsequ meet requir 1 subsequ length 1 return 1 constraint 1 numslength 105 1 numsi k 105 longestincreasingsubsequenceii
given array nonoverlap interv interv intervalsi starti endi repres start end ith interv interv sort ascend order starti also given interv newinterv start end repres start end anoth interv insert newinterv interv interv still sort ascend order starti interv still overlap interv merg overlap interv necessari return interv insert exampl 1 input interv 1369 newinterv 25 output 1569 exampl 2 input interv 1235678101216 newinterv 48 output 123101216 explan new interv 48 overlap 3567810 constraint 0 intervalslength 104 intervalsilength 2 0 starti endi 105 interv sort starti ascend order newintervallength 2 0 start end 105 insertinterv
given integ array num array queri queriesi vali indexi queri first appli numsindexi numsindexi vali print sum even valu num return integ array answer answeri answer ith queri exampl 1 input num 1234 queri 10314023 output 8624 explan begin array 1234 ad 1 nums0 array 2234 sum even valu 2 2 4 8 ad 3 nums1 array 2134 sum even valu 2 4 6 ad 4 nums0 array 2134 sum even valu 2 4 2 ad 2 nums3 array 2136 sum even valu 2 6 4 exampl 2 input num 1 queri 40 output 0 constraint 1 numslength 104 104 numsi 104 1 querieslength 104 104 vali 104 0 indexi numslength sumofevennumbersafterqueri
given integ n return list simplifi fraction 0 1 exclus denomin lessthanorequalto n return answer order exampl 1 input n 2 output 12 explan 12 uniqu fraction denomin lessthanorequalto 2 exampl 2 input n 3 output 121323 exampl 3 input n 4 output 1213142334 explan 24 simplifi fraction simplifi 12 constraint 1 n 100 simplifiedfract
root tree consist n node number 0 n 1 node number denot uniqu genet valu ie genet valu node x x genet differ two genet valu defin bitwisexor valu given integ array parent parentsi parent node node x root tree parentsx 1 also given array queri queriesi nodei vali queri find maximum genet differ vali pi pi genet valu node path nodei root includ nodei root formal want maxim vali xor pi return array an ansi answer ith queri exampl 1 input parent 1011 queri 023225 output 237 explan queri process follow 02 node maximum genet differ 0 differ 2 xor 0 2 32 node maximum genet differ 1 differ 2 xor 1 3 25 node maximum genet differ 2 differ 5 xor 2 7 exampl 2 input parent 37120702 queri 4611505 output 6147 explan queri process follow 46 node maximum genet differ 0 differ 6 xor 0 6 115 node maximum genet differ 1 differ 15 xor 1 14 05 node maximum genet differ 2 differ 5 xor 2 7 constraint 2 parentslength 105 0 parentsi parentslength 1 everi node root parentsroot 1 1 querieslength 3 104 0 nodei parentslength 1 0 vali 2 105 maximumgeneticdifferencequeri
given x n integ matrix grid three integ row col color valu grid repres color grid squar locat two squar call adjac next 4 direct two squar belong connect compon color adjac border connect compon squar connect compon either adjac least squar compon boundari grid first last row column color border connect compon contain squar gridrowcol color return final grid exampl 1 input grid 1112 row 0 col 0 color 3 output 3332 exampl 2 input grid 122232 row 0 col 1 color 3 output 133233 exampl 3 input grid 111111111 row 1 col 1 color 2 output 222212222 constraint gridlength n gridilength 1 n 50 1 gridij color 1000 0 row 0 col n coloringabord
given root binari tree imagin stand right side return valu node see order top bottom exampl 1 input root 123null5null4 output 134 exampl 2 input root 1null3 output 13 exampl 3 input root output constraint number node tree rang 0 100 100 nodev 100 binarytreerightsideview
given integ n n x n binari grid grid valu initi 1s except indic given array mine ith element array mine defin minesi xi yi gridxiyi 0 return order largest axisalign plu sign 1s contain grid none return 0 axisalign plu sign 1s order k center gridrc 1 along four arm length k 1 go left right made 1s note could 0s 1s beyond arm plu sign relev area plu sign check 1s exampl 1 input n 5 mine 42 output 2 explan grid largest plu sign order 2 one shown exampl 2 input n 1 mine 00 output 0 explan plu sign return 0 constraint 1 n 500 1 mineslength 5000 0 xi yi n pair xi yi uniqu largestplussign
given string 0index ask perform follow oper get sort string find largest index 1 slength si si 1 find largest index j j slength sk si 1 possibl valu k rang j inclus swap two charact indic 1 j revers suffix start index return number oper need make string sort sinc answer larg return modulo 109 7 exampl 1 input cba output 5 explan simul goe follow oper 1 i2 j2 swap s1 s2 get scab revers suffix start 2 scab oper 2 i1 j2 swap s0 s2 get sbac revers suffix start 1 sbca oper 3 i2 j2 swap s1 s2 get sbac revers suffix start 2 sbac oper 4 i1 j1 swap s0 s1 get sabc revers suffix start 1 sacb oper 5 i2 j2 swap s1 s2 get sabc revers suffix start 2 sabc exampl 2 input aabaa output 2 explan simul goe follow oper 1 i3 j4 swap s2 s4 get saaaab revers substr start 3 saaaba oper 2 i4 j4 swap s3 s4 get saaaab revers substr start 4 saaaab constraint 1 slength 3000 consist lowercas english letter minimumnumberofoperationstomakestringsort
roman numer repres seven differ symbol v x l c symbol valu 1 v 5 x 10 l 50 c 100 500 1000 exampl 2 written ii roman numer two one ad togeth 12 written xii simpli x ii number 27 written xxvii xx v ii roman numer usual written largest smallest left right howev numer four iiii instead number four written iv one five subtract make four principl appli number nine written ix six instanc subtract use place v 5 x 10 make 4 9 x place l 50 c 100 make 40 90 c place 500 1000 make 400 900 given roman numer convert integ exampl 1 input iii output 3 explan iii 3 exampl 2 input lviii output 58 explan l 50 v 5 iii 3 exampl 3 input mcmxciv output 1994 explan 1000 cm 900 xc 90 iv 4 constraint 1 slength 15 contain charact v x l c guarante valid roman numer rang 1 3999 romantointeg
given integ array num sort nondecreas order return array squar number sort nondecreas order exampl 1 input num 410310 output 01916100 explan squar array becom 16109100 sort becom 01916100 exampl 2 input num 732311 output 49949121 constraint 1 numslength 104 104 numsi 104 num sort nondecreas order follow squar element sort new array trivial could find solut use differ approach squaresofasortedarray
given follow detail matrix n column 2 row matrix binari matrix mean element matrix 0 1 sum element 0thupper row given upper sum element 1stlower row given lower sum element ith column0index colsumi colsum given integ array length n task reconstruct matrix upper lower colsum return 2d integ array one valid solut accept valid solut exist return empti 2d array exampl 1 input upper 2 lower 1 colsum 111 output 110001 explan 101010 011100 also correct answer exampl 2 input upper 2 lower 3 colsum 2211 output exampl 3 input upper 5 lower 5 colsum 2120101201 output 11101001001010001101 constraint 1 colsumlength 105 0 upper lower colsumlength 0 colsumi 2 reconstructa2rowbinarymatrix
string nice everi letter alphabet contain appear uppercas lowercas exampl ababb nice appear b b appear howev aba b appear b given string return longest substr nice multipl return substr earliest occurr none return empti string exampl 1 input yazaaay output aaa explan aaa nice string aa letter alphabet appear aaa longest nice substr exampl 2 input bb output bb explan bb nice string b b appear whole string substr exampl 3 input c output explan nice substr constraint 1 slength 100 consist uppercas lowercas english letter longestnicesubstr
given integ n integ p rang 0 n 1 repres 0index array arr length n posit set 0s except posit p set 1 also given integ array ban contain posit array ith posit ban arrbannedi 0 bannedi p perform multipl oper arr oper choos subarray size k revers subarray howev 1 arr never go posit ban word oper arrbannedi remain 0 return array an 0 n 1 ansi minimum number revers oper need bring 1 posit arr 1 imposs subarray contigu nonempti sequenc element within array valu ansi independ revers array array contain valu revers order exampl 1 input n 4 p 0 ban 12 k 4 output 0111 explan case k 4 one possibl revers oper perform revers whole array initi 1 place posit 0 amount oper need posit 0 0 never place 1 ban posit answer posit 1 2 1 final one revers oper bring 1 index 3 answer posit 3 1 exampl 2 input n 5 p 0 ban 24 k 3 output 01111 explan case 1 initi posit 0 answer posit 0 perform revers oper size 3 1 current locat posit 0 need revers subarray 0 2 leav posit revers subarray make posit 2 1 shouldnt happen cant move 1 posit 0 make result posit 1 exampl 3 input n 4 p 2 ban 013 k 1 output 1101 explan case perform revers oper size 1 1 never chang posit constraint 1 n 105 0 p n 1 0 bannedlength n 1 0 bannedi n 1 1 k n bannedi p valu ban uniqu minimumreverseoper
given string lower upper case english letter good string string doesnt two adjac charact si si 1 0 slength 2 si lowercas letter si 1 letter uppercas viceversa make string good choos two adjac charact make string bad remov keep string becom good return string make good answer guarante uniqu given constraint notic empti string also good exampl 1 input leeeetcod output leetcod explan first step either choos 1 2 result leeeetcod reduc leetcod exampl 2 input abbacc output explan mani possibl scenario lead answer exampl abbacc aacc cc abbacc abba aa exampl 3 input output constraint 1 slength 100 contain lower upper case english letter makethestringgreat
peak element element strictli greater neighbor given 0index integ array num find peak element return index array contain multipl peak return index peak may imagin nums1 numsn ∞ word element alway consid strictli greater neighbor outsid array must write algorithm run olog n time exampl 1 input num 1231 output 2 explan 3 peak element function return index number 2 exampl 2 input num 1213564 output 5 explan function return either index number 1 peak element 2 index number 5 peak element 6 constraint 1 numslength 1000 231 numsi 231 1 numsi numsi 1 valid findpeakel
given x n integ grid account accountsij amount money ith custom jth bank return wealth richest custom custom wealth amount money bank account richest custom custom maximum wealth exampl 1 input account 123321 output 6 explan 1st custom wealth 1 2 3 6 2nd custom wealth 3 2 1 6 custom consid richest wealth 6 return 6 exampl 2 input account 157335 output 10 explan 1st custom wealth 6 2nd custom wealth 10 3rd custom wealth 8 2nd custom richest wealth 10 exampl 3 input account 287713195 output 17 constraint accountslength n accountsilength 1 n 50 1 accountsij 100 richestcustomerwealth
given 0index array posit integ w wi describ weight ith index need implement function pickindex randomli pick index rang 0 wlength 1 inclus return probabl pick index wi sumw exampl w 1 3 probabl pick index 0 1 1 3 025 ie 25 probabl pick index 1 3 1 3 075 ie 75 exampl 1 input solutionpickindex 1 output null0 explan solut solut new solution1 solutionpickindex return 0 option return 0 sinc one element w exampl 2 input solutionpickindexpickindexpickindexpickindexpickindex 13 output null11110 explan solut solut new solution1 3 solutionpickindex return 1 return second element index 1 probabl 34 solutionpickindex return 1 solutionpickindex return 1 solutionpickindex return 1 solutionpickindex return 0 return first element index 0 probabl 14 sinc random problem multipl answer allow follow output consid correct null11110 null11111 null11100 null11101 null10100 constraint 1 wlength 104 1 wi 105 pickindex call 104 time randompickwithweight
given root two binari tree root subroot return true subtre root structur node valu subroot fals otherwis subtre binari tree tree tree consist node tree node descend tree tree could also consid subtre exampl 1 input root 34512 subroot 412 output true exampl 2 input root 34512nullnullnullnull0 subroot 412 output fals constraint number node root tree rang 1 2000 number node subroot tree rang 1 1000 104 rootval 104 104 subrootv 104 subtreeofanothertre
sql schema tabl custom column name type id int name varchar refereeid int id primari key column tabl row tabl indic id custom name id custom refer write sql queri report name custom refer custom id 2 return result tabl order queri result format follow exampl exampl 1 input custom tabl id name refereeid 1 null 2 jane null 3 alex 2 4 bill null 5 zack 1 6 mark 2 output name jane bill zack findcustomerrefere
given integ array num return maximum differ two success element sort form array contain less two element return 0 must write algorithm run linear time use linear extra space exampl 1 input num 3691 output 3 explan sort form array 1369 either 36 69 maximum differ 3 exampl 2 input num 10 output 0 explan array contain less 2 element therefor return 0 constraint 1 numslength 105 0 numsi 109 maximumgap
given alphanumer string return second largest numer digit appear 1 exist alphanumer string string consist lowercas english letter digit exampl 1 input dfa12321afd output 2 explan digit appear 1 2 3 second largest digit 2 exampl 2 input abc1111 output 1 explan digit appear 1 second largest digit constraint 1 slength 500 consist lowercas english letter andor digit secondlargestdigitinastr
given x n binari matrix mat one step choos one cell flip four neighbor exist flip chang 1 0 0 1 pair cell call neighbor share one edg return minimum number step requir convert mat zero matrix 1 binari matrix matrix cell equal 0 1 zero matrix matrix cell equal 0 exampl 1 input mat 0001 output 3 explan one possibl solut flip 1 0 0 1 final 1 1 shown exampl 2 input mat 0 output 0 explan given matrix zero matrix need chang exampl 3 input mat 100100 output 1 explan given matrix zero matrix constraint matlength n matilength 1 n 3 matij either 0 1 minimumnumberofflipstoconvertbinarymatrixtozeromatrix
special squar room mirror four wall except southwest corner receptor remain corner number 0 1 2 squar room wall length p laser ray southwest corner first meet east wall distanc q 0th receptor given two integ p q return number receptor ray meet first test case guarante ray meet receptor eventu exampl 1 input p 2 q 1 output 2 explan ray meet receptor 2 first time get reflect back left wall exampl 2 input p 3 q 1 output 1 constraint 1 q p 1000 mirrorreflect
given coordin four point 2d space p1 p2 p3 p4 return true four point construct squar coordin point pi repres xi yi input given order valid squar four equal side posit length four equal angl 90degre angl exampl 1 input p1 00 p2 11 p3 10 p4 01 output true exampl 2 input p1 00 p2 11 p3 10 p4 012 output fals exampl 3 input p1 10 p2 10 p3 01 p4 01 output true constraint p1length p2length p3length p4length 2 104 xi yi 104 validsquar
given two binari tree root1 root2 imagin put one cover node two tree overlap other need merg two tree new binari tree merg rule two node overlap sum node valu new valu merg node otherwis null node use node new tree return merg tree note merg process must start root node tree exampl 1 input root1 1325 root2 213null4null7 output 34554null7 exampl 2 input root1 1 root2 12 output 22 constraint number node tree rang 0 2000 104 nodev 104 mergetwobinarytre
given stream record particular stock record contain timestamp correspond price stock timestamp unfortun due volatil natur stock market record come order even wors record may incorrect anoth record timestamp may appear later stream correct price previou wrong record design algorithm updat price stock particular timestamp correct price previou record timestamp find latest price stock base current record latest price price latest timestamp record find maximum price stock base current record find minimum price stock base current record implement stockpric class stockpric initi object price record void updateint timestamp int price updat price stock given timestamp int current return latest price stock int maximum return maximum price stock int minimum return minimum price stock exampl 1 input stockpric updat updat current maximum updat maximum updat minimum 1 10 2 5 1 3 4 2 output null null null 5 10 null 5 null 2 explan stockpric stockpric new stockpric stockpriceupdate1 10 timestamp 1 correspond price 10 stockpriceupdate2 5 timestamp 12 correspond price 105 stockpricecurr return 5 latest timestamp 2 price 5 stockpricemaximum return 10 maximum price 10 timestamp 1 stockpriceupdate1 3 previou timestamp 1 wrong price updat 3 timestamp 12 correspond price 35 stockpricemaximum return 5 maximum price 5 correct stockpriceupdate4 2 timestamp 124 correspond price 352 stockpriceminimum return 2 minimum price 2 timestamp 4 constraint 1 timestamp price 109 105 call made total updat current maximum minimum current maximum minimum call updat call least stockpricefluctu
digit string good digit 0index even indic even digit odd indic prime 2 3 5 7 exampl 2582 good digit 2 8 even posit even digit 5 2 odd posit prime howev 3245 good 3 even index even given integ n return total number good digit string length n sinc answer may larg return modulo 109 7 digit string string consist digit 0 9 may contain lead zero exampl 1 input n 1 output 5 explan good number length 1 0 2 4 6 8 exampl 2 input n 4 output 400 exampl 3 input n 50 output 564908303 constraint 1 n 1015 countgoodnumb
given 0index integ array num repres strength hero power group hero defin follow let i0 i1 ik indic hero group power group maxnumsi0 numsi1 numsik2 minnumsi0 numsi1 numsik return sum power nonempti group hero possibl sinc sum could larg return modulo 109 7 exampl 1 input num 214 output 141 explan 1st group 2 power 22 2 8 2nd group 1 power 12 1 1 3rd group 4 power 42 4 64 4th group 21 power 22 1 4 5th group 24 power 42 2 32 6th group 14 power 42 1 16 7th group 214 power 42 1 16 sum power group 8 1 64 4 32 16 16 141 exampl 2 input num 111 output 7 explan total 7 group possibl power group 1 therefor sum power group 7 constraint 1 numslength 105 1 numsi 109 powerofhero
given x n matrix charact box repres sideview box cell box one follow stone stationari obstacl empti box rotat 90 degre clockwis caus stone fall due graviti stone fall land obstacl anoth stone bottom box graviti affect obstacl posit inertia box rotat affect stone horizont posit guarante stone box rest obstacl anoth stone bottom box return n x matrix repres box rotat describ exampl 1 input box output exampl 2 input box output exampl 3 input box output constraint boxlength n boxilength 1 n 500 boxij either rotatingthebox
numbottl water bottl initi full water exchang numexchang empti water bottl market one full water bottl oper drink full water bottl turn empti bottl given two integ numbottl numexchang return maximum number water bottl drink exampl 1 input numbottl 9 numexchang 3 output 13 explan exchang 3 empti bottl get 1 full water bottl number water bottl drink 9 3 1 13 exampl 2 input numbottl 15 numexchang 4 output 19 explan exchang 4 empti bottl get 1 full water bottl number water bottl drink 15 3 1 19 constraint 1 numbottl 100 2 numexchang 100 waterbottl
given string consist lowercas english letter integ k first convert integ replac letter posit alphabet ie replac 1 b 2 z 26 transform integ replac sum digit repeat transform oper k time total exampl zbax k 2 result integ would 8 follow oper convert zbax ➝ 262124 ➝ 262124 ➝ 262124 transform 1 262124 ➝ 2 6 2 1 2 4 ➝ 17 transform 2 17 ➝ 1 7 ➝ 8 return result integ perform oper describ exampl 1 input iiii k 1 output 36 explan oper follow convert iiii ➝ 9999 ➝ 9999 ➝ 9999 transform 1 9999 ➝ 9 9 9 9 ➝ 36 thu result integ 36 exampl 2 input leetcod k 2 output 6 explan oper follow convert leetcod ➝ 12552031545 ➝ 12552031545 ➝ 12552031545 transform 1 12552031545 ➝ 1 2 5 5 2 0 3 1 5 4 5 ➝ 33 transform 2 33 ➝ 3 3 ➝ 6 thu result integ 6 exampl 3 input zbax k 2 output 8 constraint 1 slength 100 1 k 10 consist lowercas english letter sumofdigitsofstringafterconvert
given two integ n k construct list answer contain n differ posit integ rang 1 n obey follow requir suppos list answer a1 a2 a3 list a1 a2 a2 a3 a3 a4 an1 exactli k distinct integ return list answer multipl valid answer return exampl 1 input n 3 k 1 output 123 explan 123 three differ posit integ rang 1 3 11 exactli 1 distinct integ 1 exampl 2 input n 3 k 2 output 132 explan 132 three differ posit integ rang 1 3 21 exactli 2 distinct integ 1 2 constraint 1 k n 104 beautifularrangementii
given two integ n consid x n grid cell initi white paint cell red green blue cell must paint return number way color grid two adjac cell color sinc answer larg return modulo 109 7 exampl 1 input 1 n 1 output 3 explan three possibl color shown imag exampl 2 input 1 n 2 output 6 explan six possibl color shown imag exampl 3 input 5 n 5 output 580986 constraint 1 5 1 n 1000 paintingagridwiththreedifferentcolor
given integ n return counter function counter function initi return n return 1 previou valu everi subsequ time call n n 1 n 2 etc exampl 1 input n 10 callcallcal output 101112 explan counter 10 first time counter call return n counter 11 return 1 previou time counter 12 return 1 previou time exampl 2 input n 2 callcallcallcallcal output 21012 explan counter initi return 2 increas sebsequ call constraint 1000 n 1000 1000 call counter made counter
kbeauti integ num defin number substr num read string meet follow condit length k divisor num given integ num k return kbeauti num note lead zero allow 0 divisor valu substr contigu sequenc charact string exampl 1 input num 240 k 2 output 2 explan follow substr num length k 24 240 24 divisor 240 40 240 40 divisor 240 therefor kbeauti 2 exampl 2 input num 430043 k 2 output 2 explan follow substr num length k 43 430043 43 divisor 430043 30 430043 30 divisor 430043 00 430043 0 divisor 430043 04 430043 4 divisor 430043 43 430043 43 divisor 430043 therefor kbeauti 2 constraint 1 num 109 1 k numlength take num string findthekbeautyofanumb
sql schema pandan schema tabl employe column name type id int salari int sql id primari key column tabl row tabl contain inform salari employe find second highest salari employe tabl second highest salari return null return none panda result format follow exampl exampl 1 input employe tabl id salari 1 100 2 200 3 300 output secondhighestsalari 200 exampl 2 input employe tabl id salari 1 100 output secondhighestsalari null secondhighestsalari
given two string current correct repres two 24hour time 24hour time format hhmm hh 00 23 mm 00 59 earliest 24hour time 0000 latest 2359 one oper increas time current 1 5 15 60 minut perform oper number time return minimum number oper need convert current correct exampl 1 input current 0230 correct 0435 output 3 explan convert current correct 3 oper follow add 60 minut current current becom 0330 add 60 minut current current becom 0430 add 5 minut current current becom 0435 proven possibl convert current correct fewer 3 oper exampl 2 input current 1100 correct 1101 output 1 explan add one minut current minimum number oper need 1 constraint current correct format hhmm current correct minimumnumberofoperationstoconverttim
tree ie connect undirect graph cycl structur countri network consist n citi number 0 n 1 exactli n 1 road capit citi citi 0 given 2d integ array road roadsi ai bi denot exist bidirect road connect citi ai bi meet repres citi meet capit citi car citi given integ seat indic number seat car repres use car citi travel chang car ride anoth repres cost travel two citi one liter fuel return minimum number liter fuel reach capit citi exampl 1 input road 010203 seat 5 output 3 explan representative1 goe directli capit 1 liter fuel representative2 goe directli capit 1 liter fuel representative3 goe directli capit 1 liter fuel cost 3 liter fuel minimum proven 3 minimum number liter fuel need exampl 2 input road 313210040546 seat 2 output 7 explan representative2 goe directli citi 3 1 liter fuel representative2 representative3 go togeth citi 1 1 liter fuel representative2 representative3 go togeth capit 1 liter fuel representative1 goe directli capit 1 liter fuel representative5 goe directli capit 1 liter fuel representative6 goe directli citi 4 1 liter fuel representative4 representative6 go togeth capit 1 liter fuel cost 7 liter fuel minimum proven 7 minimum number liter fuel need exampl 3 input road seat 1 output 0 explan repres need travel capit citi constraint 1 n 105 roadslength n 1 roadsilength 2 0 ai bi n ai bi road repres valid tree 1 seat 105 minimumfuelcosttoreporttothecapit
given two sort 0index integ array nums1 nums2 well integ k return kth 1base smallest product nums1i nums2j 0 nums1length 0 j nums2length exampl 1 input nums1 25 nums2 34 k 2 output 8 explan 2 smallest product nums10 nums20 2 3 6 nums10 nums21 2 4 8 2nd smallest product 8 exampl 2 input nums1 4203 nums2 24 k 6 output 0 explan 6 smallest product nums10 nums21 4 4 16 nums10 nums20 4 2 8 nums11 nums21 2 4 8 nums11 nums20 2 2 4 nums12 nums20 0 2 0 nums12 nums21 0 4 0 6th smallest product 0 exampl 3 input nums1 21012 nums2 31245 k 3 output 6 explan 3 smallest product nums10 nums24 2 5 10 nums10 nums23 2 4 8 nums14 nums20 2 3 6 3rd smallest product 6 constraint 1 nums1length nums2length 5 104 105 nums1i nums2j 105 1 k nums1length nums2length nums1 nums2 sort kthsmallestproductoftwosortedarray
given array num distinct posit integ return number tupl b c b c b c element num b c exampl 1 input num 2346 output 8 explan 8 valid tupl 2634 2643 6234 6243 3426 4326 3462 4362 exampl 2 input num 124510 output 16 explan 16 valid tupl 11025 11052 10125 10152 25110 25101 52110 52101 21045 21054 10245 10254 45210 45102 54210 54102 constraint 1 numslength 1000 1 numsi 104 element num distinct tuplewithsameproduct
given n x n 2d matrix repres imag rotat imag 90 degre clockwis rotat imag inplac mean modifi input 2d matrix directli alloc anoth 2d matrix rotat exampl 1 input matrix 123456789 output 741852963 exampl 2 input matrix 51911248101336715141216 output 15132514341126891671011 constraint n matrixlength matrixilength 1 n 20 1000 matrixij 1000 rotateimag
long flowerb plot plant howev flower plant adjac plot given integ array flowerb contain 0s 1s 0 mean empti 1 mean empti integ n return true n new flower plant flowerb without violat noadjacentflow rule fals otherwis exampl 1 input flowerb 10001 n 1 output true exampl 2 input flowerb 10001 n 2 output fals constraint 1 flowerbedlength 2 104 flowerbedi 0 1 two adjac flower flowerb 0 n flowerbedlength canplaceflow
given 0index string consist lowercas english letter letter appear exactli twice also given 0index integ array distanc length 26 letter alphabet number 0 25 ie 0 b 1 c 2 z 25 wellspac string number letter two occurr ith letter distancei ith letter appear distancei ignor return true wellspac string otherwis return fals exampl 1 input abaccb distanc 13050000000000000000000000 output true explan appear indic 0 2 satisfi distance0 1 b appear indic 1 5 satisfi distance1 3 c appear indic 3 4 satisfi distance2 0 note distance3 5 sinc appear ignor return true wellspac string exampl 2 input aa distanc 10000000000000000000000000 output fals explan appear indic 0 1 zero letter distance0 1 wellspac string constraint 2 slength 52 consist lowercas english letter letter appear exactli twice distancelength 26 0 distancei 50 checkdistancesbetweensamelett
given array num rotat nonneg integ k array becom numsk numsk 1 numsnumslength 1 nums0 nums1 numsk1 afterward entri less equal index worth one point exampl num 24130 rotat k 2 becom 13024 worth 3 point 1 0 point 3 1 point 0 2 one point 2 3 one point 4 4 one point return rotat index k correspond highest score achiev rotat num multipl answer return smallest index k exampl 1 input num 23140 output 3 explan score k list k 0 num 23140 score 2 k 1 num 31402 score 3 k 2 num 14023 score 3 k 3 num 40231 score 4 k 4 num 02314 score 3 choos k 3 highest score exampl 2 input num 13024 output 0 explan num alway 3 point matter shift choos smallest k 0 constraint 1 numslength 105 0 numsi numslength smallestrotationwithhighestscor
given 2 integ n start task return permut p 0122n 1 p0 start pi pi1 differ one bit binari represent p0 p2n 1 must also differ one bit binari represent exampl 1 input n 2 start 3 output 3201 explan binari represent permut 11100001 adjac element differ one bit anoth valid permut 3102 exampl 2 input n 3 start 2 output 26754013 explan binari represent permut 010110111101100000001011 constraint 1 n 16 0 start 2 n circularpermutationinbinaryrepresent
given 0index string 0index integ array space describ indic origin string space ad space insert charact given index exampl given enjoyyourcoffe space 5 9 place space c indic 5 9 respect thu obtain enjoy coffe return modifi string space ad exampl 1 input leetcodehelpsmelearn space 81315 output leetcod help learn explan indic 8 13 15 correspond underlin charact leetcodehelpsmelearn place space charact exampl 2 input icodeinpython space 1579 output code py thon explan indic 1 5 7 9 correspond underlin charact icodeinpython place space charact exampl 3 input space space 0123456 output p c n g explan also abl place space first charact string constraint 1 slength 3 105 consist lowercas uppercas english letter 1 spaceslength 3 105 0 spacesi slength 1 valu space strictli increas addingspacestoastr
given 0index array uniqu string word palindrom pair pair integ j 0 j wordslength j wordsi wordsj concaten two string palindrom return array palindrom pair word exampl 1 input word abcddcballsssssl output 01103224 explan palindrom abcddcbadcbaabcdsllsllssssl exampl 2 input word battabcat output 0110 explan palindrom battabtabbat exampl 3 input word output 0110 explan palindrom aa constraint 1 wordslength 5000 0 wordsilength 300 wordsi consist lowercas english letter palindromepair
given integ array num length n integ target find three integ num sum closest target return sum three integ may assum input would exactli one solut exampl 1 input num 1214 target 1 output 2 explan sum closest target 2 1 2 1 2 exampl 2 input num 000 target 1 output 0 explan sum closest target 0 0 0 0 0 constraint 3 numslength 500 1000 numsi 1000 104 target 104 3sumclosest
sql schema tabl cinema column name type id int movi varchar descript varchar rate float id primari key tabl row contain inform name movi genr rate rate 2 decim place float rang 0 10 write sql queri report movi oddnumb id descript bore return result tabl order rate descend order queri result format follow exampl exampl 1 input cinema tabl id movi descript rate 1 war great 3d 89 2 scienc fiction 85 3 irish bore 62 4 ice song fantaci 86 5 hous card interest 91 output id movi descript rate 5 hous card interest 91 1 war great 3d 89 explan three movi oddnumb id 1 3 5 movi id 3 bore includ answer notboringmovi
given two nonneg integ low high return count odd number low high inclus exampl 1 input low 3 high 7 output 3 explan odd number 3 7 357 exampl 2 input low 8 high 10 output 1 explan odd number 8 10 9 constraint 0 low high 109 countoddnumbersinanintervalrang
given binari array num subarray array good contain exactli one element valu 1 return integ denot number way split array num good subarray number may larg return modulo 109 7 subarray contigu nonempti sequenc element within array exampl 1 input num 01001 output 3 explan 3 way split num good subarray 01 001 010 01 0100 1 exampl 2 input num 010 output 1 explan 1 way split num good subarray 010 constraint 1 numslength 105 0 numsi 1 waystosplitarrayintogoodsubarray
given two integ repres numer denomin fraction return fraction string format fraction part repeat enclos repeat part parenthes multipl answer possibl return guarante length answer string less 104 given input exampl 1 input numer 1 denomin 2 output 05 exampl 2 input numer 2 denomin 1 output 2 exampl 3 input numer 4 denomin 333 output 0012 constraint 231 numer denomin 231 1 denomin 0 fractiontorecurringdecim
given 0index x n integ matrix grid initi posit topleft cell 0 0 start cell j move one follow cell cell k j k gridij j rightward movement cell k j k gridij downward movement return minimum number cell need visit reach bottomright cell 1 n 1 valid path return 1 exampl 1 input grid 3421423121002400 output 4 explan imag show one path visit exactli 4 cell exampl 2 input grid 3421421121103410 output 3 explan imag show one path visit exactli 3 cell exampl 3 input grid 210100 output 1 explan proven path exist constraint gridlength n gridilength 1 n 105 1 n 105 0 gridij n gridm 1n 1 0 minimumnumberofvisitedcellsinagrid
write api gener fanci sequenc use append addal multal oper implement fanci class fanci initi object empti sequenc void appendv append integ val end sequenc void addallinc increment exist valu sequenc integ inc void multallm multipli exist valu sequenc integ int getindexidx get current valu index idx 0index sequenc modulo 109 7 index greater equal length sequenc return 1 exampl 1 input fanci append addal append multal getindex addal append multal getindex getindex getindex 2 3 7 2 0 3 10 2 0 1 2 output null null null null null 10 null null null 26 34 20 explan fanci fanci new fanci fancyappend2 fanci sequenc 2 fancyaddall3 fanci sequenc 23 5 fancyappend7 fanci sequenc 5 7 fancymultall2 fanci sequenc 52 72 10 14 fancygetindex0 return 10 fancyaddall3 fanci sequenc 103 143 13 17 fancyappend10 fanci sequenc 13 17 10 fancymultall2 fanci sequenc 132 172 102 26 34 20 fancygetindex0 return 26 fancygetindex1 return 34 fancygetindex2 return 20 constraint 1 val inc 100 0 idx 105 105 call total made append addal multal getindex fancysequ
given 0index string word length n consist digit posit integ divis array div word integ array length n divi 1 numer valu word0i divis divi 0 otherwis return divis array word exampl 1 input word 998244353 3 output 110001100 explan 4 prefix divis 3 9 99 998244 9982443 exampl 2 input word 1010 10 output 0101 explan 2 prefix divis 10 10 1010 constraint 1 n 105 wordlength n word consist digit 0 9 1 109 findthedivisibilityarrayofastr
given object array obj return compact object compact object origin object except key contain falsi valu remov oper appli object nest object array consid object indic key valu consid falsi booleanvalu return fals may assum obj output jsonpars word valid json exampl 1 input obj null 0 fals 1 output 1 explan falsi valu remov array exampl 2 input obj null b fals 1 output b 1 explan obja objb0 falsi valu remov exampl 3 input obj null 0 5 0 fals 16 output 5 16 explan obj0 obj1 obj30 obj40 falsi remov constraint obj valid json object 2 jsonstringifyobjlength 106 compactobject
given string consist lower case english letter bracket revers string pair match parenthes start innermost one result contain bracket exampl 1 input abcd output dcba exampl 2 input ulovei output iloveu explan substr love revers first whole string revers exampl 3 input edetocel output leetcod explan first revers substr oc etco final whole string constraint 1 slength 2000 contain lower case english charact parenthes guarante parenthes balanc reversesubstringsbetweeneachpairofparenthes
given binari tree root return maximum sum key subtre also binari search tree bst assum bst defin follow left subtre node contain node key less node key right subtre node contain node key greater node key left right subtre must also binari search tree exampl 1 input root 1432425nullnullnullnullnullnull46 output 20 explan maximum sum valid binari search tree obtain root node key equal 3 exampl 2 input root 43null12 output 2 explan maximum sum valid binari search tree obtain singl root node key equal 2 exampl 3 input root 425 output 0 explan valu neg return empti bst constraint number node tree rang 1 4 104 4 104 nodev 4 104 maximumsumbstinbinarytre
sql schema pandan schema tabl custom column name type id int name varchar sql id primari key column tabl row tabl indic id name custom tabl order column name type id int customerid int sql id primari key column tabl customerid foreign key join key panda id custom tabl row tabl indic id order id custom order find custom never order anyth return result tabl order result format follow exampl exampl 1 input custom tabl id name 1 joe 2 henri 3 sam 4 max order tabl id customerid 1 3 2 1 output custom henri max customerswhoneverord
given string repres express evalu express return valu integ divis truncat toward zero may assum given express alway valid intermedi result rang 231 231 1 note allow use builtin function evalu string mathemat express eval exampl 1 input 322 output 7 exampl 2 input 32 output 1 exampl 3 input 35 2 output 5 constraint 1 slength 3 105 consist integ oper separ number space repres valid express integ express nonneg integ rang 0 231 1 answer guarante fit 32bit integ basiccalculatorii
deliveri compani want build new servic center new citi compani know posit custom citi 2dmap want build new center posit sum euclidean distanc custom minimum given array posit positionsi xi yi posit ith custom map return minimum sum euclidean distanc custom word need choos posit servic center xcentr ycentr follow formula minim answer within 105 actual valu accept exampl 1 input posit 01101221 output 400000 explan shown see choos xcentr ycentr 1 1 make distanc custom 1 sum distanc 4 minimum possibl achiev exampl 2 input posit 1133 output 282843 explan minimum possibl sum distanc sqrt2 sqrt2 282843 constraint 1 positionslength 50 positionsilength 2 0 xi yi 100 bestpositionforaservicecentr
given array distinct integ arr find pair element minimum absolut differ two element return list pair ascend orderwith respect pair pair b follow b arr b b equal minimum absolut differ two element arr exampl 1 input arr 4213 output 122334 explan minimum absolut differ 1 list pair differ equal 1 ascend order exampl 2 input arr 1361015 output 13 exampl 3 input arr 3810231941427 output 141019232327 constraint 2 arrlength 105 106 arri 106 minimumabsolutediffer
given two posit integ num1 num2 find posit integ x x number set bit num2 valu x xor num1 minim note xor bitwis xor oper return integ x test case gener x uniqu determin number set bit integ number 1s binari represent exampl 1 input num1 3 num2 5 output 3 explan binari represent num1 num2 0011 0101 respect integ 3 number set bit num2 valu 3 xor 3 0 minim exampl 2 input num1 1 num2 12 output 3 explan binari represent num1 num2 0001 1100 respect integ 3 number set bit num2 valu 3 xor 1 2 minim constraint 1 num1 num2 109 minimizexor
given string number repres posit integ charact digit return result string remov exactli one occurr digit number valu result string decim form maxim test case gener digit occur least number exampl 1 input number 123 digit 3 output 12 explan one 3 123 remov 3 result 12 exampl 2 input number 1231 digit 1 output 231 explan remov first 1 get 231 remov second 1 get 123 sinc 231 123 return 231 exampl 3 input number 551 digit 5 output 51 explan remov either first second 5 551 result string 51 constraint 2 numberlength 100 number consist digit 1 9 digit digit 1 9 digit occur least number removedigitfromnumbertomaximizeresult
given binari string one second occurr 01 simultan replac 10 process repeat occurr 01 exist return number second need complet process exampl 1 input 0110101 output 4 explan one second becom 1011010 anoth second becom 1101100 third second becom 1110100 fourth second becom 1111000 occurr 01 exist longer process need 4 second complet return 4 exampl 2 input 11100 output 0 explan occurr 01 exist process need 0 second complet return 0 constraint 1 slength 1000 si either 0 1 follow solv problem time complex timeneededtorearrangeabinarystr
given 0index integ array num one oper choos two differ indic j 0 j numslength choos nonneg integ k kth bit 0index binari represent numsi numsj 1 subtract 2k numsi numsj subarray beauti possibl make element equal 0 appli oper number time return number beauti subarray array num subarray contigu nonempti sequenc element within array exampl 1 input num 43124 output 2 explan 2 beauti subarray num 43124 43124 make element subarray 312 equal 0 follow way choos 3 1 2 k 1 subtract 21 number subarray becom 1 1 0 choos 1 1 0 k 0 subtract 20 number subarray becom 0 0 0 make element subarray 43124 equal 0 follow way choos 4 3 1 2 4 k 2 subtract 22 number subarray becom 0 3 1 2 0 choos 0 3 1 2 0 k 0 subtract 20 number subarray becom 0 2 0 2 0 choos 0 2 0 2 0 k 1 subtract 21 number subarray becom 0 0 0 0 0 exampl 2 input num 1104 output 0 explan beauti subarray num constraint 1 numslength 105 0 numsi 106 countthenumberofbeautifulsubarray
robot x n grid robot initi locat topleft corner ie grid00 robot tri move bottomright corner ie gridm 1n 1 robot move either right point time given two integ n return number possibl uniqu path robot take reach bottomright corner test case gener answer less equal 2 109 exampl 1 input 3 n 7 output 28 exampl 2 input 3 n 2 output 3 explan topleft corner total 3 way reach bottomright corner 1 right 2 right 3 right constraint 1 n 100 uniquepath
sql schema tabl sale column name type saleid int productid int year int quantiti int price int saleid year primari key tabl productid foreign key product tabl row tabl show sale product productid certain year note price per unit tabl product column name type productid int productnam varchar productid primari key tabl row tabl indic product name product write sql queri report productnam year price saleid sale tabl return result tabl order queri result format follow exampl exampl 1 input sale tabl saleid productid year quantiti price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 product tabl productid productnam 100 nokia 200 appl 300 samsung output productnam year price nokia 2008 5000 nokia 2009 5000 appl 2011 9000 explan saleid 1 conclud nokia sold 5000 year 2008 saleid 2 conclud nokia sold 5000 year 2009 saleid 7 conclud appl sold 9000 year 2011 productsalesanalysisi
given list song ith song durat timei second return number pair song total durat second divis 60 formal want number indic j j timei timej 60 0 exampl 1 input time 302015010040 output 3 explan three pair total durat divis 60 time0 30 time2 150 total durat 180 time1 20 time3 100 total durat 120 time1 20 time4 40 total durat 60 exampl 2 input time 606060 output 3 explan three pair total durat 120 divis 60 constraint 1 timelength 6 104 1 timei 500 pairsofsongswithtotaldurationsdivisibleby60
given nonneg integ array num one oper must choos posit integ x x less equal smallest nonzero element num subtract x everi posit element num return minimum number oper make everi element num equal 0 exampl 1 input num 15035 output 3 explan first oper choos x 1 num 04024 second oper choos x 2 num 02002 third oper choos x 2 num 00000 exampl 2 input num 0 output 0 explan element num alreadi 0 oper need constraint 1 numslength 100 0 numsi 100 makearrayzerobysubtractingequalamount
attend record student repres string charact signifi whether student absent late present day record contain follow three charact absent l late p present student elig attend award meet follow criteria student absent strictli fewer 2 day total student never late l 3 consecut day given integ n return number possibl attend record length n make student elig attend award answer may larg return modulo 109 7 exampl 1 input n 2 output 8 explan 8 record length 2 elig award pp ap pa lp pl al la aa elig 2 absenc need fewer 2 exampl 2 input n 1 output 3 exampl 3 input n 10101 output 183236316 constraint 1 n 105 studentattendancerecordii
n point road drive taxi n point road label 1 n direct go want drive point 1 point n make money pick passeng chang direct taxi passeng repres 0index 2d integ array ride ridesi starti endi tipi denot ith passeng request ride point starti point endi will give tipi dollar tip passeng pick earn endi starti tipi dollar may drive one passeng time given n ride return maximum number dollar earn pick passeng optim note may drop passeng pick differ passeng point exampl 1 input n 5 ride 254151 output 7 explan pick passeng 0 earn 5 2 4 7 dollar exampl 2 input n 20 ride 161310210123111221215213181 output 20 explan pick follow passeng drive passeng 1 point 3 point 10 profit 10 3 2 9 dollar drive passeng 2 point 10 point 12 profit 12 10 3 5 dollar drive passeng 5 point 13 point 18 profit 18 13 1 6 dollar earn 9 5 6 20 dollar total constraint 1 n 105 1 rideslength 3 104 ridesilength 3 1 starti endi n 1 tipi 105 maximumearningsfromtaxi
nqueen puzzl problem place n queen n x n chessboard two queen attack given integ n return distinct solut nqueen puzzl may return answer order solut contain distinct board configur nqueen placement q indic queen empti space respect exampl 1 input n 4 output qqqqqqqq explan exist two distinct solut 4queen puzzl shown exampl 2 input n 1 output q constraint 1 n 9 nqueen
given binari matrix matrix size x n allow rearrang column matrix order return area largest submatrix within matrix everi element submatrix 1 reorder column optim exampl 1 input matrix 001111101 output 4 explan rearrang column shown largest submatrix 1s bold area 4 exampl 2 input matrix 10101 output 3 explan rearrang column shown largest submatrix 1s bold area 3 exampl 3 input matrix 110101 output 2 explan notic must rearrang entir column way make submatrix 1s larger area 2 constraint matrixlength n matrixilength 1 n 105 matrixij either 0 1 largestsubmatrixwithrearrang
concert hall n row number 0 n 1 seat number 0 1 need design ticket system alloc seat follow case group k spectat sit togeth row everi member group k spectat get seat may may sit togeth note spectat picki henc book seat member group get seat row number less equal maxrow maxrow vari group group case multipl row choos row smallest number chosen multipl seat choos row seat smallest number chosen implement bookmyshow class bookmyshowint n int initi object n number row number seat per row int gatherint k int maxrow return array length 2 denot row seat number respect first seat alloc k member group must sit togeth word return smallest possibl r c c c k 1 seat valid empti row r r maxrow return case possibl alloc seat group boolean scatterint k int maxrow return true k member group alloc seat row 0 maxrow may may sit togeth seat alloc alloc k seat group smallest row number smallest possibl seat number row otherwis return fals exampl 1 input bookmyshow gather gather scatter scatter 2 5 4 0 2 0 5 1 5 1 output null 0 0 true fals explan bookmyshow bm new bookmyshow2 5 2 row 5 seat bmsgather4 0 return 0 0 group book seat 0 3 row 0 bmsgather2 0 return 1 seat left row 0 possibl book 2 consecut seat bmsscatter5 1 return true group book seat 4 row 0 seat 0 3 row 1 bmsscatter5 1 return fals one seat left hall constraint 1 n 5 104 1 k 109 0 maxrow n 1 5 104 call total made gather scatter bookingconcertticketsingroup
1index binari string length n bit 0 initi flip bit binari string ie chang 0 1 one one given 1index integ array flip flipsi indic bit index flip ith step binari string prefixalign ith step bit inclus rang 1 one bit zero return number time binari string prefixalign flip process exampl 1 input flip 32415 output 2 explan binari string initi 00000 appli step 1 string becom 00100 prefixalign appli step 2 string becom 01100 prefixalign appli step 3 string becom 01110 prefixalign appli step 4 string becom 11110 prefixalign appli step 5 string becom 11111 prefixalign see string prefixalign 2 time return 2 exampl 2 input flip 4123 output 1 explan binari string initi 0000 appli step 1 string becom 0001 prefixalign appli step 2 string becom 1001 prefixalign appli step 3 string becom 1101 prefixalign appli step 4 string becom 1111 prefixalign see string prefixalign 1 time return 1 constraint n flipslength 1 n 5 104 flip permut integ rang 1 n numberoftimesbinarystringisprefixalign
warehous row barcod ith barcod barcodesi rearrang barcod two adjac barcod equal may return answer guarante answer exist exampl 1 input barcod 111222 output 212121 exampl 2 input barcod 11112233 output 13131212 constraint 1 barcodeslength 10000 1 barcodesi 10000 distantbarcod
given integ n denot total number server 2d 0index integ array log logsi serverid time denot server id serverid receiv request time time also given integ x 0index integ array queri return 0index integ array arr length querieslength arri repres number server receiv request time interv queriesi x queriesi note time interv inclus exampl 1 input n 3 log 132615 x 5 queri 1011 output 12 explan queries0 server id 1 2 get request durat 5 10 henc server 3 get zero request queries1 server id 2 get request durat 611 henc server id 1 3 server receiv request time period exampl 2 input n 3 log 24211231 x 2 queri 34 output 01 explan queries0 server get least one request durat 1 3 queries1 server id 3 get request durat 24 constraint 1 n 105 1 logslength 105 1 querieslength 105 logsilength 2 1 logsi0 n 1 logsi1 106 1 x 105 x queriesi 106 countzerorequestserv
write function find longest common prefix string amongst array string common prefix return empti string exampl 1 input str flowerflowflight output fl exampl 2 input str dogracecarcar output explan common prefix among input string constraint 1 strslength 200 0 strsilength 200 strsi consist lowercas english letter longestcommonprefix
given two integ array equal length target arr one step select nonempti subarray arr revers allow make number step return true make arr equal target fals otherwis exampl 1 input target 1234 arr 2413 output true explan follow next step convert arr target 1 revers subarray 241 arr becom 1423 2 revers subarray 42 arr becom 1243 3 revers subarray 43 arr becom 1234 multipl way convert arr target way exampl 2 input target 7 arr 7 output true explan arr equal target without revers exampl 3 input target 379 arr 3711 output fals explan arr valu 9 never convert target constraint targetlength arrlength 1 targetlength 1000 1 targeti 1000 1 arri 1000 maketwoarraysequalbyreversingsubarray
n friend play game friend sit circl number 1 n clockwis order formal move clockwis ith friend bring i1th friend 1 n move clockwis nth friend bring 1st friend rule game follow 1st friend receiv ball 1st friend pass friend k step away clockwis direct friend receiv ball pass friend 2 k step away clockwis direct friend receiv ball pass friend 3 k step away clockwis direct forth word ith turn friend hold ball pass friend k step away clockwis direct game finish friend receiv ball second time loser game friend receiv ball entir game given number friend n integ k return array answer contain loser game ascend order exampl 1 input n 5 k 2 output 45 explan game goe follow 1 start 1st friend pass ball friend 2 step away 3rd friend 2 3rd friend pass ball friend 4 step away 2nd friend 3 2nd friend pass ball friend 6 step away 3rd friend 4 game end 3rd friend receiv ball second time exampl 2 input n 4 k 4 output 234 explan game goe follow 1 start 1st friend pass ball friend 4 step away 1st friend 2 game end 1st friend receiv ball second time constraint 1 k n 50 findthelosersofthecirculargam
given array integ num integ k return total number subarray whose sum equal k subarray contigu nonempti sequenc element within array exampl 1 input num 111 k 2 output 2 exampl 2 input num 123 k 3 output 2 constraint 1 numslength 2 104 1000 numsi 1000 107 k 107 subarraysumequalsk
given two string order charact order uniqu sort custom order previous permut charact match order order sort specif charact x occur charact order x occur permut string return permut satisfi properti exampl 1 input order cba abcd output cbad explan b c appear order order b c c b sinc appear order posit return string dcba cdba cbda also valid output exampl 2 input order cbafg abcd output cbad constraint 1 orderlength 26 1 slength 200 order consist lowercas english letter charact order uniqu customsortstr
string call happi prefix nonempti prefix also suffix exclud given string return longest happi prefix return empti string prefix exist exampl 1 input level output l explan contain 4 prefix exclud l le lev leve suffix l el vel evel largest prefix also suffix given l exampl 2 input ababab output abab explan abab largest prefix also suffix overlap origin string constraint 1 slength 105 contain lowercas english letter longesthappyprefix
given 0index integ array num exist array arr length numslength arri sum j j numsj numsi j j set arri 0 return array arr exampl 1 input num 13112 output 50340 explan 0 nums0 nums2 nums0 nums3 therefor arr0 0 2 0 3 5 1 arr1 0 index valu 3 2 nums2 nums0 nums2 nums3 therefor arr2 2 0 2 3 3 3 nums3 nums0 nums3 nums2 therefor arr3 3 0 3 2 4 4 arr4 0 index valu 2 exampl 2 input num 053 output 000 explan sinc element num distinct arri 0 constraint 1 numslength 105 0 numsi 109 sumofdist
given array integ num calcul pivot index array pivot index index sum number strictli left index equal sum number strictli index right index left edg array left sum 0 element left also appli right edg array return leftmost pivot index index exist return 1 exampl 1 input num 173656 output 3 explan pivot index 3 left sum nums0 nums1 nums2 1 7 3 11 right sum nums4 nums5 5 6 11 exampl 2 input num 123 output 1 explan index satisfi condit problem statement exampl 3 input num 211 output 0 explan pivot index 0 left sum 0 element left index 0 right sum nums1 nums2 1 1 0 constraint 1 numslength 104 1000 numsi 1000 note question 1991 httpsleetcodecomproblemsfindthemiddleindexinarray findpivotindex
given integ array data repres data return whether valid utf8 encod ie translat sequenc valid utf8 encod charact charact utf8 1 4 byte long subject follow rule 1byte charact first bit 0 follow unicod code nbyte charact first n bit one n 1 bit 0 follow n 1 byte signific 2 bit 10 utf8 encod would work number byte utf8 octet sequenc binari 1 0xxxxxxx 2 110xxxxx 10xxxxxx 3 1110xxxx 10xxxxxx 10xxxxxx 4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx x denot bit binari form byte may either 0 1 note input array integ least signific 8 bit integ use store data mean integ repres 1 byte data exampl 1 input data 1971301 output true explan data repres octet sequenc 11000101 10000010 00000001 valid utf8 encod 2byte charact follow 1byte charact exampl 2 input data 2351404 output fals explan data repres octet sequenc 11101011 10001100 00000100 first 3 bit one 4th bit 0 mean 3byte charact next byte continu byte start 10 that correct second continu byte start 10 invalid constraint 1 datalength 2 104 0 datai 255 utf8valid
given array integ num slide window size k move left array right see k number window time slide window move right one posit return max slide window exampl 1 input num 13135367 k 3 output 335567 explan window posit max 1 3 1 3 5 3 6 7 3 1 3 1 3 5 3 6 7 3 1 3 1 3 5 3 6 7 5 1 3 1 3 5 3 6 7 5 1 3 1 3 5 3 6 7 6 1 3 1 3 5 3 6 7 7 exampl 2 input num 1 k 1 output 1 constraint 1 numslength 105 104 numsi 104 1 k numslength slidingwindowmaximum
given array integ arr sort array perform seri pancak flip one pancak flip follow step choos integ k 1 k arrlength revers subarray arr0k1 0index exampl arr 3214 perform pancak flip choos k 3 revers subarray 321 arr 1234 pancak flip k 3 return array kvalu correspond sequenc pancak flip sort arr valid answer sort array within 10 arrlength flip judg correct exampl 1 input arr 3241 output 4243 explan perform 4 pancak flip k valu 4 2 4 3 start state arr 3 2 4 1 1st flip k 4 arr 1 4 2 3 2nd flip k 2 arr 4 1 2 3 3rd flip k 4 arr 3 2 1 4 4th flip k 3 arr 1 2 3 4 sort exampl 2 input arr 123 output explan input alreadi sort need flip anyth note answer 3 3 would also accept constraint 1 arrlength 100 1 arri arrlength integ arr uniqu ie arr permut integ 1 arrlength pancakesort
given function fn array argument arg interv time return cancel function cancelfn function fn call arg immedi call everi millisecond cancelfn call exampl 1 input fn x x 2 arg 4 20 output time 0 return 8 time 20 return 8 time 40 return 8 time 60 return 8 time 80 return 8 time 100 return 8 explan const cancelt 110 const cancel cancellablex x 2 4 20 settimeoutcancel cancelt everi 20m fn4 call t110m cancel 1st fn call 0m fn4 return 8 2nd fn call 20m fn4 return 8 3rd fn call 40m fn4 return 8 4th fn call 60m fn4 return 8 5th fn call 80m fn4 return 8 6th fn call 100m fn4 return 8 cancel 110m exampl 2 input fn x1 x2 x1 x2 arg 2 5 25 output time 0 return 10 time 25 return 10 time 50 return 10 time 75 return 10 time 100 return 10 time 125 return 10 explan const cancelt 140 const cancel cancellablex1 x2 x1 x2 2 5 25 settimeoutcancel cancelt everi 25m fn2 5 call t140m cancel 1st fn call 0m 2nd fn call 25m 3rd fn call 50m 4th fn call 75m 5th fn call 100m 6th fn call 125m cancel 140m exampl 3 input fn x1 x2 x3 x1 x2 x3 arg 5 1 3 50 output time 0 return 9 time 50 return 9 time 100 return 9 time 150 return 9 explan const cancelt 180 const cancel cancellablex1 x2 x3 x1 x2 x3 5 1 3 50 settimeoutcancel cancelt everi 50m fn5 1 3 call t180m cancel 1st fn call 0m 2nd fn call 50m 3rd fn call 100m 4th fn call 150m cancel 180m constraint fn function arg valid json array 1 argslength 10 20 1000 10 cancelt 1000 intervalcancel
infinit plane robot initi stand 0 0 face north note north direct posit direct yaxi south direct neg direct yaxi east direct posit direct xaxi west direct neg direct xaxi robot receiv one three instruct g go straight 1 unit l turn 90 degre left ie anticlockwis direct r turn 90 degre right ie clockwis direct robot perform instruct given order repeat forev return true exist circl plane robot never leav circl exampl 1 input instruct ggllgg output true explan robot initi 0 0 face north direct g move one step posit 0 1 direct north g move one step posit 0 2 direct north l turn 90 degre anticlockwis posit 0 2 direct west l turn 90 degre anticlockwis posit 0 2 direct south g move one step posit 0 1 direct south g move one step posit 0 0 direct south repeat instruct robot goe cycl 0 0 0 1 0 2 0 1 0 0 base return true exampl 2 input instruct gg output fals explan robot initi 0 0 face north direct g move one step posit 0 1 direct north g move one step posit 0 2 direct north repeat instruct keep advanc north direct go cycl base return fals exampl 3 input instruct gl output true explan robot initi 0 0 face north direct g move one step posit 0 1 direct north l turn 90 degre anticlockwis posit 0 1 direct west g move one step posit 1 1 direct west l turn 90 degre anticlockwis posit 1 1 direct south g move one step posit 1 0 direct south l turn 90 degre anticlockwis posit 1 0 direct east g move one step posit 0 0 direct east l turn 90 degre anticlockwis posit 0 0 direct north repeat instruct robot goe cycl 0 0 0 1 1 1 1 0 0 0 base return true constraint 1 instructionslength 100 instructionsi g l r robotboundedincircl
citi consist n intersect number 0 n 1 bidirect road intersect input gener reach intersect intersect one road two intersect given integ n 2d integ array road roadsi ui vi timei mean road intersect ui vi take timei minut travel want know mani way travel intersect 0 intersect n 1 shortest amount time return number way arriv destin shortest amount time sinc answer may larg return modulo 109 7 exampl 1 input n 7 road 067012123133633351651251045462 output 4 explan shortest amount time take go intersect 0 intersect 6 7 minut four way get 7 minut 0 ➝ 6 0 ➝ 4 ➝ 6 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6 exampl 2 input n 2 road 1010 output 1 explan one way go intersect 0 intersect 1 take 10 minut constraint 1 n 200 n 1 roadslength n n 1 2 roadsilength 3 0 ui vi n 1 1 timei 109 ui vi one road connect two intersect reach intersect intersect numberofwaystoarriveatdestin
given integ array num want maxim number point get perform follow oper number time pick numsi delet earn numsi point afterward must delet everi element equal numsi 1 everi element equal numsi 1 return maximum number point earn appli oper number time exampl 1 input num 342 output 6 explan perform follow oper delet 4 earn 4 point consequ 3 also delet num 2 delet 2 earn 2 point num earn total 6 point exampl 2 input num 223334 output 9 explan perform follow oper delet 3 earn 3 point 2s 4s also delet num 33 delet 3 earn 3 point num 3 delet 3 earn 3 point num earn total 9 point constraint 1 numslength 2 104 1 numsi 104 deleteandearn
given 0index integ array num rearrang valu num accord follow rule sort valu odd indic num nonincreas order exampl num 4123 step becom 4321 valu odd indic 1 3 sort nonincreas order sort valu even indic num nondecreas order exampl num 4123 step becom 2143 valu even indic 0 2 sort nondecreas order return array form rearrang valu num exampl 1 input num 4123 output 2341 explan first sort valu present odd indic 1 3 nonincreas order num chang 4123 4321 next sort valu present even indic 0 2 nondecreas order num chang 4123 2341 thu array form rearrang valu 2341 exampl 2 input num 21 output 21 explan sinc exactli one odd index one even index rearrang valu take place result array form 21 initi array constraint 1 numslength 100 1 numsi 100 sortevenandoddindicesindepend
arrayform integ num array repres digit left right order exampl num 1321 array form 1321 given num arrayform integ integ k return arrayform integ num k exampl 1 input num 1200 k 34 output 1234 explan 1200 34 1234 exampl 2 input num 274 k 181 output 455 explan 274 181 455 exampl 3 input num 215 k 806 output 1021 explan 215 806 1021 constraint 1 numlength 104 0 numi 9 num contain lead zero except zero 1 k 104 addtoarrayformofinteg
given x n binari matrix matrix choos number column matrix flip everi cell column ie chang valu cell 0 1 vice versa return maximum number row valu equal number flip exampl 1 input matrix 0111 output 1 explan flip valu 1 row valu equal exampl 2 input matrix 0110 output 2 explan flip valu first column row equal valu exampl 3 input matrix 000001110 output 2 explan flip valu first two column last two row equal valu constraint matrixlength n matrixilength 1 n 300 matrixij either 0 1 flipcolumnsformaximumnumberofequalrow
product differ two pair b c defin b c exampl product differ 5 6 2 7 5 6 2 7 16 given integ array num choos four distinct indic w x z product differ pair numsw numsx numsi numsz maxim return maximum product differ exampl 1 input num 56274 output 34 explan choos indic 1 3 first pair 6 7 indic 2 4 second pair 2 4 product differ 6 7 2 4 34 exampl 2 input num 4259748 output 64 explan choos indic 3 6 first pair 9 8 indic 1 5 second pair 2 4 product differ 9 8 2 4 64 constraint 4 numslength 104 1 numsi 104 maximumproductdifferencebetweentwopair
n coupl sit 2n seat arrang row want hold hand peopl seat repres integ array row rowi id person sit ith seat coupl number order first coupl 0 1 second coupl 2 3 last coupl 2n 2 2n 1 return minimum number swap everi coupl sit side side swap consist choos two peopl stand switch seat exampl 1 input row 0213 output 1 explan need swap second row1 third row2 person exampl 2 input row 3201 output 0 explan coupl alreadi seat side side constraint 2n rowlength 2 n 30 n even 0 rowi 2n element row uniqu couplesholdinghand
given string consist digit 1 9 two integ k minlength partit call beauti partit k nonintersect substr substr length least minlength substr start prime digit end nonprim digit prime digit 2 3 5 7 rest digit nonprim return number beauti partit sinc answer may larg return modulo 109 7 substr contigu sequenc charact within string exampl 1 input 23542185131 k 3 minlength 2 output 3 explan exist three way creat beauti partit 2354 218 5131 2354 21851 31 2354218 51 31 exampl 2 input 23542185131 k 3 minlength 3 output 1 explan exist one way creat beauti partit 2354 218 5131 exampl 3 input 3312958 k 3 minlength 1 output 1 explan exist one way creat beauti partit 331 29 58 constraint 1 k minlength slength 1000 consist digit 1 9 numberofbeautifulpartit
given 0index posit integ array num posit integ k pair number num1 num2 call excel follow condit satisfi number num1 num2 exist array num sum number set bit num1 num2 num1 num2 greater equal k bitwis oper bitwis oper return number distinct excel pair two pair b c consid distinct either c b exampl 1 2 2 1 distinct note pair num1 num2 num1 num2 also excel least one occurr num1 array exampl 1 input num 1231 k 3 output 5 explan excel pair follow 3 3 3 3 3 3 equal 11 binari total number set bit 2 2 4 greater equal k 3 2 3 3 2 2 3 equal 10 binari 2 3 equal 11 binari total number set bit 1 2 3 1 3 3 1 1 3 equal 01 binari 1 3 equal 11 binari total number set bit 1 2 3 number excel pair 5 exampl 2 input num 511 k 10 output 0 explan excel pair array constraint 1 numslength 105 1 numsi 109 1 k 60 numberofexcellentpair
given 0index 2d integ array grid size x n repres field cell one three valu 0 repres grass 1 repres fire 2 repres wall fire pass situat topleft cell 0 0 want travel safehous bottomright cell 1 n 1 everi minut may move adjac grass cell move everi fire cell spread adjac cell wall return maximum number minut stay initi posit move still safe reach safehous imposs return 1 alway reach safehous regardless minut stay return 109 note even fire spread safehous immedi reach count safe reach safehous cell adjac anoth cell former directli north east south west latter ie side touch exampl 1 input grid 02000000002210020012000222020000000 output 3 explan figur show scenario stay initi posit 3 minut still abl safe reach safehous stay 3 minut allow safe reach safehous exampl 2 input grid 000001200200 output 1 explan figur show scenario immedi move toward safehous fire spread cell move toward imposs safe reach safehous thu 1 return exampl 3 input grid 000220120 output 1000000000 explan figur show initi grid notic fire contain wall alway abl safe reach safehous thu 109 return constraint gridlength n gridilength 2 n 300 4 n 2 104 gridij either 0 1 2 grid00 gridm 1n 1 0 escapethespreadingfir
sql schema tabl activ column name type machineid int processid int activitytyp enum timestamp float tabl show user activ factori websit machineid processid activitytyp primari key tabl machineid id machin processid id process run machin id machineid activitytyp enum type start end timestamp float repres current time second start mean machin start process given timestamp end mean machin end process given timestamp start timestamp alway end timestamp everi machineid processid pair factori websit sever machin run number process write sql queri find averag time machin take complet process time complet process end timestamp minu start timestamp averag time calcul total time complet everi process machin divid number process run result tabl machineid along averag time processingtim round 3 decim place return result tabl order queri result format follow exampl exampl 1 input activ tabl machineid processid activitytyp timestamp 0 0 start 0712 0 0 end 1520 0 1 start 3140 0 1 end 4120 1 0 start 0550 1 0 end 1550 1 1 start 0430 1 1 end 1420 2 0 start 4100 2 0 end 4512 2 1 start 2500 2 1 end 5000 output machineid processingtim 0 0894 1 0995 2 1456 explan 3 machin run 2 process machin 0s averag time 1520 0712 4120 3140 2 0894 machin 1s averag time 1550 0550 1420 0430 2 0995 machin 2s averag time 4512 4100 5000 2500 2 1456 averagetimeofprocesspermachin
given 0index integ array num index part hill num closest nonequ neighbor smaller numsi similarli index part valley num closest nonequ neighbor larger numsi adjac indic j part hill valley numsi numsj note index part hill valley must nonequ neighbor left right index return number hill valley num exampl 1 input num 241165 output 3 explan index 0 nonequ neighbor 2 left index 0 neither hill valley index 1 closest nonequ neighbor 4 2 1 sinc 4 2 4 1 index 1 hill index 2 closest nonequ neighbor 1 4 6 sinc 1 4 1 6 index 2 valley index 3 closest nonequ neighbor 1 4 6 sinc 1 4 1 6 index 3 valley note part valley index 2 index 4 closest nonequ neighbor 6 1 5 sinc 6 1 6 5 index 4 hill index 5 nonequ neighbor 5 right index 5 neither hill valley 3 hill valley return 3 exampl 2 input num 665541 output 0 explan index 0 nonequ neighbor 6 left index 0 neither hill valley index 1 nonequ neighbor 6 left index 1 neither hill valley index 2 closest nonequ neighbor 5 6 4 sinc 5 6 5 4 index 2 neither hill valley index 3 closest nonequ neighbor 5 6 4 sinc 5 6 5 4 index 3 neither hill valley index 4 closest nonequ neighbor 4 5 1 sinc 4 5 4 1 index 4 neither hill valley index 5 nonequ neighbor 1 right index 5 neither hill valley 0 hill valley return 0 constraint 3 numslength 100 1 numsi 100 counthillsandvalleysinanarray
sql schema pandan schema tabl product column name type productid int lowfat enum recycl enum sql productid primari key tabl lowfat enum type n mean product low fat n mean recycl enum type n mean product recycl n mean find id product low fat recycl return result tabl order result format follow exampl exampl 1 input product tabl productid lowfat recycl 0 n 1 2 n 3 4 n n output productid 1 3 explan product 1 3 low fat recycl recyclableandlowfatproduct
undirect graph n node node number 0 n 1 given 2d array graph graphu array node node u adjac formal v graphu undirect edg node u node v graph follow properti selfedg graphu contain u parallel edg graphu contain duplic valu v graphu u graphv graph undirect graph may connect mean may two node u v path graph bipartit node partit two independ set b everi edg graph connect node set node set b return true bipartit exampl 1 input graph 1230201302 output fals explan way partit node two independ set everi edg connect node one node exampl 2 input graph 13021302 output true explan partit node two set 0 2 1 3 constraint graphlength n 1 n 100 0 graphulength n 0 graphui n 1 graphu contain u valu graphu uniqu graphu contain v graphv contain u isgraphbipartit
n tile tile one letter tilesi print return number possibl nonempti sequenc letter make use letter print tile exampl 1 input tile aab output 8 explan possibl sequenc b aa ab ba aab aba baa exampl 2 input tile aaabbc output 188 exampl 3 input tile v output 1 constraint 1 tileslength 7 tile consist uppercas english letter lettertileposs
given integ array height repres height build brick ladder start journey build 0 move next build possibl use brick ladder move build build i1 0index current build height greater equal next build height need ladder brick current build height less next build height either use one ladder hi1 hi brick return furthest build index 0index reach use given ladder brick optim exampl 1 input height 427691412 brick 5 ladder 1 output 4 explan start build 0 follow step go build 1 without use ladder brick sinc 4 2 go build 2 use 5 brick must use either brick ladder 2 7 go build 3 without use ladder brick sinc 7 6 go build 4 use ladder must use either brick ladder 6 9 imposs go beyond build 4 brick ladder exampl 2 input height 4122731820319 brick 10 ladder 2 output 7 exampl 3 input height 143193 brick 17 ladder 0 output 3 constraint 1 heightslength 105 1 heightsi 106 0 brick 109 0 ladder heightslength furthestbuildingyoucanreach
n seat n student room given array seat length n seatsi posit ith seat also given array student length n studentsj posit jth student may perform follow move number time increas decreas posit ith student 1 ie move ith student posit x x 1 x 1 return minimum number move requir move student seat two student seat note may multipl seat student posit begin exampl 1 input seat 315 student 274 output 4 explan student move follow first student move posit 2 posit 1 use 1 move second student move posit 7 posit 5 use 2 move third student move posit 4 posit 3 use 1 move total 1 2 1 4 move use exampl 2 input seat 4159 student 1326 output 7 explan student move follow first student move second student move posit 3 posit 4 use 1 move third student move posit 2 posit 5 use 3 move fourth student move posit 6 posit 9 use 3 move total 0 1 3 3 7 move use exampl 3 input seat 2266 student 1326 output 4 explan note two seat posit 2 two seat posit 6 student move follow first student move posit 1 posit 2 use 1 move second student move posit 3 posit 6 use 3 move third student move fourth student move total 1 3 0 0 4 move use constraint n seatslength studentslength 1 n 100 1 seatsi studentsj 100 minimumnumberofmovestoseateveryon
given string integ k return length longest substr frequenc charact substr greater equal k substr exist return 0 exampl 1 input aaabb k 3 output 3 explan longest substr aaa repeat 3 time exampl 2 input ababbc k 2 output 5 explan longest substr ababb repeat 2 time b repeat 3 time constraint 1 slength 104 consist lowercas english letter 1 k 105 longestsubstringwithatleastkrepeatingcharact
given array num n integ numsi rang 1 n return array integ rang 1 n appear num exampl 1 input num 43278231 output 56 exampl 2 input num 11 output 2 constraint n numslength 1 n 105 1 numsi n follow could without extra space runtim may assum return list count extra space findallnumbersdisappearedinanarray
given root binari tree n node node assign uniqu valu 1 n also given array queri size perform independ queri tree ith queri follow remov subtre root node valu queriesi tree guarante queriesi equal valu root return array answer size answeri height tree perform ith queri note queri independ tree return initi state queri height tree number edg longest simpl path root node tree exampl 1 input root 1342null65nullnullnullnullnull7 queri 4 output 2 explan diagram show tree remov subtre root node valu 4 height tree 2 path 1 3 2 exampl 2 input root 589213746 queri 3248 output 3232 explan follow queri remov subtre root node valu 3 height tree becom 3 path 5 8 2 4 remov subtre root node valu 2 height tree becom 2 path 5 8 1 remov subtre root node valu 4 height tree becom 3 path 5 8 2 6 remov subtre root node valu 8 height tree becom 2 path 5 9 3 constraint number node tree n 2 n 105 1 nodev n valu tree uniqu querieslength 1 minn 104 1 queriesi n queriesi rootval heightofbinarytreeaftersubtreeremovalqueri
given string lowercas english charact task remov minimum number parenthes posit result parenthes string valid return valid string formal parenthes string valid empti string contain lowercas charact written ab concaten b b valid string written valid string exampl 1 input leetcod output leetcod explan leetcod leetcod would also accept exampl 2 input abcd output abcd exampl 3 input output explan empti string also valid constraint 1 slength 105 si either lowercas english letter minimumremovetomakevalidparenthes
countri n citi number 0 n 1 countri road connect everi pair citi friend number 0 1 travel countri one take path consist citi path repres integ array contain visit citi order path may contain citi citi list consecut given integ n 2d integ array path pathsi integ array repres path ith friend return length longest common subpath share everi friend path 0 common subpath subpath path contigu sequenc citi within path exampl 1 input n 5 path 01234 234 40123 output 2 explan longest common subpath 23 exampl 2 input n 3 path 012 output 0 explan common subpath share three path exampl 3 input n 5 path 01234 43210 output 1 explan possibl longest common subpath 0 1 2 3 4 length 1 constraint 1 n 105 pathslength 2 105 sumpathsilength 105 0 pathsij n citi list multipl time consecut pathsi longestcommonsubpath
given string transform everi letter individu lowercas uppercas creat anoth string return list possibl string could creat return output order exampl 1 input a1b2 output a1b2a1b2a1b2a1b2 exampl 2 input 3z4 output 3z43z4 constraint 1 slength 12 consist lowercas english letter uppercas english letter digit lettercasepermut
given array string str return length longest uncommon subsequ longest uncommon subsequ exist return 1 uncommon subsequ array string string subsequ one string other subsequ string string obtain delet number charact exampl abc subsequ aebdc delet underlin charact aebdc get abc subsequ aebdc includ aebdc aeb empti string exampl 1 input str abacdcea output 3 exampl 2 input str aaaaaaaa output 1 constraint 2 strslength 50 1 strsilength 10 strsi consist lowercas english letter longestuncommonsubsequenceii
given log user action leetcod integ k log repres 2d integ array log logsi idi timei indic user idi perform action minut timei multipl user perform action simultan singl user perform multipl action minut user activ minut uam given user defin number uniqu minut user perform action leetcod minut count even multipl action occur calcul 1index array answer size k j 1 j k answerj number user whose uam equal j return array answer describ exampl 1 input log 0512020513 k 5 output 02000 explan user id0 perform action minut 5 2 5 henc uam 2 minut 5 count user id1 perform action minut 2 3 henc uam 2 sinc user uam 2 answer2 2 remain answerj valu 0 exampl 2 input log 112223 k 4 output 1100 explan user id1 perform singl action minut 1 henc uam 1 user id2 perform action minut 2 3 henc uam 2 one user uam 1 one uam 2 henc answer1 1 answer2 1 remain valu 0 constraint 1 logslength 104 0 idi 109 1 timei 105 k rang maximum uam user 105 findingtheusersactiveminut
permut perm n 1 integ integ rang 0 n repres string length n si permi permi 1 si permi permi 1 given string reconstruct permut perm return multipl valid permut perm return exampl 1 input idid output 04132 exampl 2 input iii output 0123 exampl 3 input ddi output 3201 constraint 1 slength 105 si either distringmatch
given two string return true subsequ fals otherwis subsequ string new string form origin string delet none charact without disturb rel posit remain charact ie ace subsequ abcd aec exampl 1 input abc ahbgdc output true exampl 2 input axc ahbgdc output fals constraint 0 slength 100 0 tlength 104 consist lowercas english letter follow suppos lot incom say s1 s2 sk k 109 want check one one see subsequ scenario would chang code issubsequ
two string word1 word2 consid almost equival differ frequenc letter z word1 word2 3 given two string word1 word2 length n return true word1 word2 almost equival fals otherwis frequenc letter x number time occur string exampl 1 input word1 aaaa word2 bccb output fals explan 4 aaaa 0 bccb differ 4 allow 3 exampl 2 input word1 abcdeef word2 abaaacc output true explan differ frequenc letter word1 word2 3 appear 1 time word1 4 time word2 differ 3 b appear 1 time word1 1 time word2 differ 0 c appear 1 time word1 2 time word2 differ 1 appear 1 time word1 0 time word2 differ 1 e appear 2 time word1 0 time word2 differ 2 f appear 1 time word1 0 time word2 differ 1 exampl 3 input word1 cccddabba word2 babababab output true explan differ frequenc letter word1 word2 3 appear 2 time word1 4 time word2 differ 2 b appear 2 time word1 5 time word2 differ 3 c appear 3 time word1 0 time word2 differ 3 appear 2 time word1 0 time word2 differ 2 constraint n word1length word2length 1 n 100 word1 word2 consist lowercas english letter checkwhethertwostringsarealmostequival
sql schema tabl employe column name type id int name varchar salari int managerid int id primari key column tabl row tabl indic id employe name salari id manag write sql queri find employe earn manag return result tabl order queri result format follow exampl exampl 1 input employe tabl id name salari managerid 1 joe 70000 3 2 henri 80000 4 3 sam 60000 null 4 max 90000 null output employe joe explan joe employe earn manag employeesearningmorethantheirmanag
given sort array num n nonneg integ integ maximumbit want perform follow queri n time find nonneg integ k 2maximumbit nums0 xor nums1 xor xor numsnumslength1 xor k maxim k answer ith queri remov last element current array num return array answer answeri answer ith queri exampl 1 input num 0113 maximumbit 2 output 0323 explan queri answer follow 1st queri num 0113 k 0 sinc 0 xor 1 xor 1 xor 3 xor 0 3 2nd queri num 011 k 3 sinc 0 xor 1 xor 1 xor 3 3 3rd queri num 01 k 2 sinc 0 xor 1 xor 2 3 4th queri num 0 k 3 sinc 0 xor 3 3 exampl 2 input num 2347 maximumbit 3 output 5265 explan queri answer follow 1st queri num 2347 k 5 sinc 2 xor 3 xor 4 xor 7 xor 5 7 2nd queri num 234 k 2 sinc 2 xor 3 xor 4 xor 2 7 3rd queri num 23 k 6 sinc 2 xor 3 xor 6 7 4th queri num 2 k 5 sinc 2 xor 5 7 exampl 3 input num 012257 maximumbit 3 output 436467 constraint numslength n 1 n 105 1 maximumbit 20 0 numsi 2maximumbit num sort ascend order maximumxorforeachqueri
given string consist lowercas english letter one oper delet entir string delet first letter first letter equal follow letter rang 1 slength 2 exampl ababc one oper could delet first two letter get abc sinc first two letter follow two letter equal ab return maximum number oper need delet exampl 1 input abcabcdabc output 2 explan delet first 3 letter abc sinc next 3 letter equal abcdabc delet letter use 2 oper return 2 proven 2 maximum number oper need note second oper delet abc next occurr abc happen next 3 letter exampl 2 input aaabaab output 4 explan delet first letter sinc next letter equal aabaab delet first 3 letter aab sinc next 3 letter equal aab delet first letter sinc next letter equal ab delet letter use 4 oper return 4 proven 4 maximum number oper need exampl 3 input aaaaa output 5 explan oper delet first letter constraint 1 slength 4000 consist lowercas english letter maximumdeletionsonastr
given integ array num two integ limit goal array num interest properti absnumsi limit return minimum number element need add make sum array equal goal array must maintain properti absnumsi limit note absx equal x x 0 x otherwis exampl 1 input num 111 limit 3 goal 4 output 2 explan add 2 3 sum array 1 1 1 2 3 4 exampl 2 input num 11091 limit 100 goal 0 output 1 constraint 1 numslength 105 1 limit 106 limit numsi limit 109 goal 109 minimumelementstoaddtoformagivensum
given integ n indic n cours label 1 n also given array relat relationsi prevcoursei nextcoursei repres prerequisit relationship cours prevcoursei cours nextcoursei cours prevcoursei taken cours nextcoursei also given integ k one semest take k cours long taken prerequisit previou semest cours take return minimum number semest need take cours testcas gener possibl take everi cours exampl 1 input n 4 relat 213114 k 2 output 3 explan figur repres given graph first semest take cours 2 3 second semest take cours 1 third semest take cours 4 exampl 2 input n 5 relat 21314115 k 2 output 4 explan figur repres given graph first semest take cours 2 3 sinc take two per semest second semest take cours 4 third semest take cours 1 fourth semest take cours 5 constraint 1 n 15 1 k n 0 relationslength n n1 2 relationsilength 2 1 prevcoursei nextcoursei n prevcoursei nextcoursei pair prevcoursei nextcoursei uniqu given graph direct acycl graph parallelcoursesii
write function revers string input string given array charact must modifi input array inplac o1 extra memori exampl 1 input hello output olleh exampl 2 input hannah output hannah constraint 1 slength 105 si printabl ascii charact reversestr
given integ array num return number element strictli smaller strictli greater element appear num exampl 1 input num 117215 output 2 explan element 7 element 2 strictli smaller element 11 strictli greater element 11 element 7 strictli smaller element 15 strictli greater total 2 element strictli smaller strictli greater element appear num exampl 2 input num 33390 output 2 explan element 3 element 3 strictli smaller element 90 strictli greater sinc two element valu 3 total 2 element strictli smaller strictli greater element appear num constraint 1 numslength 100 105 numsi 105 countelementswithstrictlysmallerandgreaterel
given perfect binari tree leav level everi parent two children binari tree follow definit struct node int val node left node right node next popul next pointer point next right node next right node next pointer set null initi next pointer set null exampl 1 input root 1234567 output 1234567 explan given perfect binari tree figur function popul next pointer point next right node like figur b serial output level order connect next pointer signifi end level exampl 2 input root output constraint number node tree rang 0 212 1 1000 nodev 1000 followup may use constant extra space recurs approach fine may assum implicit stack space count extra space problem populatingnextrightpointersineachnod
given x n matrix board contain x captur region 4direct surround x region captur flip os xs surround region exampl 1 input board xxxxxooxxxoxxoxx output xxxxxxxxxxxxxoxx explan notic flip border adjac flip bottom border flip three form surround region flip exampl 2 input board x output x constraint boardlength n boardilength 1 n 200 boardij x surroundedregion
given two array arr1 arr2 element arr2 distinct element arr2 also arr1 sort element arr1 rel order item arr1 arr2 element appear arr2 place end arr1 ascend order exampl 1 input arr1 231324679219 arr2 214396 output 222143396719 exampl 2 input arr1 2862284417 arr2 222886 output 2228861744 constraint 1 arr1length arr2length 1000 0 arr1i arr2i 1000 element arr2 distinct arr2i arr1 relativesortarray
nozero integ posit integ contain 0 decim represent given integ n return list two integ b b nozero integ b n test case gener least one valid solut mani valid solut return exampl 1 input n 2 output 11 explan let 1 b 1 b nozero integ b 2 n exampl 2 input n 11 output 29 explan let 2 b 9 b nozero integ b 9 n note valid answer 8 3 accept constraint 2 n 104 convertintegertothesumoftwonozerointeg
sql schema tabl transact column name type id int countri varchar state enum amount int transdat date id primari key tabl tabl inform incom transact state column enum type approv declin write sql queri find month countri number transact total amount number approv transact total amount return result tabl order queri result format follow exampl exampl 1 input transact tabl id countri state amount transdat 121 us approv 1000 20181218 122 us declin 2000 20181219 123 us approv 2000 20190101 124 de approv 2000 20190107 output month countri transcount approvedcount transtotalamount approvedtotalamount 201812 us 2 1 3000 1000 201901 us 1 1 2000 2000 201901 de 1 1 2000 2000 monthlytransactionsi
given string length 5 call time repres current time digit clock format hhmm earliest possibl time 0000 latest possibl time 2359 string time digit repres symbol unknown must replac digit 0 9 return integ answer number valid clock time creat replac everi digit 0 9 exampl 1 input time 500 output 2 explan replac either 0 1 produc 0500 1500 note replac 2 sinc time 2500 invalid total two choic exampl 2 input time 00 output 100 explan replac digit 0 9 100 total choic exampl 3 input time output 1440 explan 24 possibl choic hour 60 possibl choic minut total 24 60 1440 choic constraint time valid string length 5 format hhmm 00 hh 23 00 mm 59 digit might replac need replac digit 0 9 numberofvalidclocktim
given two integ array nums1 nums2 write integ nums1 nums2 order given two separ horizont line may draw connect line straight line connect two number nums1i nums2j nums1i nums2j line draw intersect connect nonhorizont line note connect line intersect even endpoint ie number belong one connect line return maximum number connect line draw way exampl 1 input nums1 142 nums2 124 output 2 explan draw 2 uncross line diagram draw 3 uncross line line nums11 4 nums22 4 intersect line nums122 nums212 exampl 2 input nums1 25125 nums2 1052152 output 3 exampl 3 input nums1 137175 nums2 19251 output 2 constraint 1 nums1length nums2length 500 1 nums1i nums2j 2000 uncrossedlin
sql schema pandan schema tabl product column name type productid int store1 int store2 int store3 int productid primari key tabl row tabl indic product price 3 differ store store1 store2 store3 product avail store price null store column rearrang product tabl row productid store price product avail store includ row productid store combin result tabl return result tabl order result format follow exampl exampl 1 input product tabl productid store1 store2 store3 0 95 100 105 1 70 null 80 output productid store price 0 store1 95 0 store2 100 0 store3 105 1 store1 70 1 store3 80 explan product 0 avail three store price 95 100 105 respect product 1 avail store1 price 70 store3 price 80 product avail store2 rearrangeproductst
social network consist user friendship user two user commun know common languag given integ n array languag array friendship n languag number 1 n languagesi set languag ith user know friendshipsi ui vi denot friendship user ui vi choos one languag teach user friend commun return minimum number user need teach note friendship transit mean x friend friend z doesnt guarante x friend z exampl 1 input n 2 languag 1212 friendship 121323 output 1 explan either teach user 1 second languag user 2 first languag exampl 2 input n 3 languag 213123 friendship 14123423 output 2 explan teach third languag user 1 3 yield two user teach constraint 2 n 500 languageslength 1 500 1 languagesilength n 1 languagesij n 1 ui vi languageslength 1 friendshipslength 500 tupl ui vi uniqu languagesi contain uniqu valu minimumnumberofpeopletoteach
given 0index integ array num say integ x express num exist integ 0 index1 index2 indexk numslength numsindex1 numsindex2 numsindexk x word integ express written bitwis subsequ num return minimum posit nonzero integ express num exampl 1 input num 21 output 4 explan 1 2 alreadi present array know 3 express sinc nums0 nums1 2 1 3 sinc 4 express return 4 exampl 2 input num 532 output 1 explan show 1 smallest number express constraint 1 numslength 105 1 numsi 109 minimumimpossibleor
given tictacto board string array board return true possibl reach board posit cours valid tictacto game board 3 x 3 array consist charact x charact repres empti squar rule tictacto player take turn place charact empti squar first player alway place x charact second player alway place charact x charact alway place empti squar never fill one game end three nonempti charact fill row column diagon game also end squar nonempti move play game exampl 1 input board output fals explan first player alway play x exampl 2 input board xox x output fals explan player take turn make move exampl 3 input board xoxo oxox output true constraint boardlength 3 boardilength 3 boardij either x validtictactoest
given list folder folder return folder remov subfold folder may return answer order folderi locat within anoth folderj call subfold format path one concaten string form follow one lowercas english letter exampl leetcod leetcodeproblem valid path empti string exampl 1 input folder aabcdcdecf output acdcf explan folder ab subfold cde insid folder cd filesystem exampl 2 input folder aabcabd output explan folder abc abd remov subfold exampl 3 input folder abcabcaabd output abcabcaabd constraint 1 folderlength 4 104 2 folderilength 100 folderi contain lowercas letter folderi alway start charact folder name uniqu removesubfoldersfromthefilesystem
given network n node repres n x n adjac matrix graph ith node directli connect jth node graphij 1 node initi initi infect malwar whenev two node directli connect least one two node infect malwar node infect malwar spread malwar continu node infect manner suppos miniti final number node infect malwar entir network spread malwar stop remov exactli one node initi complet remov connect node node return node remov would minim miniti multipl node could remov minim miniti return node smallest index exampl 1 input graph 110110001 initi 01 output 0 exampl 2 input graph 110111011 initi 01 output 1 exampl 3 input graph 1100111001110011 initi 01 output 1 constraint n graphlength n graphilength 2 n 300 graphij 0 1 graphij graphji graphii 1 1 initiallength n 0 initiali n 1 integ initi uniqu minimizemalwarespreadii
given root binari search tree bst return minimum differ valu two differ node tree exampl 1 input root 42613 output 1 exampl 2 input root 1048nullnull1249 output 1 constraint number node tree rang 2 100 0 nodev 105 note question 530 httpsleetcodecomproblemsminimumabsolutedifferenceinbst minimumdistancebetweenbstnod
given 0index integ array num one oper may follow choos two integ num equal remov integ num form pair oper done num mani time possibl return 0index integ array answer size 2 answer0 number pair form answer1 number leftov integ num oper mani time possibl exampl 1 input num 1321322 output 31 explan form pair nums0 nums3 remov num num 32322 form pair nums0 nums2 remov num num 222 form pair nums0 nums1 remov num num 2 pair form total 3 pair form 1 number leftov num exampl 2 input num 11 output 10 explan form pair nums0 nums1 remov num num pair form total 1 pair form 0 number leftov num exampl 3 input num 0 output 01 explan pair form 1 number leftov num constraint 1 numslength 100 0 numsi 100 maximumnumberofpairsinarray
given squar board charact move board start bottom right squar mark charact need reach top left squar mark charact e rest squar label either numer charact 1 2 9 obstacl x one move go left upleft diagon obstacl return list two integ first integ maximum sum numer charact collect second number path take get maximum sum taken modulo 109 7 case path return 0 0 exampl 1 input board e232x212 output 71 exampl 2 input board e121x121 output 42 exampl 3 input board e11xxx11 output 00 constraint 2 boardlength boardilength 100 numberofpathswithmaxscor
given array network tower tower towersi xi yi qi denot ith network tower locat xi yi qualiti factor qi coordin integr coordin xy plane distanc two coordin euclidean distanc also given integ radiu tower reachabl distanc less equal radiu outsid distanc signal becom garbl tower reachabl signal qualiti ith tower coordin x calcul formula ⌊qi 1 d⌋ distanc tower coordin network qualiti coordin sum signal qualiti reachabl tower return array cx cy repres integr coordin cx cy network qualiti maximum multipl coordin network qualiti return lexicograph minimum nonneg coordin note coordin x1 y1 lexicograph smaller x2 y2 either x1 x2 x1 x2 y1 y2 ⌊val⌋ greatest integ less equal val floor function exampl 1 input tower 125217319 radiu 2 output 21 explan coordin 2 1 total qualiti 13 qualiti 7 2 1 result ⌊7 1 sqrt0⌋ ⌊7⌋ 7 qualiti 5 1 2 result ⌊5 1 sqrt2⌋ ⌊207⌋ 2 qualiti 9 3 1 result ⌊9 1 sqrt1⌋ ⌊45⌋ 4 coordin higher network qualiti exampl 2 input tower 231121 radiu 9 output 2311 explan sinc one tower network qualiti highest right tower locat exampl 3 input tower 1213217019 radiu 2 output 12 explan coordin 1 2 highest network qualiti constraint 1 towerslength 50 towersilength 3 0 xi yi qi 50 1 radiu 50 coordinatewithmaximumnetworkqu
given array num integ return mani contain even number digit exampl 1 input num 12345267896 output 2 explan 12 contain 2 digit even number digit 345 contain 3 digit odd number digit 2 contain 1 digit odd number digit 6 contain 1 digit odd number digit 7896 contain 4 digit even number digit therefor 12 7896 contain even number digit exampl 2 input num 5559014821771 output 1 explan 1771 contain even number digit constraint 1 numslength 500 1 numsi 105 findnumberswithevennumberofdigit
want build n new build citi new build built line label 1 n howev citi restrict height new build height build must nonneg integ height first build must 0 height differ two adjac build exceed 1 addit citi restrict maximum height specif build restrict given 2d integ array restrict restrictionsi idi maxheighti indic build idi must height less equal maxheighti guarante build appear restrict build 1 restrict return maximum possibl height tallest build exampl 1 input n 5 restrict 2141 output 2 explan green area imag indic maximum allow height build build build height 01212 tallest build height 2 exampl 2 input n 6 restrict output 5 explan green area imag indic maximum allow height build build build height 012345 tallest build height 5 exampl 3 input n 10 restrict 532574103 output 5 explan green area imag indic maximum allow height build build build height 0123344543 tallest build height 5 constraint 2 n 109 0 restrictionslength minn 1 105 2 idi n idi uniqu 0 maxheighti 109 maximumbuildingheight
transform sequenc word beginword word endword use dictionari wordlist sequenc word beginword s1 s2 sk everi adjac pair word differ singl letter everi si 1 k wordlist note beginword need wordlist sk endword given two word beginword endword dictionari wordlist return number word shortest transform sequenc beginword endword 0 sequenc exist exampl 1 input beginword hit endword cog wordlist hotdotdoglotlogcog output 5 explan one shortest transform sequenc hit hot dot dog cog 5 word long exampl 2 input beginword hit endword cog wordlist hotdotdoglotlog output 0 explan endword cog wordlist therefor valid transform sequenc constraint 1 beginwordlength 10 endwordlength beginwordlength 1 wordlistlength 5000 wordlistilength beginwordlength beginword endword wordlisti consist lowercas english letter beginword endword word wordlist uniqu wordladd
given two posit integ startpo endpo initi stand posit startpo infinit number line one step move either one posit left one posit right given posit integ k return number differ way reach posit endpo start startpo perform exactli k step sinc answer may larg return modulo 109 7 two way consid differ order step made exactli note number line includ neg integ exampl 1 input startpo 1 endpo 2 k 3 output 3 explan reach posit 2 1 exactli 3 step three way 1 2 3 2 1 2 1 2 1 0 1 2 proven way possibl return 3 exampl 2 input startpo 2 endpo 5 k 10 output 0 explan imposs reach posit 5 posit 2 exactli 10 step constraint 1 startpo endpo k 1000 numberofwaystoreachapositionafterexactlykstep
given head singli link list two integ left right left right revers node list posit left posit right return revers list exampl 1 input head 12345 left 2 right 4 output 14325 exampl 2 input head 5 left 1 right 1 output 5 constraint number node list n 1 n 500 500 nodev 500 1 left right n follow could one pass reverselinkedlistii
sever card arrang row card associ number point point given integ array cardpoint one step take one card begin end row take exactli k card score sum point card taken given integ array cardpoint integ k return maximum score obtain exampl 1 input cardpoint 1234561 k 3 output 12 explan first step score alway 1 howev choos rightmost card first maxim total score optim strategi take three card right give final score 1 6 5 12 exampl 2 input cardpoint 222 k 2 output 4 explan regardless two card take score alway 4 exampl 3 input cardpoint 9779779 k 7 output 55 explan take card score sum point card constraint 1 cardpointslength 105 1 cardpointsi 104 1 k cardpointslength maximumpointsyoucanobtainfromcard
given integ array num integ k return true num good subarray fals otherwis good subarray subarray length least two sum element subarray multipl k note subarray contigu part array integ x multipl k exist integ n x n k 0 alway multipl k exampl 1 input num 232467 k 6 output true explan 2 4 continu subarray size 2 whose element sum 6 exampl 2 input num 232647 k 6 output true explan 23 2 6 4 7 continu subarray size 5 whose element sum 42 42 multipl 6 42 7 6 7 integ exampl 3 input num 232647 k 13 output fals constraint 1 numslength 105 0 numsi 109 0 sumnumsi 231 1 1 k 231 1 continuoussubarraysum
given sever box differ color repres differ posit number may experi sever round remov box box left time choos continu box color ie compos k box k 1 remov get k k point return maximum point get exampl 1 input box 132223431 output 23 explan 1 3 2 2 2 3 4 3 1 1 3 3 4 3 1 339 point 1 3 3 3 1 111 point 1 1 339 point 224 point exampl 2 input box 111 output 9 exampl 3 input box 1 output 1 constraint 1 boxeslength 100 1 boxesi 100 removebox
given 0index x n matrix grid consist posit integ start cell first column matrix travers grid follow way cell row col move cell row 1 col 1 row col 1 row 1 col 1 valu cell move strictli bigger valu current cell return maximum number move perform exampl 1 input grid 24355493342111091315 output 3 explan start cell 0 0 make follow move 0 0 0 1 0 1 1 2 1 2 2 3 shown maximum number move made exampl 2 input grid 324219117 output 0 explan start cell first column perform move constraint gridlength n gridilength 2 n 1000 4 n 105 1 gridij 106 maximumnumberofmovesinagrid
given two string str1 str2 return shortest string str1 str2 subsequ multipl valid string return string subsequ string delet number charact possibl 0 result string exampl 1 input str1 abac str2 cab output cabac explan str1 abac subsequ cabac delet first c str2 cab subsequ cabac delet last ac answer provid shortest string satisfi properti exampl 2 input str1 aaaaaaaa str2 aaaaaaaa output aaaaaaaa constraint 1 str1length str2length 1000 str1 str2 consist lowercas english letter shortestcommonsupersequ
given x n binari matrix grid island group 1s repres land connect 4direct horizont vertic may assum four edg grid surround water area island number cell valu 1 island return maximum area island grid island return 0 exampl 1 input grid 00100001000000000000111000011010000000001001100101000100110011100000000000010000000001110000000000110000 output 6 explan answer 11 island must connect 4direct exampl 2 input grid 00000000 output 0 constraint gridlength n gridilength 1 n 50 gridij either 0 1 maxareaofisland
music player contain n differ song want listen goal song necessarili differ trip avoid boredom creat playlist everi song play least song play k song play given n goal k return number possibl playlist creat sinc answer larg return modulo 109 7 exampl 1 input n 3 goal 3 k 1 output 6 explan 6 possibl playlist 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 exampl 2 input n 2 goal 3 k 0 output 6 explan 6 possibl playlist 1 1 2 1 2 1 2 1 1 2 2 1 2 1 2 1 2 2 exampl 3 input n 2 goal 3 k 1 output 2 explan 2 possibl playlist 1 2 1 2 1 2 constraint 0 k n goal 100 numberofmusicplaylist
given integ array num call subset num good product repres product one distinct prime number exampl num 1 2 3 4 2 3 1 2 3 1 3 good subset product 6 23 6 23 3 3 respect 1 4 4 good subset product 4 22 4 22 respect return number differ good subset num modulo 109 7 subset num array obtain delet possibl none element num two subset differ chosen indic delet differ exampl 1 input num 1234 output 6 explan good subset 12 product 2 product distinct prime 2 123 product 6 product distinct prime 2 3 13 product 3 product distinct prime 3 2 product 2 product distinct prime 2 23 product 6 product distinct prime 2 3 3 product 3 product distinct prime 3 exampl 2 input num 42315 output 5 explan good subset 2 product 2 product distinct prime 2 23 product 6 product distinct prime 2 3 215 product 30 product distinct prime 2 3 5 3 product 3 product distinct prime 3 15 product 15 product distinct prime 3 5 constraint 1 numslength 105 1 numsi 30 thenumberofgoodsubset
given integ array num sort nondecreas order determin possibl split num one subsequ follow condit true subsequ consecut increas sequenc ie integ exactli one previou integ subsequ length 3 return true split num accord condit fals otherwis subsequ array new array form origin array delet none element without disturb rel posit remain element ie 135 subsequ 12345 132 exampl 1 input num 123345 output true explan num split follow subsequ 123345 1 2 3 123345 3 4 5 exampl 2 input num 12334455 output true explan num split follow subsequ 12334455 1 2 3 4 5 12334455 3 4 5 exampl 3 input num 123445 output fals explan imposs split num consecut increas subsequ length 3 constraint 1 numslength 104 1000 numsi 1000 num sort nondecreas order splitarrayintoconsecutivesubsequ
sequenc number call arithmet consist least two element differ everi two consecut element formal sequenc arithmet si1 si s1 s0 valid exampl arithmet sequenc 1 3 5 7 9 7 7 7 7 3 1 5 9 follow sequenc arithmet 1 1 2 5 7 given array n integ num two array integ l r repres rang queri ith queri rang li ri array 0index return list boolean element answer answeri true subarray numsli numsli1 numsri rearrang form arithmet sequenc fals otherwis exampl 1 input num 465937 l 002 r 235 output truefalsetru explan 0th queri subarray 465 rearrang 654 arithmet sequenc 1st queri subarray 4659 rearrang arithmet sequenc 2nd queri subarray 5937 rearrang 3579 arithmet sequenc exampl 2 input num 1293126152025201510 l 016487 r 4497910 output falsetruefalsefalsetruetru constraint n numslength llength rlength 2 n 500 1 500 0 li ri n 105 numsi 105 arithmeticsubarray
stream n idkey valu pair arriv arbitrari order idkey integ 1 n valu string two pair id design stream return valu increas order id return chunk list valu insert concaten chunk result list sort valu implement orderedstream class orderedstreamint n construct stream take n valu string insertint idkey string valu insert pair idkey valu stream return largest possibl chunk current insert valu appear next order exampl input orderedstream insert insert insert insert insert 5 3 ccccc 1 aaaaa 2 bbbbb 5 eeeee 4 ddddd output null aaaaa bbbbb ccccc ddddd eeeee explan note valu order id aaaaa bbbbb ccccc ddddd eeeee orderedstream os new orderedstream5 osinsert3 ccccc insert 3 ccccc return osinsert1 aaaaa insert 1 aaaaa return aaaaa osinsert2 bbbbb insert 2 bbbbb return bbbbb ccccc osinsert5 eeeee insert 5 eeeee return osinsert4 ddddd insert 4 ddddd return ddddd eeeee concatent chunk return aaaaa bbbbb ccccc ddddd eeeee aaaaa bbbbb ccccc ddddd eeeee result order order constraint 1 n 1000 1 id n valuelength 5 valu consist lowercas letter call insert uniqu id exactli n call made insert designanorderedstream
given head singli linkedlist list repres l0 → l1 → … → ln 1 → ln reorder list follow form l0 → ln → l1 → ln 1 → l2 → ln 2 → … may modifi valu list node node may chang exampl 1 input head 1234 output 1423 exampl 2 input head 12345 output 15243 constraint number node list rang 1 5 104 1 nodev 1000 reorderlist
integ array num sort ascend order distinct valu prior pass function num possibl rotat unknown pivot index k 1 k numslength result array numsk numsk1 numsn1 nums0 nums1 numsk1 0index exampl 0124567 might rotat pivot index 3 becom 4567012 given array num possibl rotat integ target return index target num 1 num must write algorithm olog n runtim complex exampl 1 input num 4567012 target 0 output 4 exampl 2 input num 4567012 target 3 output 1 exampl 3 input num 1 target 0 output 1 constraint 1 numslength 5000 104 numsi 104 valu num uniqu num ascend array possibl rotat 104 target 104 searchinrotatedsortedarray
given root binari tree return number node valu node equal averag valu subtre note averag n element sum n element divid n round nearest integ subtre root tree consist root descend exampl 1 input root 48501null6 output 5 explan node valu 4 averag subtre 4 8 5 0 1 6 6 24 6 4 node valu 5 averag subtre 5 6 2 11 2 5 node valu 0 averag subtre 0 1 0 node valu 1 averag subtre 1 1 1 node valu 6 averag subtre 6 1 6 exampl 2 input root 1 output 1 explan node valu 1 averag subtre 1 1 1 constraint number node tree rang 1 1000 0 nodev 1000 countnodesequaltoaverageofsubtre
given x n matrix maze 0index empti cell repres wall repres also given entranc maze entranc entrancerow entrancecol denot row column cell initi stand one step move one cell left right step cell wall step outsid maze goal find nearest exit entranc exit defin empti cell border maze entranc count exit return number step shortest path entranc nearest exit 1 path exist exampl 1 input maze entranc 12 output 1 explan 3 exit maze 10 02 23 initi entranc cell 12 reach 10 move 2 step left reach 02 move 1 step imposs reach 23 entranc thu nearest exit 02 1 step away exampl 2 input maze entranc 10 output 2 explan 1 exit maze 12 10 count exit sinc entranc cell initi entranc cell 10 reach 12 move 2 step right thu nearest exit 12 2 step away exampl 3 input maze entranc 00 output 1 explan exit maze constraint mazelength mazeilength n 1 n 100 mazeij either entrancelength 2 0 entrancerow 0 entrancecol n entranc alway empti cell nearestexitfromentranceinmaz
n ga station along circular rout amount ga ith station gasi car unlimit ga tank cost costi ga travel ith station next 1th station begin journey empti tank one ga station given two integ array ga cost return start ga station index travel around circuit clockwis direct otherwis return 1 exist solut guarante uniqu exampl 1 input ga 12345 cost 34512 output 3 explan start station 3 index 3 fill 4 unit ga tank 0 4 4 travel station 4 tank 4 1 5 8 travel station 0 tank 8 2 1 7 travel station 1 tank 7 3 2 6 travel station 2 tank 6 4 3 5 travel station 3 cost 5 ga enough travel back station 3 therefor return 3 start index exampl 2 input ga 234 cost 343 output 1 explan cant start station 0 1 enough ga travel next station let start station 2 fill 4 unit ga tank 0 4 4 travel station 0 tank 4 3 2 3 travel station 1 tank 3 3 3 3 travel back station 2 requir 4 unit ga 3 therefor cant travel around circuit matter start constraint n gaslength costlength 1 n 105 0 gasi costi 104 gasstat
sentenc list word separ singl space lead trail space exampl hello world hello hello world hello world sentenc word consist uppercas lowercas english letter two sentenc sentence1 sentence2 similar possibl insert arbitrari sentenc possibl empti insid one sentenc two sentenc becom equal exampl sentence1 hello name jane sentence2 hello jane made equal insert name hello jane sentence2 given two sentenc sentence1 sentence2 return true sentence1 sentence2 similar otherwis return fals exampl 1 input sentence1 name haley sentence2 haley output true explan sentence2 turn sentence1 insert name haley exampl 2 input sentence1 sentence2 lot word output fals explan singl sentenc insert insid one sentenc make equal exampl 3 input sentence1 eat right sentence2 eat output true explan sentence2 turn sentence1 insert right end sentenc constraint 1 sentence1length sentence2length 100 sentence1 sentence2 consist lowercas uppercas english letter space word sentence1 sentence2 separ singl space sentencesimilarityiii
given two string word1 word2 want construct string merg follow way either word1 word2 nonempti choos one follow option word1 nonempti append first charact word1 merg delet word1 exampl word1 abc merg dv choos oper word1 bc merg dva word2 nonempti append first charact word2 merg delet word2 exampl word2 abc merg choos oper word2 bc merg return lexicograph largest merg construct string lexicograph larger string b length first posit b differ charact strictli larger correspond charact b exampl abcd lexicograph larger abcc first posit differ fourth charact greater c exampl 1 input word1 cabaa word2 bcaaa output cbcabaaaaa explan one way get lexicograph largest merg take word1 merg c word1 abaa word2 bcaaa take word2 merg cb word1 abaa word2 caaa take word2 merg cbc word1 abaa word2 aaa take word1 merg cbca word1 baa word2 aaa take word1 merg cbcab word1 aa word2 aaa append remain 5 word1 word2 end merg exampl 2 input word1 abcabc word2 abdcaba output abdcabcabcaba constraint 1 word1length word2length 3000 word1 word2 consist lowercas english letter largestmergeoftwostr
alic bob travel rome separ busi meet given 4 string arrivealic leavealic arrivebob leavebob alic citi date arrivealic leavealic inclus bob citi date arrivebob leavebob inclus 5charact string format mmdd correspond month day date return total number day alic bob rome togeth assum date occur calendar year leap year note number day per month repres 31 28 31 30 31 30 31 31 30 31 30 31 exampl 1 input arrivealic 0815 leavealic 0818 arrivebob 0816 leavebob 0819 output 3 explan alic rome august 15 august 18 bob rome august 16 august 19 rome togeth august 16th 17th 18th answer 3 exampl 2 input arrivealic 1001 leavealic 1031 arrivebob 1101 leavebob 1231 output 0 explan day alic bob rome togeth return 0 constraint date provid format mmdd alic bob arriv date earlier equal leav date given date valid date nonleap year countdaysspenttogeth
given unsort integ array num return smallest miss posit integ must implement algorithm run time use o1 auxiliari space exampl 1 input num 120 output 3 explan number rang 12 array exampl 2 input num 3411 output 2 explan 1 array 2 miss exampl 3 input num 7891112 output 1 explan smallest posit integ 1 miss constraint 1 numslength 105 231 numsi 231 1 firstmissingposit
given string array queri queriesi lefti righti ki may rearrang substr sleftirighti queri choos ki replac lowercas english letter substr possibl palindrom string oper result queri true otherwis result fals return boolean array answer answeri result ith queri queriesi note letter count individu replac exampl sleftirighti aaa ki 2 replac two letter also note queri modifi initi string exampl input abcda queri 330120031032041 output truefalsefalsetruetru explan queries0 substr palidrom queries1 substr bc palidrom queries2 substr abcd palidrom replac 1 charact queries3 substr abcd could chang abba palidrom also chang baab first rearrang bacd replac cd ab queries4 substr abcda could chang abcba palidrom exampl 2 input lyb queri 010221 output falsetru constraint 1 slength querieslength 105 0 lefti righti slength 0 ki slength consist lowercas english letter canmakepalindromefromsubstr
given two string start target length n string consist charact l r charact l r repres piec piec l move left blank space directli left piec r move right blank space directli right charact repres blank space occupi l r piec return true possibl obtain string target move piec string start number time otherwis return fals exampl 1 input start lrr target lrr output true explan obtain string target start follow move move first piec one step left start becom equal lrr move last piec one step right start becom equal lrr move second piec three step right start becom equal lrr sinc possibl get string target start return true exampl 2 input start rl target lr output fals explan r piec string start move one step right obtain rl piec move anymor imposs obtain string target start exampl 3 input start r target r output fals explan piec string start move right imposs obtain string target start constraint n startlength targetlength 1 n 105 start target consist charact l r movepiecestoobtainastr
given string express repres lisplik express return integ valu syntax express given follow express either integ let express add express mult express assign variabl express alway evalu singl integ integ could posit neg let express take form let v1 e1 v2 e2 vn en expr let alway string let one pair altern variabl express mean first variabl v1 assign valu express e1 second variabl v2 assign valu express e2 sequenti valu let express valu express expr add express take form add e1 e2 add alway string add alway two express e1 e2 result addit evalu e1 evalu e2 mult express take form mult e1 e2 mult alway string mult alway two express e1 e2 result multipl evalu e1 evalu e2 question use smaller subset variabl name variabl start lowercas letter zero lowercas letter digit addit conveni name add let mult protect never use variabl name final concept scope express variabl name evalu within context evalu innermost scope term parenthes check first valu variabl outer scope check sequenti guarante everi express legal pleas see exampl detail scope exampl 1 input express let x 2 mult x let x 3 4 add x output 14 explan express add x check valu variabl x check innermost scope outermost context variabl tri evalu sinc x 3 found first valu x 3 exampl 2 input express let x 3 x 2 x output 2 explan assign let statement process sequenti exampl 3 input express let x 1 2 x add x add x output 5 explan first add x evalu 3 assign x second add x evalu 32 5 constraint 1 expressionlength 2000 lead trail space express token separ singl space express answer intermedi calcul answer guarante fit 32bit integ express guarante legal evalu integ parselispexpress
integ n strictli palindrom everi base b 2 n 2 inclus string represent integ n base b palindrom given integ n return true n strictli palindrom fals otherwis string palindrom read forward backward exampl 1 input n 9 output fals explan base 2 9 1001 base 2 palindrom base 3 9 100 base 3 palindrom therefor 9 strictli palindrom return fals note base 4 5 6 7 n 9 also palindrom exampl 2 input n 4 output fals explan consid base 2 4 100 base 2 palindrom therefor return fals constraint 4 n 105 strictlypalindromicnumb
consid leav binari tree left right order valu leav form leaf valu sequenc exampl given tree leaf valu sequenc 6 7 4 9 8 two binari tree consid leafsimilar leaf valu sequenc return true two given tree head node root1 root2 leafsimilar exampl 1 input root1 3516298nullnull74 root2 3516742nullnullnullnullnullnull98 output true exampl 2 input root1 123 root2 132 output fals constraint number node tree rang 1 200 given tree valu rang 0 200 leafsimilartre
given integ array num 2n integ group integ n pair a1 b1 a2 b2 bn sum minai bi maxim return maxim sum exampl 1 input num 1432 output 4 explan possibl pair ignor order element 1 1 4 2 3 min1 4 min2 3 1 2 3 2 1 3 2 4 min1 3 min2 4 1 2 3 3 1 2 3 4 min1 2 min3 4 1 3 4 maximum possibl sum 4 exampl 2 input num 626512 output 9 explan optim pair 2 1 2 5 6 6 min2 1 min2 5 min6 6 1 2 6 9 constraint 1 n 104 numslength 2 n 104 numsi 104 arraypartit
given root binari search tree bst duplic return mode ie frequent occur element tree one mode return order assum bst defin follow left subtre node contain node key less equal node key right subtre node contain node key greater equal node key left right subtre must also binari search tree exampl 1 input root 1null22 output 2 exampl 2 input root 0 output 0 constraint number node tree rang 1 104 105 nodev 105 follow could without use extra space assum implicit stack space incur due recurs count findmodeinbinarysearchtre
given integ n integ start defin array num numsi start 2 0index n numslength return bitwis xor element num exampl 1 input n 5 start 0 output 8 explan array num equal 0 2 4 6 8 0 2 4 6 8 8 correspond bitwis xor oper exampl 2 input n 4 start 3 output 8 explan array num equal 3 5 7 9 3 5 7 9 8 constraint 1 n 1000 0 start 1000 n numslength xoroperationinanarray
biker go road trip road trip consist n 1 point differ altitud biker start trip point 0 altitud equal 0 given integ array gain length n gaini net gain altitud point 1 0 n return highest altitud point exampl 1 input gain 51507 output 1 explan altitud 054116 highest 1 exampl 2 input gain 4321432 output 0 explan altitud 047910631 highest 0 constraint n gainlength 1 n 100 100 gaini 100 findthehighestaltitud
given integ array num largest integ uniqu determin whether largest element array least twice much everi number array return index largest element return 1 otherwis exampl 1 input num 3610 output 1 explan 6 largest integ everi number array x 6 least twice big x index valu 6 1 return 1 exampl 2 input num 1234 output 1 explan 4 less twice valu 3 return 1 constraint 2 numslength 50 0 numsi 100 largest element num uniqu largestnumberatleasttwiceofoth
implement powx n calcul x rais power n ie xn exampl 1 input x 200000 n 10 output 102400000 exampl 2 input x 210000 n 3 output 926100 exampl 3 input x 200000 n 2 output 025000 explan 22 122 14 025 constraint 1000 x 1000 231 n 2311 n integ either x zero n 0 104 xn 104 powxn
dna sequenc compos seri nucleotid abbrevi c g exampl acgaattccg dna sequenc studi dna use identifi repeat sequenc within dna given string repres dna sequenc return 10letterlong sequenc substr occur dna molecul may return answer order exampl 1 input aaaaacccccaaaaaccccccaaaaagggttt output aaaaaccccccccccaaaaa exampl 2 input aaaaaaaaaaaaa output aaaaaaaaaa constraint 1 slength 105 si either c g repeateddnasequ
implement first first fifo queue use two stack implement queue support function normal queue push peek pop empti implement myqueu class void pushint x push element x back queue int pop remov element front queue return int peek return element front queue boolean empti return true queue empti fals otherwis note must use standard oper stack mean push top peekpop top size empti oper valid depend languag stack may support nativ may simul stack use list dequ doubleend queue long use stack standard oper exampl 1 input myqueu push push peek pop empti 1 2 output null null null 1 1 fals explan myqueu myqueu new myqueu myqueuepush1 queue 1 myqueuepush2 queue 1 2 leftmost front queue myqueuepeek return 1 myqueuepop return 1 queue 2 myqueueempti return fals constraint 1 x 9 100 call made push pop peek empti call pop peek valid followup implement queue oper amort o1 time complex word perform n oper take overal time even one oper may take longer implementqueueusingstack
given two n x n binari matric mat target return true possibl make mat equal target rotat mat 90degre increment fals otherwis exampl 1 input mat 0110 target 1001 output true explan rotat mat 90 degre clockwis make mat equal target exampl 2 input mat 0111 target 1001 output fals explan imposs make mat equal target rotat mat exampl 3 input mat 000010111 target 111010000 output true explan rotat mat 90 degre clockwis two time make mat equal target constraint n matlength targetlength n matilength targetilength 1 n 10 matij targetij either 0 1 determinewhethermatrixcanbeobtainedbyrot
given array digit digit return largest multipl three form concaten given digit order answer return empti string sinc answer may fit integ data type return answer string note return answer must contain unnecessari lead zero exampl 1 input digit 819 output 981 exampl 2 input digit 86710 output 8760 exampl 3 input digit 1 output constraint 1 digitslength 104 0 digitsi 9 largestmultipleofthre
given array point integ angl locat locat posx posi pointsi xi yi denot integr coordin xy plane initi face directli east posit move posit rotat word posx posi chang field view degre repres angl determin wide see given view direct let amount degre rotat counterclockwis field view inclus rang angl angle2 angle2 browser support video tag video format see set point point angl form point posit immedi east direct posit field view multipl point one coordin may point locat alway see point regardless rotat point obstruct vision point return maximum number point see exampl 1 input point 212233 angl 90 locat 11 output 3 explan shade region repres field view point made visibl field view includ 33 even though 22 front line sight exampl 2 input point 21223411 angl 90 locat 11 output 4 explan point made visibl field view includ one locat exampl 3 input point 1021 angl 13 locat 11 output 1 explan see one two point shown constraint 1 pointslength 105 pointsilength 2 locationlength 2 0 angl 360 0 posx posi xi yi 100 maximumnumberofvisiblepoint
three stone differ posit xaxi given three integ b c posit stone one move pick stone endpoint ie either lowest highest posit stone move unoccupi posit endpoint formal let say stone current posit x z x z pick stone either posit x posit z move stone integ posit k x k z k game end make move ie stone three consecut posit return integ array answer length 2 answer0 minimum number move play answer1 maximum number move play exampl 1 input 1 b 2 c 5 output 12 explan move stone 5 3 move stone 5 4 3 exampl 2 input 4 b 3 c 2 output 00 explan make move exampl 3 input 3 b 5 c 1 output 12 explan move stone 1 4 move stone 1 2 4 constraint 1 b c 100 b c differ valu movingstonesuntilconsecut
given array rectangl rectanglesi xi yi ai bi repres axisalign rectangl bottomleft point rectangl xi yi topright point ai bi return true rectangl togeth form exact cover rectangular region exampl 1 input rectangl 11333142324413242334 output true explan 5 rectangl togeth form exact cover rectangular region exampl 2 input rectangl 1123132431423244 output fals explan gap two rectangular region exampl 3 input rectangl 1133314213242244 output fals explan two rectangl overlap constraint 1 rectangleslength 2 104 rectanglesilength 4 105 xi yi ai bi 105 perfectrectangl
given 2d integ array queri queriesi queriesi ni ki find number differ way place posit integ array size ni product integ ki number way may larg answer ith queri number way modulo 109 7 return integ array answer answerlength querieslength answeri answer ith queri exampl 1 input queri 265173660 output 4150734910 explan queri independ 26 4 way fill array size 2 multipli 6 16 23 32 61 51 1 way fill array size 5 multipli 1 11111 73660 1050734917 way fill array size 73 multipli 660 1050734917 modulo 109 7 50734910 exampl 2 input queri 1122334455 output 123105 constraint 1 querieslength 104 1 ni ki 104 countwaystomakearraywithproduct
array squar sum everi pair adjac element perfect squar given integ array num return number permut num squar two permut perm1 perm2 differ index perm1i perm2i exampl 1 input num 1178 output 2 explan 1817 1781 valid permut exampl 2 input num 222 output 1 constraint 1 numslength 12 0 numsi 109 numberofsquarefularray
given integ columnnumb return correspond column titl appear excel sheet exampl 1 b 2 c 3 z 26 aa 27 ab 28 exampl 1 input columnnumb 1 output exampl 2 input columnnumb 28 output ab exampl 3 input columnnumb 701 output zy constraint 1 columnnumb 231 1 excelsheetcolumntitl
given n rectangl repres 0index 2d integ array rectangl rectanglesi widthi heighti denot width height ith rectangl two rectangl j j consid interchang widthtoheight ratio formal two rectangl interchang widthiheighti widthjheightj use decim divis integ divis return number pair interchang rectangl rectangl exampl 1 input rectangl 483610201530 output 6 explan follow interchang pair rectangl index 0index rectangl 0 rectangl 1 48 36 rectangl 0 rectangl 2 48 1020 rectangl 0 rectangl 3 48 1530 rectangl 1 rectangl 2 36 1020 rectangl 1 rectangl 3 36 1530 rectangl 2 rectangl 3 1020 1530 exampl 2 input rectangl 4578 output 0 explan interchang pair rectangl constraint n rectangleslength 1 n 105 rectanglesilength 2 1 widthi heighti 105 numberofpairsofinterchangeablerectangl
given two string find number way choos nonempti substr replac singl charact differ charact result substr substr word find number substr differ substr exactli one charact exampl underlin substr comput comput differ ea valid way return number substr satisfi condit substr contigu sequenc charact within string exampl 1 input aba baba output 6 explan follow pair substr differ exactli 1 charact aba baba aba baba aba baba aba baba aba baba aba baba underlin portion substr chosen exampl 2 input ab bb output 3 explan follow pair substr differ 1 charact ab bb ab bb ab bb underlin portion substr chosen constraint 1 slength tlength 100 consist lowercas english letter countsubstringsthatdifferbyonecharact
given 3 posit number b c return minimum flip requir bit b make b c bitwis oper flip oper consist chang singl bit 1 0 chang bit 0 1 binari represent exampl 1 input 2 b 6 c 5 output 3 explan flip 1 b 4 c 5 b c exampl 2 input 4 b 2 c 7 output 1 exampl 3 input 1 b 2 c 3 output 0 constraint 1 109 1 b 109 1 c 109 minimumflipstomakeaorbequaltoc
given string return size longest substr contain vowel even number time e u must appear even number time exampl 1 input eleetminicoworoep output 13 explan longest substr leetminicowor contain two vowel e zero vowel u exampl 2 input leetcodeisgreat output 5 explan longest substr leetc contain two es exampl 3 input bcbcbc output 6 explan case given string bcbcbc longest vowel e u appear zero time constraint 1 slength 5 x 105 contain lowercas english letter findthelongestsubstringcontainingvowelsinevencount
given undirect weight connect graph contain n node label 0 n 1 integ array edg edgesi ai bi wi indic edg node ai bi weight wi edg weight 1 wi 1 other posit weight wi 0 task modifi edg weight 1 assign posit integ valu rang 1 2 109 shortest distanc node sourc destin becom equal integ target multipl modif make shortest distanc sourc destin equal target consid correct return array contain edg even unmodifi one order possibl make shortest distanc sourc destin equal target empti array imposs note allow modifi weight edg initi posit weight exampl 1 input n 5 edg 411201031431 sourc 0 destin 1 target 5 output 411201033431 explan graph show possibl modif edg make distanc 0 1 equal 5 exampl 2 input n 3 edg 011025 sourc 0 destin 2 target 6 output explan graph contain initi edg possibl make distanc 0 2 equal 6 modifi edg weight 1 empti array return exampl 3 input n 4 edg 104123235031 sourc 0 destin 2 target 6 output 104123235031 explan graph show modifi graph shortest distanc 0 2 6 constraint 1 n 100 1 edgeslength n n 1 2 edgesilength 3 0 ai bi n wi 1 1 wi 107 ai bi 0 sourc destin n sourc destin 1 target 109 graph connect selfloop repeat edg modifygraphedgeweight
given array integ stone stonesi weight ith stone play game stone turn choos heaviest two stone smash togeth suppos heaviest two stone weight x x result smash x stone destroy x stone weight x destroy stone weight new weight x end game one stone left return weight last remain stone stone left return 0 exampl 1 input stone 274181 output 1 explan combin 7 8 get 1 array convert 24111 combin 2 4 get 2 array convert 2111 combin 2 1 get 1 array convert 111 combin 1 1 get 0 array convert 1 that valu last stone exampl 2 input stone 1 output 1 constraint 1 stoneslength 30 1 stonesi 1000 laststoneweight
given 0index integ array num return true made strictli increas remov exactli one element fals otherwis array alreadi strictli increas return true array num strictli increas numsi 1 numsi index 1 numslength exampl 1 input num 121057 output true explan remov 10 index 2 num becom 1257 1257 strictli increas return true exampl 2 input num 2312 output fals explan 312 result remov element index 0 212 result remov element index 1 232 result remov element index 2 231 result remov element index 3 result array strictli increas return fals exampl 3 input num 111 output fals explan result remov element 11 11 strictli increas return fals constraint 2 numslength 1000 1 numsi 1000 removeoneelementtomakethearraystrictlyincreas
given string lowercas letter need find maximum number nonempti substr meet follow condit substr overlap two substr sij sxi either j x true substr contain certain charact c must also contain occurr c find maximum number substr meet condit multipl solut number substr return one minimum total length shown exist uniqu solut minimum total length notic return substr order exampl 1 input adefaddaccc output efccc explan follow possibl substr meet condit adefaddaccc adefadda ef e f ccc choos first string choos anyth els wed get 1 choos adefadda left ccc one doesnt overlap thu obtain 2 substr notic also optim choos ef sinc split two therefor optim way choos efccc give us 3 substr solut number substr exist exampl 2 input abbaccd output dbbcc explan notic set substr dabbacc also length 3 consid incorrect sinc larger total length constraint 1 slength 105 contain lowercas english letter maximumnumberofnonoverlappingsubstr
given 0index 2d integ array question questionsi pointsi brainpoweri array describ question exam process question order ie start question 0 make decis whether solv skip question solv question earn pointsi point unabl solv next brainpoweri question skip question get make decis next question exampl given question 3 2 4 3 4 4 2 5 question 0 solv earn 3 point unabl solv question 1 2 instead question 0 skip question 1 solv earn 4 point unabl solv question 2 3 return maximum point earn exam exampl 1 input question 32434425 output 5 explan maximum point earn solv question 0 3 solv question 0 earn 3 point unabl solv next 2 question unabl solv question 1 2 solv question 3 earn 2 point total point earn 3 2 5 way earn 5 point exampl 2 input question 1122334455 output 7 explan maximum point earn solv question 1 4 skip question 0 solv question 1 earn 2 point unabl solv next 2 question unabl solv question 2 3 solv question 4 earn 5 point total point earn 2 5 7 way earn 7 point constraint 1 questionslength 105 questionsilength 2 1 pointsi brainpoweri 105 solvingquestionswithbrainpow
given integ array num posit integ k return competit subsequ num size k array subsequ result sequenc obtain eras possibl zero element array defin subsequ competit subsequ b length first posit b differ subsequ number less correspond number b exampl 134 competit 135 first posit differ final number 4 less 5 exampl 1 input num 3526 k 2 output 26 explan among set everi possibl subsequ 35 32 36 52 56 26 26 competit exampl 2 input num 24335496 k 4 output 2334 constraint 1 numslength 105 0 numsi 109 1 k numslength findthemostcompetitivesubsequ
html entiti parser parser take html code input replac entiti special charact charact special charact entiti html quotat mark entiti quot symbol charact singl quot mark entiti apo symbol charact ampersand entiti amp symbol charact greater sign entiti gt symbol charact less sign entiti lt symbol charact slash entiti frasl symbol charact given input text string html parser implement entiti parser return text replac entiti special charact exampl 1 input text amp html entiti ambassador output html entiti ambassador explan parser replac amp entiti exampl 2 input text quot quotquot output quot constraint 1 textlength 105 string may contain possibl charact 256 ascii charact htmlentitypars
n peopl line queu buy ticket 0th person front line n 1th person back line given 0index integ array ticket length n number ticket ith person would like buy ticketsi person take exactli 1 second buy ticket person buy 1 ticket time go back end line happen instantan order buy ticket person ticket left buy person leav line return time taken person posit k 0index finish buy ticket exampl 1 input ticket 232 k 2 output 6 explan first pass everyon line buy ticket line becom 1 2 1 second pass everyon line buy ticket line becom 0 1 0 person posit 2 success bought 2 ticket took 3 3 6 second exampl 2 input ticket 5111 k 0 output 8 explan first pass everyon line buy ticket line becom 4 0 0 0 next 4 pass person posit 0 buy ticket person posit 0 success bought 5 ticket took 4 1 1 1 1 8 second constraint n ticketslength 1 n 100 1 ticketsi 100 0 k n timeneededtobuyticket
given integ array num contain zero find largest posit integ k k also exist array return posit integ k integ return 1 exampl 1 input num 1233 output 3 explan 3 valid k find array exampl 2 input num 1106771 output 7 explan 1 7 correspond neg valu array 7 larger valu exampl 3 input num 1086723 output 1 explan singl valid k return 1 constraint 1 numslength 1000 1000 numsi 1000 numsi 0 largestpositiveintegerthatexistswithitsneg
keep score basebal game strang rule begin game start empti record given list string oper operationsi ith oper must appli record one follow integ x record new score x record new score sum previou two score record new score doubl previou score c invalid previou score remov record return sum score record appli oper test case gener answer intermedi calcul fit 32bit integ oper valid exampl 1 input op 52cd output 30 explan 5 add 5 record record 5 2 add 2 record record 5 2 c invalid remov previou score record 5 add 2 5 10 record record 5 10 add 5 10 15 record record 5 10 15 total sum 5 10 15 30 exampl 2 input op 524cd9 output 27 explan 5 add 5 record record 5 2 add 2 record record 5 2 4 add 4 record record 5 2 4 c invalid remov previou score record 5 2 add 2 2 4 record record 5 2 4 9 add 9 record record 5 2 4 9 add 4 9 5 record record 5 2 4 9 5 add 9 5 14 record record 5 2 4 9 5 14 total sum 5 2 4 9 5 14 27 exampl 3 input op 1c output 0 explan 1 add 1 record record 1 c invalid remov previou score record sinc record empti total sum 0 constraint 1 operationslength 1000 operationsi c string repres integ rang 3 104 3 104 oper alway least two previou score record oper c alway least one previou score record baseballgam
given integ array arr integ target return number tupl j k j k arri arrj arrk target answer larg return modulo 109 7 exampl 1 input arr 1122334455 target 8 output 20 explan enumer valu arri arrj arrk 1 2 5 occur 8 time 1 3 4 occur 8 time 2 2 4 occur 2 time 2 3 3 occur 2 time exampl 2 input arr 112222 target 5 output 12 explan arri 1 arrj arrk 2 occur 12 time choos one 1 11 2 way two 2s 2222 6 way exampl 3 input arr 213 target 6 output 1 explan 1 2 3 occur one time array return 1 constraint 3 arrlength 3000 0 arri 100 0 target 300 3sumwithmultipl
given n balloon index 0 n 1 balloon paint number repres array num ask burst balloon burst ith balloon get numsi 1 numsi numsi 1 coin 1 1 goe bound array treat balloon 1 paint return maximum coin collect burst balloon wise exampl 1 input num 3158 output 167 explan num 3158 358 38 8 coin 315 358 138 181 167 exampl 2 input num 15 output 10 constraint n numslength 1 n 300 0 numsi 100 burstballoon
given two integ array arr1 arr2 integ return distanc valu two array distanc valu defin number element arr1i element arr2j arr1iarr2j exampl 1 input arr1 458 arr2 10918 2 output 2 explan arr104 4106 d2 495 d2 413 d2 484 d2 arr115 5105 d2 594 d2 514 d2 583 d2 arr128 8102 d2 891 d2 817 d2 880 d2 exampl 2 input arr1 1423 arr2 436102030 3 output 2 exampl 3 input arr1 211003 arr2 521037 6 output 1 constraint 1 arr1length arr2length 500 1000 arr1i arr2j 1000 0 100 findthedistancevaluebetweentwoarray
given text file filetxt contain list phone number one per line write onelin bash script print valid phone number may assum valid phone number must appear one follow two format xxx xxxxxxx xxxxxxxxxx x mean digit may also assum line text file must contain lead trail white space exampl assum filetxt follow content 9871234567 123 456 7890 123 4567890 script output follow valid phone number 9871234567 123 4567890 validphonenumb
balanc string equal quantiti l r charact given balanc string split number substr substr balanc return maximum number balanc string obtain exampl 1 input rlrrllrlrl output 4 explan split rl rrll rl rl substr contain number l r exampl 2 input rlrrrllrll output 2 explan split rl rrrllrll substr contain number l r note split rl rr rl lr 2nd 5th substr balanc exampl 3 input llllrrrr output 1 explan split llllrrrr constraint 2 slength 1000 si either l r balanc string splitastringinbalancedstr
given array nonneg integ arr initi posit start index array index jump arri arri check reach index valu 0 notic jump outsid array time exampl 1 input arr 4230312 start 5 output true explan possibl way reach index 3 valu 0 index 5 index 4 index 1 index 3 index 5 index 6 index 4 index 1 index 3 exampl 2 input arr 4230312 start 0 output true explan one possibl way reach index 3 valu 0 index 0 index 4 index 1 index 3 exampl 3 input arr 30212 start 2 output fals explan way reach index 1 valu 0 constraint 1 arrlength 5 104 0 arri arrlength 0 start arrlength jumpgameiii
given integ array num return maximum result numsi xor numsj 0 j n exampl 1 input num 31052528 output 28 explan maximum result 5 xor 25 28 exampl 2 input num 147053834991368092516670 output 127 constraint 1 numslength 2 105 0 numsi 231 1 maximumxoroftwonumbersinanarray
given posit integ milli write asynchron function sleep milli millisecond resolv valu exampl 1 input milli 100 output 100 explan return promis resolv 100m let datenow sleep100then consolelogdatenow 100 exampl 2 input milli 200 output 200 explan return promis resolv 200m constraint 1 milli 1000 sleep
given 0index integ array num determin whether exist two subarray length 2 equal sum note two subarray must begin differ indic return true subarray exist fals otherwis subarray contigu nonempti sequenc element within array exampl 1 input num 424 output true explan subarray element 42 24 sum 6 exampl 2 input num 12345 output fals explan two subarray size 2 sum exampl 3 input num 000 output true explan subarray nums0nums1 nums1nums2 sum 0 note even though subarray content two subarray consid differ differ posit origin array constraint 2 numslength 1000 109 numsi 109 findsubarrayswithequalsum
selfdivid number number divis everi digit contain exampl 128 selfdivid number 128 1 0 128 2 0 128 8 0 selfdivid number allow contain digit zero given two integ left right return list selfdivid number rang left right exampl 1 input left 1 right 22 output 12345678911121522 exampl 2 input left 47 right 85 output 48556677 constraint 1 left right 104 selfdividingnumb
given array integ num return number good pair pair j call good numsi numsj j exampl 1 input num 123113 output 4 explan 4 good pair 03 04 34 25 0index exampl 2 input num 1111 output 6 explan pair array good exampl 3 input num 123 output 0 constraint 1 numslength 100 1 numsi 100 numberofgoodpair
given integ k return minimum number fibonacci number whose sum equal k fibonacci number use multipl time fibonacci number defin f1 1 f2 1 fn fn1 fn2 n 2 guarante given constraint alway find fibonacci number sum k exampl 1 input k 7 output 2 explan fibonacci number 1 1 2 3 5 8 13 k 7 use 2 5 7 exampl 2 input k 10 output 2 explan k 10 use 2 8 10 exampl 3 input k 19 output 3 explan k 19 use 1 5 13 19 constraint 1 k 109 findtheminimumnumberoffibonaccinumberswhosesumisk
given array coordin coordinatesi x x repres coordin point check point make straight line xy plane exampl 1 input coordin 122334455667 output true exampl 2 input coordin 112234455677 output fals constraint 2 coordinateslength 1000 coordinatesilength 2 104 coordinatesi0 coordinatesi1 104 coordin contain duplic point checkifitisastraightlin
given array integ arr initi posit first index array one step jump index index 1 1 arrlength 1 1 0 j arri arrj j return minimum number step reach last index array notic jump outsid array time exampl 1 input arr 10023234041002323233404 output 3 explan need three jump index 0 4 3 9 note index 9 last index array exampl 2 input arr 7 output 0 explan start index last index need jump exampl 3 input arr 76969697 output 1 explan jump directli index 0 index 7 last index array constraint 1 arrlength 5 104 108 arri 108 jumpgameiv
onedimension garden xaxi garden start point 0 end point n ie length garden n n 1 tap locat point 0 1 n garden given integ n integ array rang length n 1 rangesi 0index mean ith tap water area rangesi rangesi open return minimum number tap open water whole garden garden water return 1 exampl 1 input n 5 rang 341100 output 1 explan tap point 0 cover interv 33 tap point 1 cover interv 35 tap point 2 cover interv 13 tap point 3 cover interv 24 tap point 4 cover interv 44 tap point 5 cover interv 55 open second tap water whole garden 05 exampl 2 input n 3 rang 0000 output 1 explan even activ four tap water whole garden constraint 1 n 104 rangeslength n 1 0 rangesi 100 minimumnumberoftapstoopentowateragarden
given string return number segment string segment defin contigu sequenc nonspac charact exampl 1 input hello name john output 5 explan five segment hello name john exampl 2 input hello output 1 constraint 0 slength 300 consist lowercas uppercas english letter digit one follow charact space charact numberofsegmentsinastr
given function fn time millisecond return debounc version function debounc function function whose execut delay millisecond whose execut cancel call within window time debounc function also receiv pass paramet exampl let say 50m function call 30m 60m 100m first 2 function call would cancel 3rd function call would execut 150m instead 35m 1st call would cancel 2nd would execut 95m 3rd would execut 135m diagram show debounc transform event rectangl repres 100m debounc time 400m color repres differ set input pleas solv without use lodash debounc function exampl 1 input 50 call 50 input 1 75 input 2 output 125 input 2 explan let start datenow function loginput consolelogdatenow start input const dlog debouncelog 50 settimeout dlog1 50 settimeout dlog2 75 1st call cancel 2nd call 2nd call occur 100m 2nd call delay 50m execut 125m input 2 exampl 2 input 20 call 50 input 1 100 input 2 output 70 input 1 120 input 2 explan 1st call delay 70m input 1 2nd call delay 120m input 2 exampl 3 input 150 call 50 input 1 2 300 input 3 4 300 input 5 6 output 200 input 12 450 input 5 6 explan 1st call delay 150m ran 200m input 1 2 2nd call cancel 3rd call 3rd call delay 150m ran 450m input 5 6 constraint 0 1000 1 callslength 10 0 callsit 1000 0 callsiinputslength 10 debounc
given 0index integ array num even length consist equal number posit neg integ rearrang element num modifi array follow given condit everi consecut pair integ opposit sign integ sign order present num preserv rearrang array begin posit integ return modifi array rearrang element satisfi aforement condit exampl 1 input num 312524 output 321524 explan posit integ num 312 neg integ 254 possibl way rearrang satisfi condit 321524 way 122534 312254 235142 incorrect satisfi one condit exampl 2 input num 11 output 11 explan 1 posit integ 1 neg integ num num rearrang 11 constraint 2 numslength 2 105 numslength even 1 numsi 105 num consist equal number posit neg integ rearrangearrayelementsbysign
n peopl stand queue number 0 n 1 left right order given array height distinct integ heightsi repres height ith person person see anoth person right queue everybodi shorter formal ith person see jth person j minheightsi heightsj maxheightsi1 heightsi2 heightsj1 return array answer length n answeri number peopl ith person see right queue exampl 1 input height 10685119 output 312110 explan person 0 see person 1 2 4 person 1 see person 2 person 2 see person 3 4 person 3 see person 4 person 4 see person 5 person 5 see one sinc nobodi right exampl 2 input height 512310 output 41110 constraint n heightslength 1 n 105 1 heightsi 105 valu height uniqu numberofvisiblepeopleinaqueu
given collect candid number candid target number target find uniqu combin candid candid number sum target number candid may use combin note solut set must contain duplic combin exampl 1 input candid 10127615 target 8 output 116 125 17 26 exampl 2 input candid 25212 target 5 output 122 5 constraint 1 candidateslength 100 1 candidatesi 50 1 target 30 combinationsumii
given 0index integ array num find leftmost middleindex ie smallest amongst possibl one middleindex index nums0 nums1 numsmiddleindex1 numsmiddleindex1 numsmiddleindex2 numsnumslength1 middleindex 0 left side sum consid 0 similarli middleindex numslength 1 right side sum consid 0 return leftmost middleindex satisfi condit 1 index exampl 1 input num 23184 output 3 explan sum number index 3 2 3 1 4 sum number index 3 4 4 exampl 2 input num 114 output 2 explan sum number index 2 1 1 0 sum number index 2 0 exampl 3 input num 25 output 1 explan valid middleindex constraint 1 numslength 100 1000 numsi 1000 note question 724 httpsleetcodecomproblemsfindpivotindex findthemiddleindexinarray
given integ n return true possibl repres n sum distinct power three otherwis return fals integ power three exist integ x 3x exampl 1 input n 12 output true explan 12 31 32 exampl 2 input n 91 output true explan 91 30 32 34 exampl 3 input n 21 output fals constraint 1 n 107 checkifnumberisasumofpowersofthre
stack block form pyramid block color repres singl letter row block contain one less block row beneath center top make pyramid aesthet pleas specif triangular pattern allow triangular pattern consist singl block stack top two block pattern given list threelett string allow first two charact pattern repres left right bottom block respect third charact top block exampl abc repres triangular pattern c block stack top left b right block note differ bac b left bottom right bottom start bottom row block bottom given singl string must use base pyramid given bottom allow return true build pyramid way top everi triangular pattern pyramid allow fals otherwis exampl 1 input bottom bcd allow bcccdeceafff output true explan allow triangular pattern shown right start bottom level 3 build ce level 2 build level 1 three triangular pattern pyramid bcc cde cea allow exampl 2 input bottom aaaa allow aabaacbcdbbedef output fals explan allow triangular pattern shown right start bottom level 4 multipl way build level 3 tri possibilit get alway stuck build level 1 constraint 2 bottomlength 6 0 allowedlength 216 allowedilength 3 letter input string set b c e f valu allow uniqu pyramidtransitionmatrix
given array integ arr replac element rank rank repres larg element rank follow rule rank integ start 1 larger element larger rank two element equal rank must rank small possibl exampl 1 input arr 40102030 output 4123 explan 40 largest element 10 smallest 20 second smallest 30 third smallest exampl 2 input arr 100100100 output 111 explan element share rank exampl 3 input arr 37122891005680512 output 534286713 constraint 0 arrlength 105 109 arri 109 ranktransformofanarray
given integ array deck deck card everi card uniqu integ integ ith card decki order deck order want initi card start face unrev one deck follow step repeatedli card reveal take top card deck reveal take deck still card deck put next top card deck bottom deck still unrev card go back step 1 otherwis stop return order deck would reveal card increas order note first entri answer consid top deck exampl 1 input deck 1713112357 output 2133115177 explan get deck order 1713112357 order matter reorder reorder deck start 2133115177 2 top deck reveal 2 move 13 bottom deck 311517713 reveal 3 move 11 bottom deck 51771311 reveal 5 move 17 bottom deck 7131117 reveal 7 move 13 bottom deck 111713 reveal 11 move 17 bottom deck 1317 reveal 13 move 17 bottom deck 17 reveal 17 sinc card reveal increas order answer correct exampl 2 input deck 11000 output 11000 constraint 1 decklength 1000 1 decki 106 valu deck uniqu revealcardsinincreasingord
given integ array size n find element appear ⌊ n3 ⌋ time exampl 1 input num 323 output 3 exampl 2 input num 1 output 1 exampl 3 input num 12 output 12 constraint 1 numslength 5 104 109 numsi 109 follow could solv problem linear time o1 space majorityelementii
given string s1 s2 size n string evil return number good string good string size n alphabet greater equal s1 alphabet smaller equal s2 contain string evil substr sinc answer huge number return modulo 109 7 exampl 1 input n 2 s1 aa s2 da evil b output 51 explan 25 good string start aaacadaz 25 good string start c cacccdcz final one good string start da exampl 2 input n 8 s1 leetcod s2 leetgo evil leet output 0 explan string greater equal s1 smaller equal s2 start prefix leet therefor good string exampl 3 input n 2 s1 gx s2 gz evil x output 2 constraint s1length n s2length n s1 s2 1 n 500 1 evillength 50 string consist lowercas english letter findallgoodstr
given root node binari search tree bst valu insert tree return root node bst insert guarante new valu exist origin bst notic may exist multipl valid way insert long tree remain bst insert return exampl 1 input root 42713 val 5 output 427135 explan anoth accept tree exampl 2 input root 40206010305070 val 25 output 40206010305070nullnull25 exampl 3 input root 42713nullnullnullnullnullnul val 5 output 427135 constraint number node tree rang 0 104 108 nodev 108 valu nodev uniqu 108 val 108 guarante val exist origin bst insertintoabinarysearchtre
given four integ n introvertscount extrovertscount x n grid two type peopl introvert extrovert introvertscount introvert extrovertscount extrovert decid mani peopl want live grid assign one grid cell note peopl live grid happi person calcul follow introvert start 120 happi lose 30 happi neighbor introvert extrovert extrovert start 40 happi gain 20 happi neighbor introvert extrovert neighbor live directli adjac cell north east south west person cell grid happi sum person happi return maximum possibl grid happi exampl 1 input 2 n 3 introvertscount 1 extrovertscount 2 output 240 explan assum grid 1index coordin row column put introvert cell 11 put extrovert cell 13 23 introvert 11 happi 120 start happi 0 30 0 neighbor 120 extrovert 13 happi 40 start happi 1 20 1 neighbor 60 extrovert 23 happi 40 start happi 1 20 1 neighbor 60 grid happi 120 60 60 240 figur show grid exampl person happi introvert stay light green cell extrovert live light purpl cell exampl 2 input 3 n 1 introvertscount 2 extrovertscount 1 output 260 explan place two introvert 11 31 extrovert 21 introvert 11 happi 120 start happi 1 30 1 neighbor 90 extrovert 21 happi 40 start happi 2 20 2 neighbor 80 introvert 31 happi 120 start happi 1 30 1 neighbor 90 grid happi 90 80 90 260 exampl 3 input 2 n 2 introvertscount 4 extrovertscount 0 output 240 constraint 1 n 5 0 introvertscount extrovertscount minm n 6 maximizegridhappi
video game fallout 4 quest road freedom requir player reach metal dial call freedom trail ring use dial spell specif keyword open door given string ring repres code engrav outer ring anoth string key repres keyword need spell return minimum number step spell charact keyword initi first charact ring align 1200 direct spell charact key one one rotat ring clockwis anticlockwis make charact string key align 1200 direct press center button stage rotat ring spell key charact keyi rotat ring clockwis anticlockwis one place count one step final purpos rotat align one ring charact 1200 direct charact must equal keyi charact keyi align 1200 direct press center button spell also count one step press could begin spell next charact key next stage otherwis finish spell exampl 1 input ring god key gd output 4 explan first key charact g sinc alreadi place need 1 step spell charact second key charact need rotat ring god anticlockwis two step make becom ddinggo also need 1 step spell final output 4 exampl 2 input ring god key god output 13 constraint 1 ringlength keylength 100 ring key consist lower case english letter guarante key could alway spell rotat ring freedomtrail
given binari string posit integ k return length longest subsequ make binari number less equal k note subsequ contain lead zero empti string consid equal 0 subsequ string deriv anoth string delet charact without chang order remain charact exampl 1 input 1001010 k 5 output 5 explan longest subsequ make binari number less equal 5 00010 number equal 2 decim note 00100 00101 also possibl equal 4 5 decim respect length subsequ 5 5 return exampl 2 input 00101001 k 1 output 6 explan 000001 longest subsequ make binari number less equal 1 number equal 1 decim length subsequ 6 6 return constraint 1 slength 1000 si either 0 1 1 k 109 longestbinarysubsequencelessthanorequaltok
design class find kth largest element stream note kth largest element sort order kth distinct element implement kthlargest class kthlargestint k int num initi object integ k stream integ num int addint val append integ val stream return element repres kth largest element stream exampl 1 input kthlargest add add add add add 3 4 5 8 2 3 5 10 9 4 output null 4 5 5 8 8 explan kthlargest kthlargest new kthlargest3 4 5 8 2 kthlargestadd3 return 4 kthlargestadd5 return 5 kthlargestadd10 return 5 kthlargestadd9 return 8 kthlargestadd4 return 8 constraint 1 k 104 0 numslength 104 104 numsi 104 104 val 104 104 call made add guarante least k element array search kth element kthlargestelementinastream
play game contain multipl charact charact two main properti attack defens given 2d integ array properti propertiesi attacki defensei repres properti ith charact game charact said weak charact attack defens level strictli greater charact attack defens level formal charact said weak exist anoth charact j attackj attacki defensej defensei return number weak charact exampl 1 input properti 556336 output 0 explan charact strictli greater attack defens exampl 2 input properti 2233 output 1 explan first charact weak second charact strictli greater attack defens exampl 3 input properti 1510443 output 1 explan third charact weak second charact strictli greater attack defens constraint 2 propertieslength 105 propertiesilength 2 1 attacki defensei 105 thenumberofweakcharactersinthegam
string partit group size k use follow procedur first group consist first k charact string second group consist next k charact string charact part exactli one group last group string k charact remain charact fill use complet group note partit done remov fill charact last group exist concaten group order result string given string size group k charact fill return string array denot composit everi group divid use procedur exampl 1 input abcdefghi k 3 fill x output abcdefghi explan first 3 charact abc form first group next 3 charact def form second group last 3 charact ghi form third group sinc group complet fill charact string need use fill thu group form abc def ghi exampl 2 input abcdefghij k 3 fill x output abcdefghijxx explan similar previou exampl form first three group abc def ghi last group use charact j string complet group add x twice thu 4 group form abc def ghi jxx constraint 1 slength 100 consist lowercas english letter 1 k 100 fill lowercas english letter divideastringintogroupsofsizek
given two integ n repres height width rectangular piec wood also given 2d integ array price pricesi hi wi pricei indic sell rectangular piec wood height hi width wi pricei dollar cut piec wood must make vertic horizont cut across entir height width piec split two smaller piec cut piec wood number smaller piec sell piec accord price may sell multipl piec shape sell shape grain wood make differ rotat piec swap height width return maximum money earn cut x n piec wood note cut piec wood mani time want exampl 1 input 3 n 5 price 142227213 output 19 explan diagram show possibl scenario consist 2 piec wood shape 2 x 2 sell price 2 7 14 1 piec wood shape 2 x 1 sell price 1 3 3 1 piec wood shape 1 x 4 sell price 1 2 2 obtain total 14 3 2 19 money earn shown 19 maximum amount money earn exampl 2 input 4 n 6 price 3210142413 output 32 explan diagram show possibl scenario consist 3 piec wood shape 3 x 2 sell price 3 10 30 1 piec wood shape 1 x 4 sell price 1 2 2 obtain total 30 2 32 money earn shown 32 maximum amount money earn notic rotat 1 x 4 piec wood obtain 4 x 1 piec wood constraint 1 n 200 1 priceslength 2 104 pricesilength 3 1 hi 1 wi n 1 pricei 106 shape wood hi wi pairwis distinct sellingpiecesofwood
sql schema tabl tree column name type id int pid int id primari key column tabl row tabl contain inform id node id parent node tree given structur alway valid tree node tree one three type leaf node leaf node root node root tree inner node neither leaf node root node write sql queri report type node tree return result tabl order queri result format follow exampl exampl 1 input tree tabl id pid 1 null 2 1 3 1 4 2 5 2 output id type 1 root 2 inner 3 leaf 4 leaf 5 leaf explan node 1 root node parent node null child node 2 3 node 2 inner node parent node 1 child node 4 5 node 3 4 5 leaf node parent node child node exampl 2 input tree tabl id pid 1 null output id type 1 root explan one node tree need output root attribut treenod
given two 0index array string startword targetword string consist lowercas english letter string targetword check possibl choos string startword perform convers oper equal targetword convers oper describ follow two step append lowercas letter present string end exampl string abc letter e ad ad result string abcd rearrang letter new string arbitrari order exampl abcd rearrang acbd bacd cbda note also rearrang abcd return number string targetword obtain perform oper string startword note verifi string targetword obtain string startword perform oper string startword actual chang process exampl 1 input startword antacttack targetword tackactacti output 2 explan order form targetwords0 tack use startwords1 act append k rearrang actk tack string startword use obtain targetwords1 act note act exist startword must append one letter string rearrang order form targetwords2 acti use startwords1 act append rearrang acti acti exampl 2 input startword aba targetword abcabcd output 1 explan order form targetwords0 abc use startwords0 ab add c rearrang abc string startword use obtain targetwords1 abcd constraint 1 startwordslength targetwordslength 5 104 1 startwordsilength targetwordsjlength 26 string startword targetword consist lowercas english letter letter occur string startword targetword countwordsobtainedafteraddingalett
given x n matrix return new matrix answer answerrowcol rank matrixrowcol rank integ repres larg element compar element calcul use follow rule rank integ start 1 two element p q row column p q rankp rankq p q rankp rankq p q rankp rankq rank small possibl test case gener answer uniqu given rule exampl 1 input matrix 1234 output 1223 explan rank matrix00 1 smallest integ row column rank matrix01 2 matrix01 matrix00 matrix00 rank 1 rank matrix10 2 matrix10 matrix00 matrix00 rank 1 rank matrix11 3 matrix11 matrix01 matrix11 matrix10 matrix01 matrix10 rank 2 exampl 2 input matrix 7777 output 1111 exampl 3 input matrix 2021141941922472419419 output 423134516134 constraint matrixlength n matrixilength 1 n 500 109 matrixrowcol 109 ranktransformofamatrix
given x n integ matrix grid n even integ integ k matrix compos sever layer shown imag color layer cyclic rotat matrix done cyclic rotat layer matrix cyclic rotat layer element layer take place adjac element counterclockwis direct exampl rotat shown return matrix appli k cyclic rotat exampl 1 input grid 40103020 k 1 output 10204030 explan figur repres grid everi state exampl 2 input grid 12345678910111213141516 k 2 output 34812211101617615591314 explan figur repres grid everi state constraint gridlength n gridilength 2 n 50 n even integ 1 gridij 5000 1 k 109 cyclicallyrotatingagrid
given root binari tree valu target node target integ k return array valu node distanc k target node return answer order exampl 1 input root 3516208nullnull74 target 5 k 2 output 741 explan node distanc 2 target node valu 5 valu 7 4 1 exampl 2 input root 1 target 1 k 3 output constraint number node tree rang 1 500 0 nodev 500 valu nodev uniqu target valu one node tree 0 k 1000 allnodesdistancekinbinarytre
given integ array num sort nondecreas order remov duplic inplac uniqu element appear rel order element kept return number uniqu element num consid number uniqu element num k get accept need follow thing chang array num first k element num contain uniqu element order present num initi remain element num import well size num return k custom judg judg test solut follow code int num input array int expectednum expect answer correct length int k removeduplicatesnum call implement assert k expectednumslength int 0 k assert numsi expectednumsi assert pass solut accept exampl 1 input num 112 output 2 num 12 explan function return k 2 first two element num 1 2 respect matter leav beyond return k henc underscor exampl 2 input num 0011122334 output 5 num 01234 explan function return k 5 first five element num 0 1 2 3 4 respect matter leav beyond return k henc underscor constraint 1 numslength 3 104 100 numsi 100 num sort nondecreas order removeduplicatesfromsortedarray
power string maximum length nonempti substr contain one uniqu charact given string return power exampl 1 input leetcod output 2 explan substr ee length 2 charact e exampl 2 input abbcccddddeeeeedcba output 5 explan substr eeeee length 5 charact e constraint 1 slength 500 consist lowercas english letter consecutivecharact
given integ array num return third distinct maximum number array third maximum exist return maximum number exampl 1 input num 321 output 1 explan first distinct maximum 3 second distinct maximum 2 third distinct maximum 1 exampl 2 input num 12 output 2 explan first distinct maximum 2 second distinct maximum 1 third distinct maximum exist maximum 2 return instead exampl 3 input num 2231 output 1 explan first distinct maximum 3 second distinct maximum 2 2s count togeth sinc valu third distinct maximum 1 constraint 1 numslength 104 231 numsi 231 1 follow find solut thirdmaximumnumb
given n task label 0 n 1 repres 2d integ array task tasksi enqueuetimei processingtimei mean ith task avail process enqueuetimei take processingtimei finish process singlethread cpu process one task time act follow way cpu idl avail task process cpu remain idl cpu idl avail task cpu choos one shortest process time multipl task shortest process time choos task smallest index task start cpu process entir task without stop cpu finish task start new one instantli return order cpu process task exampl 1 input task 12243241 output 0231 explan event go follow time 1 task 0 avail process avail task 0 also time 1 idl cpu start process task 0 avail task time 2 task 1 avail process avail task 1 time 3 task 2 avail process avail task 1 2 also time 3 cpu finish task 0 start process task 2 shortest avail task 1 time 4 task 3 avail process avail task 1 3 time 5 cpu finish task 2 start process task 3 shortest avail task 1 time 6 cpu finish task 3 start process task 1 avail task time 10 cpu finish task 1 becom idl exampl 2 input task 710712757472 output 43201 explan event go follow time 7 task becom avail avail task 01234 also time 7 idl cpu start process task 4 avail task 0123 time 9 cpu finish task 4 start process task 3 avail task 012 time 13 cpu finish task 3 start process task 2 avail task 01 time 18 cpu finish task 2 start process task 0 avail task 1 time 28 cpu finish task 0 start process task 1 avail task time 40 cpu finish task 1 becom idl constraint taskslength n 1 n 105 1 enqueuetimei processingtimei 109 singlethreadedcpu
array arr mountain follow properti hold arrlength 3 exist 0 arrlength 1 arr0 arr1 arri 1 arri arri arri 1 arrarrlength 1 given mountain array arr return index arr0 arr1 arri 1 arri arri 1 arrarrlength 1 must solv ologarrlength time complex exampl 1 input arr 010 output 1 exampl 2 input arr 0210 output 1 exampl 3 input arr 01052 output 1 constraint 3 arrlength 105 0 arri 106 arr guarante mountain array peakindexinamountainarray
two type tile 2 x 1 domino shape tromino shape may rotat shape given integ n return number way tile 2 x n board sinc answer may larg return modulo 109 7 tile everi squar must cover tile two tile differ two 4direct adjac cell board exactli one tile squar occupi tile exampl 1 input n 3 output 5 explan five differ way show exampl 2 input n 1 output 1 constraint 1 n 1000 dominoandtrominotil
write function take binari represent unsign integ return number 1 bit also known ham weight note note languag java unsign integ type case input given sign integ type affect implement integ intern binari represent whether sign unsign java compil repres sign integ use 2s complement notat therefor exampl 3 input repres sign integ 3 exampl 1 input n 00000000000000000000000000001011 output 3 explan input binari string 00000000000000000000000000001011 total three 1 bit exampl 2 input n 00000000000000000000000010000000 output 1 explan input binari string 00000000000000000000000010000000 total one 1 bit exampl 3 input n 11111111111111111111111111111101 output 31 explan input binari string 11111111111111111111111111111101 total thirti one 1 bit constraint input must binari string length 32 follow function call mani time would optim numberof1bit
integ array num consist n uniqu element forgotten howev rememb everi pair adjac element num given 2d integ array adjacentpair size n 1 adjacentpairsi ui vi indic element ui vi adjac num guarante everi adjac pair element numsi numsi1 exist adjacentpair either numsi numsi1 numsi1 numsi pair appear order return origin array num multipl solut return exampl 1 input adjacentpair 213432 output 1234 explan array adjac pair adjacentpair notic adjacentpairsi may lefttoright order exampl 2 input adjacentpair 421431 output 2413 explan neg number anoth solut 3142 would also accept exampl 3 input adjacentpair 100000100000 output 100000100000 constraint numslength n adjacentpairslength n 1 adjacentpairsilength 2 2 n 105 105 numsi ui vi 105 exist num adjacentpair pair restorethearrayfromadjacentpair
given integ array height length n n vertic line drawn two endpoint ith line 0 heighti find two line togeth xaxi form contain contain contain water return maximum amount water contain store notic may slant contain exampl 1 input height 186254837 output 49 explan vertic line repres array 186254837 case max area water blue section contain contain 49 exampl 2 input height 11 output 1 constraint n heightlength 2 n 105 0 heighti 104 containerwithmostwat
citi repres bidirect connect graph n vertic vertex label 1 n inclus edg graph repres 2d integ array edg edgesi ui vi denot bidirect edg vertex ui vertex vi everi vertex pair connect one edg vertex edg time taken travers edg time minut vertex traffic signal chang color green red vice versa everi chang minut signal chang time enter vertex time leav vertex signal green wait vertex signal green second minimum valu defin smallest valu strictli larger minimum valu exampl second minimum valu 2 3 4 3 second minimum valu 2 2 4 4 given n edg time chang return second minimum time take go vertex 1 vertex n note go vertex number time includ 1 n assum journey start signal turn green exampl 1 input n 5 edg 1213143445 time 3 chang 5 output 13 explan figur left show given graph blue path figur right minimum time path time taken start 1 time elapsed0 1 4 3 minut time elapsed3 4 5 3 minut time elapsed6 henc minimum time need 6 minut red path show path get second minimum time start 1 time elapsed0 1 3 3 minut time elapsed3 3 4 3 minut time elapsed6 wait 4 4 minut time elapsed10 4 5 3 minut time elapsed13 henc second minimum time 13 minut exampl 2 input n 2 edg 12 time 3 chang 2 output 11 explan minimum time path 1 2 time 3 minut second minimum time path 1 2 1 2 time 11 minut constraint 2 n 104 n 1 edgeslength min2 104 n n 1 2 edgesilength 2 1 ui vi n ui vi duplic edg vertex reach directli indirectli everi vertex 1 time chang 103 secondminimumtimetoreachdestin
given integ array num length n integ num rang 1 n integ appear twice return array integ appear twice must write algorithm run time use constant extra space exampl 1 input num 43278231 output 23 exampl 2 input num 112 output 1 exampl 3 input num 1 output constraint n numslength 1 n 105 1 numsi n element num appear twice findallduplicatesinanarray
alphabet continu string string consist consecut letter alphabet word substr string abcdefghijklmnopqrstuvwxyz exampl abc alphabet continu string acb za given string consist lowercas letter return length longest alphabet continu substr exampl 1 input abacaba output 2 explan 4 distinct continu substr b c ab ab longest continu substr exampl 2 input abcd output 5 explan abcd longest continu substr constraint 1 slength 105 consist english lowercas letter lengthofthelongestalphabeticalcontinuoussubstr
start cell rstart cstart row x col grid face east northwest corner first row column grid southeast corner last row column walk clockwis spiral shape visit everi posit grid whenev move outsid grid boundari continu walk outsid grid may return grid boundari later eventu reach row col space grid return array coordin repres posit grid order visit exampl 1 input row 1 col 4 rstart 0 cstart 0 output 00010203 exampl 2 input row 5 col 6 rstart 1 cstart 4 output 141525242313030405353433322212024544434241312111014030201000 constraint 1 row col 100 0 rstart row 0 cstart col spiralmatrixiii
given n x n integ matrix grid gener integ matrix maxloc size n 2 x n 2 maxlocalij equal largest valu 3 x 3 matrix grid center around row 1 column j 1 word want find largest valu everi contigu 3 x 3 matrix grid return gener matrix exampl 1 input grid 9981562682646222 output 9986 explan diagram show origin matrix gener matrix notic valu gener matrix correspond largest valu contigu 3 x 3 matrix grid exampl 2 input grid 1111111111112111111111111 output 222222222 explan notic 2 contain within everi contigu 3 x 3 matrix grid constraint n gridlength gridilength 3 n 100 1 gridij 100 largestlocalvaluesinamatrix
given x n binari matrix fill 0s 1s find largest squar contain 1s return area exampl 1 input matrix 10100101111111110010 output 4 exampl 2 input matrix 0110 output 1 exampl 3 input matrix 0 output 0 constraint matrixlength n matrixilength 1 n 300 matrixij 0 1 maximalsquar
given 0index array word consist distinct string string wordsi pair string wordsj string wordsi equal revers string wordsj 0 j wordslength return maximum number pair form array word note string belong one pair exampl 1 input word cdacdccazz output 2 explan exampl form 2 pair string follow way pair 0th string 2nd string revers string word0 dc equal words2 pair 1st string 3rd string revers string word1 ca equal words3 proven 2 maximum number pair form exampl 2 input word abbacc output 1 explan exampl form 1 pair string follow way pair 0th string 1st string revers string words1 ab equal words0 proven 1 maximum number pair form exampl 3 input word aaab output 0 explan exampl unabl form pair string constraint 1 wordslength 50 wordsilength 2 word consist distinct string wordsi contain lowercas english letter findmaximumnumberofstringpair
cubic storeroom width length height room equal n unit ask place n box room box cube unit side length howev rule place box place box anywher floor box x place top box side four vertic side box must either adjac anoth box wall given integ n return minimum possibl number box touch floor exampl 1 input n 3 output 3 explan figur placement three box box place corner room corner left side exampl 2 input n 4 output 3 explan figur placement four box box place corner room corner left side exampl 3 input n 10 output 6 explan figur placement ten box box place corner room corner back side constraint 1 n 109 buildingbox
inform n differ recip given string array recip 2d string array ingredi ith recip name recipesi creat need ingredi ingredientsi ingredi recip may need creat recip ie ingredientsi may contain string recip also given string array suppli contain ingredi initi infinit suppli return list recip creat may return answer order note two recip may contain ingredi exampl 1 input recip bread ingredi yeastflour suppli yeastflourcorn output bread explan creat bread sinc ingredi yeast flour exampl 2 input recip breadsandwich ingredi yeastflourbreadmeat suppli yeastflourmeat output breadsandwich explan creat bread sinc ingredi yeast flour creat sandwich sinc ingredi meat creat ingredi bread exampl 3 input recip breadsandwichburg ingredi yeastflourbreadmeatsandwichmeatbread suppli yeastflourmeat output breadsandwichburg explan creat bread sinc ingredi yeast flour creat sandwich sinc ingredi meat creat ingredi bread creat burger sinc ingredi meat creat ingredi bread sandwich constraint n recipeslength ingredientslength 1 n 100 1 ingredientsilength supplieslength 100 1 recipesilength ingredientsijlength suppliesklength 10 recipesi ingredientsij suppliesk consist lowercas english letter valu recip suppli combin uniqu ingredientsi contain duplic valu findallpossiblerecipesfromgivensuppli
given two 0index string target take letter rearrang form new string return maximum number copi target form take letter rearrang exampl 1 input ilovecodingonleetcod target code output 2 explan first copi code take letter indic 4 5 6 7 second copi code take letter indic 17 18 19 20 string form ecod code rearrang code make two copi code return 2 exampl 2 input abcba target abc output 1 explan make one copi abc take letter indic 0 1 2 make one copi abc return 1 note extra b indic 3 4 reus letter c index 2 make second copi abc exampl 3 input abbaccaddaeea target aaaaa output 1 explan make one copi aaaaa take letter indic 0 3 6 9 12 make one copi aaaaa return 1 constraint 1 slength 100 1 targetlength 10 target consist lowercas english letter rearrangecharacterstomaketargetstr
given custom visit log shop repres 0index string custom consist charact n ith charact mean custom come ith hour wherea n indic custom come ith hour shop close jth hour 0 j n penalti calcul follow everi hour shop open custom come penalti increas 1 everi hour shop close custom come penalti increas 1 return earliest hour shop must close incur minimum penalti note shop close jth hour mean shop close hour j exampl 1 input custom yyni output 2 explan close shop 0th hour incur 1101 3 penalti close shop 1st hour incur 0101 2 penalti close shop 2nd hour incur 0001 1 penalti close shop 3rd hour incur 0011 2 penalti close shop 4th hour incur 0010 1 penalti close shop 2nd 4th hour give minimum penalti sinc 2 earlier optim close time 2 exampl 2 input custom nnnnn output 0 explan best close shop 0th hour custom arriv exampl 3 input custom yyyi output 4 explan best close shop 4th hour custom arriv hour constraint 1 customerslength 105 custom consist charact n minimumpenaltyforashop
given posit integ num repres string return integ num without trail zero string exampl 1 input num 51230100 output 512301 explan integ 51230100 2 trail zero remov return integ 512301 exampl 2 input num 123 output 123 explan integ 123 trail zero return integ 123 constraint 1 numlength 1000 num consist digit num doesnt lead zero removetrailingzerosfromastr
given array arr function fn return sort array sortedarr assum fn return number number determin sort order sortedarr sortedarray must sort ascend order fn output may assum fn never duplic number given array exampl 1 input arr 5 4 1 2 3 fn x x output 1 2 3 4 5 explan fn simpli return number pass array sort ascend order exampl 2 input arr x 1 x 0 x 1 fn dx output x 1 x 0 x 1 explan fn return valu x key array sort base valu exampl 3 input arr 3 4 5 2 10 1 fn x x1 output 10 1 5 2 3 4 explan arr sort ascend order number index1 constraint arr valid json array fn function return number 1 arrlength 5 105 sortbi
profession robber plan rob hous along street hous certain amount money stash hous place arrang circl mean first hous neighbor last one meanwhil adjac hous secur system connect automat contact polic two adjac hous broken night given integ array num repres amount money hous return maximum amount money rob tonight without alert polic exampl 1 input num 232 output 3 explan rob hous 1 money 2 rob hous 3 money 2 adjac hous exampl 2 input num 1231 output 4 explan rob hous 1 money 1 rob hous 3 money 3 total amount rob 1 3 4 exampl 3 input num 123 output 3 constraint 1 numslength 100 0 numsi 1000 houserobberii
design calcul class class provid mathemat oper addit subtract multipl divis exponenti also allow consecut oper perform use method chain calcul class constructor accept number serv initi valu result calcul class follow method add method add given number valu result return updat calcul subtract method subtract given number valu result return updat calcul multipli method multipli result given number valu return updat calcul divid method divid result given number valu return updat calcul pass valu 0 error divis zero allow thrown power method rais result power given number valu return updat calcul getresult method return result solut within 105 actual result consid correct exampl 1 input action calcul add subtract getresult valu 10 5 7 output 8 explan new calculator10add5subtract7getresult 10 5 7 8 exampl 2 input action calcul multipli power getresult valu 2 5 2 output 100 explan new calculator2multiply5power2getresult 2 5 2 100 exampl 3 input action calcul divid getresult valu 20 0 output divis zero allow explan new calculator20divide0getresult 20 0 error thrown divid zero constraint 2 actionslength 2 104 1 valueslength 2 104 1 actionsi one calcul add subtract multipli divid power getresult last action alway getresult valu json array number calculatorwithmethodchain
given 0index string word charact ch revers segment word start index 0 end index first occurr ch inclus charact ch exist word noth exampl word abcdefd ch revers segment start 0 end 3 inclus result string dcbaefd return result string exampl 1 input word abcdefd ch output dcbaefd explan first occurr index 3 revers part word 0 3 inclus result string dcbaefd exampl 2 input word xyxzx ch z output zxyxx explan first occurr z index 3 revers part word 0 3 inclus result string zxyxx exampl 3 input word abcd ch z output abcd explan z exist word revers oper result string abcd constraint 1 wordlength 250 word consist lowercas english letter ch lowercas english letter reverseprefixofword
given array target n integ start array arr consist n 1s may perform follow procedur let x sum element current array choos index 0 n set valu arr index x may repeat procedur mani time need return true possibl construct target array arr otherwis return fals exampl 1 input target 935 output true explan start arr 1 1 1 1 1 1 sum 3 choos index 1 1 3 1 sum 5 choos index 2 1 3 5 sum 9 choos index 0 9 3 5 done exampl 2 input target 1112 output fals explan imposs creat target array 1111 exampl 3 input target 85 output true constraint n targetlength 1 n 5 104 1 targeti 109 constructtargetarraywithmultiplesum
given integ array queri posit integ intlength return array answer answeri either queriesith smallest posit palindrom length intlength 1 palindrom exist palindrom number read backward forward palindrom lead zero exampl 1 input queri 1234590 intlength 3 output 101111121131141999 explan first palindrom length 3 101 111 121 131 141 151 161 171 181 191 202 90th palindrom length 3 999 exampl 2 input queri 246 intlength 4 output 111113311551 explan first six palindrom length 4 1001 1111 1221 1331 1441 1551 constraint 1 querieslength 5 104 1 queriesi 109 1 intlength 15 findpalindromewithfixedlength
given two string s1 s2 return lowest ascii sum delet charact make two string equal exampl 1 input s1 sea s2 eat output 231 explan delet sea add ascii valu 115 sum delet eat add 116 sum end string equal 115 116 231 minimum sum possibl achiev exampl 2 input s1 delet s2 leet output 403 explan delet dee delet turn string let add 100d 101e 101e sum delet e leet add 101e sum end string equal let answer 100101101101 403 instead turn string lee eet would get answer 433 417 higher constraint 1 s1length s2length 1000 s1 s2 consist lowercas english letter minimumasciideletesumfortwostr
path binari tree sequenc node pair adjac node sequenc edg connect node appear sequenc note path need pass root path sum path sum node valu path given root binari tree return maximum path sum nonempti path exampl 1 input root 123 output 6 explan optim path 2 1 3 path sum 2 1 3 6 exampl 2 input root 10920nullnull157 output 42 explan optim path 15 20 7 path sum 15 20 7 42 constraint number node tree rang 1 3 104 1000 nodev 1000 binarytreemaximumpathsum
given integ array arr sort integ array ascend order number 1s binari represent case two integ number 1s sort ascend order return array sort exampl 1 input arr 012345678 output 012483567 explant 0 integ 0 bit 1248 1 bit 356 2 bit 7 3 bit sort array bit 012483567 exampl 2 input arr 10245122561286432168421 output 12481632641282565121024 explant integ 1 bit binari represent sort ascend order constraint 1 arrlength 500 0 arri 104 sortintegersbythenumberof1bit
given integ array num sort nondecreas order build return integ array result length num resulti equal summat absolut differ numsi element array word resulti equal sumnumsinumsj 0 j numslength j 0index exampl 1 input num 235 output 435 explan assum array 0index result0 22 23 25 0 1 3 4 result1 32 33 35 1 0 2 3 result2 52 53 55 3 2 0 5 exampl 2 input num 146810 output 2415131521 constraint 2 numslength 105 1 numsi numsi 1 104 sumofabsolutedifferencesinasortedarray
cell r c excel sheet repres string colrow col denot column number c cell repres alphabet letter exampl 1st column denot 2nd b 3rd c row row number r cell rth row repres integ r given string format col1row1col2row2 col1 repres column c1 row1 repres row r1 col2 repres column c2 row2 repres row r2 r1 r2 c1 c2 return list cell x r1 x r2 c1 c2 cell repres string format mention sort nondecreas order first column row exampl 1 input k1l2 output k1k2l1l2 explan diagram show cell present list red arrow denot order cell present exampl 2 input a1f1 output a1b1c1d1e1f1 explan diagram show cell present list red arrow denot order cell present constraint slength 5 s0 s3 z 1 s1 s4 9 consist uppercas english letter digit cellsinarangeonanexcelsheet
integ x numer balanc everi digit number x exactli occurr digit x given integ n return smallest numer balanc number strictli greater n exampl 1 input n 1 output 22 explan 22 numer balanc sinc digit 2 occur 2 time also smallest numer balanc number strictli greater 1 exampl 2 input n 1000 output 1333 explan 1333 numer balanc sinc digit 1 occur 1 time digit 3 occur 3 time also smallest numer balanc number strictli greater 1000 note 1022 answer 0 appear 0 time exampl 3 input n 3000 output 3133 explan 3133 numer balanc sinc digit 1 occur 1 time digit 3 occur 3 time also smallest numer balanc number strictli greater 3000 constraint 0 n 106 nextgreaternumericallybalancednumb
given integ array num two integ lower upper return number rang sum lie lower upper inclus rang sum si j defin sum element num indic j inclus j exampl 1 input num 251 lower 2 upper 2 output 3 explan three rang 00 22 02 respect sum 2 1 2 exampl 2 input num 0 lower 0 upper 0 output 1 constraint 1 numslength 105 231 numsi 231 1 105 lower upper 105 answer guarante fit 32bit integ countofrangesum
given integ array ban two integ n maxsum choos number integ follow rule chosen integ rang 1 n integ chosen chosen integ array ban sum chosen integ exceed maxsum return maximum number integ choos follow mention rule exampl 1 input ban 165 n 5 maxsum 6 output 2 explan choos integ 2 4 2 4 rang 1 5 appear ban sum 6 exceed maxsum exampl 2 input ban 1234567 n 8 maxsum 1 output 0 explan choos integ follow mention condit exampl 3 input ban 11 n 7 maxsum 50 output 7 explan choos integ 1 2 3 4 5 6 7 rang 1 7 appear ban sum 28 exceed maxsum constraint 1 bannedlength 104 1 bannedi n 104 1 maxsum 109 maximumnumberofintegerstochoosefromarangei
given 0index x n binari matrix grid move cell row col cell row 1 col row col 1 valu 1 matrix disconnect path 0 0 1 n 1 flip valu one possibl none cell flip cell 0 0 1 n 1 return true possibl make matrix disconnect fals otherwis note flip cell chang valu 0 1 1 0 exampl 1 input grid 111100111 output true explan chang cell shown diagram path 0 0 2 2 result grid exampl 2 input grid 111101111 output fals explan possibl chang one cell path 0 0 2 2 constraint gridlength n gridilength 1 n 1000 1 n 105 gridij either 0 1 grid00 gridm 1n 1 1 disconnectpathinabinarymatrixbyatmostoneflip
tournament n player particip player stand singl row number 1 n base initi stand posit player 1 first player row player 2 second player row etc tournament consist multipl round start round number 1 round ith player front row compet ith player end row winner advanc next round number player odd current round player middl automat advanc next round exampl row consist player 1 2 4 6 7 player 1 compet player 7 player 2 compet player 6 player 4 automat advanc next round round winner line back row base origin order assign initi ascend order player number firstplay secondplay best tournament win player compet two player compet either might win thu may choos outcom round given integ n firstplay secondplay return integ array contain two valu earliest possibl round number latest possibl round number two player compet respect exampl 1 input n 11 firstplay 2 secondplay 4 output 34 explan one possibl scenario lead earliest round number first round 1 2 3 4 5 6 7 8 9 10 11 second round 2 3 4 5 6 11 third round 2 3 4 one possibl scenario lead latest round number first round 1 2 3 4 5 6 7 8 9 10 11 second round 1 2 3 4 5 6 third round 1 2 4 fourth round 2 4 exampl 2 input n 5 firstplay 1 secondplay 5 output 11 explan player number 1 5 compet first round way make compet round constraint 2 n 28 1 firstplay secondplay n theearliestandlatestroundswhereplayerscompet
given string determin valid string valid start empti string transform perform follow oper number time insert string abc posit formal becom tleft abc tright tleft tright note tleft tright may empti return true valid string otherwis return fals exampl 1 input aabcbc output true explan abc aabcbc thu aabcbc valid exampl 2 input abcabcababcc output true explan abc abcabc abcabcabc abcabcababcc thu abcabcababcc valid exampl 3 input abccba output fals explan imposs get abccba use oper constraint 1 slength 2 104 consist letter b c checkifwordisvalidaftersubstitut
given two nonincreas 0index integ array nums1 nums2 pair indic j 0 nums1length 0 j nums2length valid j nums1i nums2j distanc pair j return maximum distanc valid pair j valid pair return 0 array arr nonincreas arri1 arri everi 1 arrlength exampl 1 input nums1 5530542 nums2 1002010105 output 2 explan valid pair 00 22 23 24 33 34 44 maximum distanc 2 pair 24 exampl 2 input nums1 222 nums2 10101 output 1 explan valid pair 00 01 11 maximum distanc 1 pair 01 exampl 3 input nums1 3029195 nums2 2525252525 output 2 explan valid pair 22 23 24 33 34 maximum distanc 2 pair 24 constraint 1 nums1length nums2length 105 1 nums1i nums2j 105 nums1 nums2 nonincreas maximumdistancebetweenapairofvalu
n x n chessboard knight start cell row column attempt make exactli k move row column 0index topleft cell 0 0 bottomright cell n 1 n 1 chess knight eight possibl move make illustr move two cell cardin direct one cell orthogon direct time knight move choos one eight possibl move uniformli random even piec would go chessboard move knight continu move made exactli k move move chessboard return probabl knight remain board stop move exampl 1 input n 3 k 2 row 0 column 0 output 006250 explan two move 12 21 keep knight board posit also two move keep knight board total probabl knight stay board 00625 exampl 2 input n 1 k 0 row 0 column 0 output 100000 constraint 1 n 25 0 k 100 0 row column n 1 knightprobabilityinchessboard
given root binari tree contain digit 0 9 roottoleaf path tree repres number exampl roottoleaf path 1 2 3 repres number 123 return total sum roottoleaf number test case gener answer fit 32bit integ leaf node node children exampl 1 input root 123 output 25 explan roottoleaf path 12 repres number 12 roottoleaf path 13 repres number 13 therefor sum 12 13 25 exampl 2 input root 49051 output 1026 explan roottoleaf path 495 repres number 495 roottoleaf path 491 repres number 491 roottoleaf path 40 repres number 40 therefor sum 495 491 40 1026 constraint number node tree rang 1 1000 0 nodev 9 depth tree exceed 10 sumroottoleafnumb
given 0index string word consist lowercas english letter need select one index remov letter index word frequenc everi letter present word equal return true possibl remov one letter frequenc letter word equal fals otherwis note frequenc letter x number time occur string must remov exactli one letter chose noth exampl 1 input word abcc output true explan select index 3 delet word becom abc charact frequenc 1 exampl 2 input word aazz output fals explan must delet charact either frequenc 1 frequenc z 2 vice versa imposs make present letter equal frequenc constraint 2 wordlength 100 word consist lowercas english letter removelettertoequalizefrequ
given 0index integ array stone sort strictli increas order repres posit stone river frog initi first stone want travel last stone return first stone howev jump stone length jump absolut differ posit stone frog current posit stone frog jump formal frog stonesi jump stonesj length jump stonesi stonesj cost path maximum length jump among jump path return minimum cost path frog exampl 1 input stone 02567 output 5 explan figur repres one optim path frog take cost path 5 maximum length jump sinc possibl achiev cost less 5 return exampl 2 input stone 039 output 9 explan frog jump directli last stone come back first stone case length jump 9 cost path max9 9 9 shown minimum achiev cost constraint 2 stoneslength 105 0 stonesi 109 stones0 0 stone sort strictli increas order frogjumpii
return number distinct nonempti substr text written concaten string ie written string exampl 1 input text abcabcabc output 3 explan 3 substr abcabc bcabca cabcab exampl 2 input text leetcodeleetcod output 2 explan 2 substr ee leetcodeleetcod constraint 1 textlength 2000 text lowercas english letter distinctechosubstr
given date string form day month year day set 1st 2nd 3rd 4th 30th 31st month set jan feb mar apr may jun jul aug sep oct nov dec year rang 1900 2100 convert date string format yyyymmdd yyyi denot 4 digit year mm denot 2 digit month dd denot 2 digit day exampl 1 input date 20th oct 2052 output 20521020 exampl 2 input date 6th jun 1933 output 19330606 exampl 3 input date 26th may 1960 output 19600526 constraint given date guarante valid error handl necessari reformatd
given head link list integ k return head link list swap valu kth node begin kth node end list 1index exampl 1 input head 12345 k 2 output 14325 exampl 2 input head 7966783095 k 5 output 7966873095 constraint number node list n 1 k n 105 0 nodev 100 swappingnodesinalinkedlist
given sign 32bit integ x return x digit revers revers x caus valu go outsid sign 32bit integ rang 231 231 1 return 0 assum environ allow store 64bit integ sign unsign exampl 1 input x 123 output 321 exampl 2 input x 123 output 321 exampl 3 input x 120 output 21 constraint 231 x 231 1 reverseinteg
given array integ num choos two differ indic j array return maximum valu numsi1numsj1 exampl 1 input num 3452 output 12 explan choos indic i1 j2 index 0 get maximum valu nums11nums21 4151 34 12 exampl 2 input num 1545 output 16 explan choos indic i1 j3 index 0 get maximum valu 5151 16 exampl 3 input num 37 output 12 constraint 2 numslength 500 1 numsi 103 maximumproductoftwoelementsinanarray
2d grid size x n repres box n ball box open top bottom side cell box diagon board span two corner cell redirect ball right left board redirect ball right span topleft corner bottomright corner repres grid 1 board redirect ball left span topright corner bottomleft corner repres grid 1 drop one ball top column box ball get stuck box fall bottom ball get stuck hit v shape pattern two board board redirect ball either wall box return array answer size n answeri column ball fall bottom drop ball ith column top 1 ball get stuck box exampl 1 input grid 1111111111111111111111111 output 11111 explan exampl shown photo ball b0 drop column 0 fall box column 1 ball b1 drop column 1 get stuck box column 2 3 row 1 ball b2 drop column 2 get stuck box column 2 3 row 0 ball b3 drop column 3 get stuck box column 2 3 row 0 ball b4 drop column 4 get stuck box column 2 3 row 1 exampl 2 input grid 1 output 1 explan ball get stuck left wall exampl 3 input grid 111111111111111111111111 output 012341 constraint gridlength n gridilength 1 n 100 gridij 1 1 wherewilltheballfal
given string convert palindrom ad charact front return shortest palindrom find perform transform exampl 1 input aacecaaa output aaacecaaa exampl 2 input abcd output dcbabcd constraint 0 slength 5 104 consist lowercas english letter shortestpalindrom
given 0index 2d integ array transact transactionsi costi cashbacki array describ transact transact must complet exactli order given moment certain amount money order complet transact money costi must hold true perform transact money becom money costi cashbacki return minimum amount money requir transact transact complet regardless order transact exampl 1 input transact 215042 output 10 explan start money 10 transact perform order shown start money 10 fail complet transact order exampl 2 input transact 3003 output 3 explan transact order 3003 minimum money requir complet transact 3 transact order 0330 minimum money requir complet transact 0 thu start money 3 transact perform order constraint 1 transactionslength 105 transactionsilength 2 0 costi cashbacki 109 minimummoneyrequiredbeforetransact
n citi connect citi connect directli citi b citi b connect directli citi c citi connect indirectli citi c provinc group directli indirectli connect citi citi outsid group given n x n matrix isconnect isconnectedij 1 ith citi jth citi directli connect isconnectedij 0 otherwis return total number provinc exampl 1 input isconnect 110110001 output 2 exampl 2 input isconnect 100010001 output 3 constraint 1 n 200 n isconnectedlength n isconnectedilength isconnectedij 1 0 isconnectedii 1 isconnectedij isconnectedji numberofprovinc
given array string word return first palindrom string array string return empti string string palindrom read forward backward exampl 1 input word abccaradaracecarcool output ada explan first string palindrom ada note racecar also palindrom first exampl 2 input word notapalindromeracecar output racecar explan first string palindrom racecar exampl 3 input word defghi output explan palindrom string empti string return constraint 1 wordslength 100 1 wordsilength 100 wordsi consist lowercas english letter findfirstpalindromicstringinthearray
given array digit string num digit string target return number pair indic j j concaten numsi numsj equal target exampl 1 input num 77777777 target 7777 output 4 explan valid pair 0 1 777 7 1 0 7 777 2 3 77 77 3 2 77 77 exampl 2 input num 12341234 target 1234 output 2 explan valid pair 0 1 123 4 2 3 12 34 exampl 3 input num 111 target 11 output 6 explan valid pair 0 1 1 1 1 0 1 1 0 2 1 1 2 0 1 1 1 2 1 1 2 1 1 1 constraint 2 numslength 100 1 numsilength 100 2 targetlength 100 numsi target consist digit numsi target lead zero numberofpairsofstringswithconcatenationequaltotarget
pair sum pair ab equal b maximum pair sum largest pair sum list pair exampl pair 15 23 44 maximum pair sum would max15 23 44 max6 5 8 8 given array num even length n pair element num n 2 pair element num exactli one pair maximum pair sum minim return minim maximum pair sum optim pair element exampl 1 input num 3523 output 7 explan element pair pair 33 52 maximum pair sum max33 52 max6 7 7 exampl 2 input num 354246 output 8 explan element pair pair 35 44 62 maximum pair sum max35 44 62 max8 8 8 8 constraint n numslength 2 n 105 n even 1 numsi 105 minimizemaximumpairsuminarray
given 0index integ array num length n split index 0 n 2 call valid product first 1 element product remain element coprim exampl num 2 3 3 split index 0 valid 2 9 coprim split index 1 valid 6 3 coprim split index 2 valid n 1 return smallest index array split validli 1 split two valu val1 val2 coprim gcdval1 val2 1 gcdval1 val2 greatest common divisor val1 val2 exampl 1 input num 4781535 output 2 explan tabl show valu product first 1 element remain element gcd index valid split index 2 exampl 2 input num 4715835 output 1 explan tabl show valu product first 1 element remain element gcd index valid split constraint n numslength 1 n 104 1 numsi 106 splitthearraytomakecoprimeproduct
given string text swap two charact text return length longest substr repeat charact exampl 1 input text ababa output 3 explan swap first b last last b first longest repeat charact substr aaa length 3 exampl 2 input text aaabaaa output 6 explan swap b last first get longest repeat charact substr aaaaaa length 6 exampl 3 input text aaaaa output 5 explan need swap longest repeat charact substr aaaaa length 5 constraint 1 textlength 2 104 text consist lowercas english charact swapforlongestrepeatedcharactersubstr
design food rate system follow modifi rate food item list system return highestr food item type cuisin system implement foodrat class foodratingsstr food string cuisin int rate initi system food item describ food cuisin rate length n foodsi name ith food cuisinesi type cuisin ith food ratingsi initi rate ith food void changeratingstr food int newrat chang rate food item name food string highestratedstr cuisin return name food item highest rate given type cuisin tie return item lexicograph smaller name note string x lexicograph smaller string x come dictionari order either x prefix first posit xi yi xi come yi alphabet order exampl 1 input foodrat highestr highestr changer highestr changer highestr kimchi miso sushi moussaka ramen bulgogi korean japanes japanes greek japanes korean 9 12 8 15 14 7 korean japanes sushi 16 japanes ramen 16 japanes output null kimchi ramen null sushi null ramen explan foodrat foodrat new foodratingskimchi miso sushi moussaka ramen bulgogi korean japanes japanes greek japanes korean 9 12 8 15 14 7 foodratingshighestratedkorean return kimchi kimchi highest rate korean food rate 9 foodratingshighestratedjapanes return ramen ramen highest rate japanes food rate 14 foodratingschangeratingsushi 16 sushi rate 16 foodratingshighestratedjapanes return sushi sushi highest rate japanes food rate 16 foodratingschangeratingramen 16 ramen rate 16 foodratingshighestratedjapanes return ramen sushi ramen rate 16 howev ramen lexicograph smaller sushi constraint 1 n 2 104 n foodslength cuisineslength ratingslength 1 foodsilength cuisinesilength 10 foodsi cuisinesi consist lowercas english letter 1 ratingsi 108 string food distinct food name food item system across call changer cuisin type cuisin least one food item system across call highestr 2 104 call total made changer highestr designafoodratingsystem
given two integ array nums1 nums2 length n xor sum two integ array nums10 xor nums20 nums11 xor nums21 nums1n 1 xor nums2n 1 0index exampl xor sum 123 321 equal 1 xor 3 2 xor 2 3 xor 1 2 0 2 4 rearrang element nums2 result xor sum minim return xor sum rearrang exampl 1 input nums1 12 nums2 23 output 2 explan rearrang nums2 becom 32 xor sum 1 xor 3 2 xor 2 2 0 2 exampl 2 input nums1 103 nums2 534 output 8 explan rearrang nums2 becom 543 xor sum 1 xor 5 0 xor 4 3 xor 3 4 4 0 8 constraint n nums1length n nums2length 1 n 14 0 nums1i nums2i 107 minimumxorsumoftwoarray
given integ array gift denot number gift variou pile everi second follow choos pile maximum number gift one pile maximum number gift choos leav behind floor squar root number gift pile take rest gift return number gift remain k second exampl 1 input gift 256494100 k 4 output 29 explan gift taken follow way first second last pile chosen 10 gift left behind second pile chosen 8 gift left behind first pile chosen 5 gift left behind final last pile chosen 3 gift left behind final remain gift 58943 total number gift remain 29 exampl 2 input gift 1111 k 4 output 4 explan case regardless pile choos leav behind 1 gift pile cant take pile total gift remain 4 constraint 1 giftslength 103 1 giftsi 109 1 k 103 takegiftsfromtherichestpil
given array integ temperatur repres daili temperatur return array answer answeri number day wait ith day get warmer temperatur futur day possibl keep answeri 0 instead exampl 1 input temperatur 7374757169727673 output 11421100 exampl 2 input temperatur 30405060 output 1110 exampl 3 input temperatur 306090 output 110 constraint 1 temperatureslength 105 30 temperaturesi 100 dailytemperatur
given root binari tree invert tree return root exampl 1 input root 4271369 output 4729631 exampl 2 input root 213 output 231 exampl 3 input root output constraint number node tree rang 0 100 100 nodev 100 invertbinarytre
given binari string return minimum number charact swap make altern 1 imposs string call altern two adjac charact equal exampl string 010 1010 altern string 0100 two charact may swap even adjac exampl 1 input 111000 output 1 explan swap posit 1 4 111000 101010 string altern exampl 2 input 010 output 0 explan string alreadi altern swap need exampl 3 input 1110 output 1 constraint 1 slength 1000 si either 0 1 minimumnumberofswapstomakethebinarystringaltern
countri n citi number 0 n 1 citi connect bidirect road road repres 2d integ array edg edgesi xi yi timei denot road citi xi yi take timei minut travel may multipl road differ travel time connect two citi road connect citi time pass citi must pay pass fee repres 0index integ array passingfe length n passingfeesj amount dollar must pay pass citi j begin citi 0 want reach citi n 1 maxtim minut less cost journey summat pass fee citi pass moment journey includ sourc destin citi given maxtim edg passingfe return minimum cost complet journey 1 complet within maxtim minut exampl 1 input maxtim 30 edg 01101210251003134104515 passingfe 51220203 output 11 explan path take 0 1 2 5 take 30 minut 11 worth pass fee exampl 2 input maxtim 29 edg 01101210251003134104515 passingfe 51220203 output 48 explan path take 0 3 4 5 take 26 minut 48 worth pass fee take path 0 1 2 5 sinc would take long exampl 3 input maxtim 25 edg 01101210251003134104515 passingfe 51220203 output 1 explan way reach citi 5 citi 0 within 25 minut constraint 1 maxtim 1000 n passingfeeslength 2 n 1000 n 1 edgeslength 1000 0 xi yi n 1 1 timei 1000 1 passingfeesj 1000 graph may contain multipl edg two node graph contain self loop minimumcosttoreachdestinationintim
given string integ k choos one first k letter append end string return lexicograph smallest string could appli mention step number move exampl 1 input cba k 1 output acb explan first move move 1st charact c end obtain string bac second move move 1st charact b end obtain final result acb exampl 2 input baaca k 3 output aaabc explan first move move 1st charact b end obtain string aacab second move move 3rd charact c end obtain final result aaabc constraint 1 k slength 1000 consist lowercas english letter orderlyqueu
given two 0index integ array cost time size n repres cost time taken paint n differ wall respect two painter avail paid painter paint ith wall timei unit time take costi unit money free painter paint wall 1 unit time cost 0 free painter use paid painter alreadi occupi return minimum amount money requir paint n wall exampl 1 input cost 1232 time 1232 output 3 explan wall index 0 1 paint paid painter take 3 unit time meanwhil free painter paint wall index 2 3 free cost 2 unit time thu total cost 1 2 3 exampl 2 input cost 2342 time 1111 output 4 explan wall index 0 3 paint paid painter take 2 unit time meanwhil free painter paint wall index 1 2 free cost 2 unit time thu total cost 2 2 4 constraint 1 costlength 500 costlength timelength 1 costi 106 1 timei 500 paintingthewal
certain bug home xaxi posit x help get posit 0 bug jump accord follow rule jump exactli posit forward right jump exactli b posit backward left jump backward twice row jump forbidden posit bug may jump forward beyond home jump posit number neg integ given array integ forbidden forbiddeni mean bug jump posit forbiddeni integ b x return minimum number jump need bug reach home possibl sequenc jump land bug posit x return 1 exampl 1 input forbidden 14418115 3 b 15 x 9 output 3 explan 3 jump forward 0 3 6 9 get bug home exampl 2 input forbidden 831661220 15 b 13 x 11 output 1 exampl 3 input forbidden 162145174 16 b 9 x 7 output 2 explan one jump forward 0 16 one jump backward 16 7 get bug home constraint 1 forbiddenlength 1000 1 b forbiddeni 2000 0 x 2000 element forbidden distinct posit x forbidden minimumjumpstoreachhom
password consid strong condit met least 6 charact 20 charact contain least one lowercas letter least one uppercas letter least one digit contain three repeat charact row ie baaabb0 weak baaba0 strong given string password return minimum number step requir make password strong password alreadi strong return 0 one step insert one charact password delet one charact password replac one charact password anoth charact exampl 1 input password output 5 exampl 2 input password aa1 output 3 exampl 3 input password 1337c0d3 output 0 constraint 1 passwordlength 50 password consist letter digit dot exclam mark strongpasswordcheck
given two binari tree origin clone given refer node target origin tree clone tree copi origin tree return refer node clone tree note allow chang two tree target node answer must refer node clone tree exampl 1 input tree 743nullnull619 target 3 output 3 explan exampl origin clone tree shown target node green node origin tree answer yellow node clone tree exampl 2 input tree 7 target 7 output 7 exampl 3 input tree 8null6null5null4null3null2null1 target 4 output 4 constraint number node tree rang 1 104 valu node tree uniqu target node node origin tree null follow could solv problem repeat valu tree allow findacorrespondingnodeofabinarytreeinacloneofthattre
given two integ num k consid set posit integ follow properti unit digit integ k sum integ num return minimum possibl size set 1 set exist note set contain multipl instanc integ sum empti set consid 0 unit digit number rightmost digit number exampl 1 input num 58 k 9 output 2 explan one valid set 949 sum 58 integ unit digit 9 anoth valid set 1939 shown 2 minimum possibl size valid set exampl 2 input num 37 k 2 output 1 explan possibl obtain sum 37 use integ unit digit 2 exampl 3 input num 0 k 7 output 0 explan sum empti set consid 0 constraint 0 num 3000 0 k 9 sumofnumberswithunitsdigitk
given two integ num1 num2 one oper choos integ rang 0 60 subtract 2i num2 num1 return integ denot minimum number oper need make num1 equal 0 imposs make num1 equal 0 return 1 exampl 1 input num1 3 num2 2 output 3 explan make 3 equal 0 follow oper choos 2 substract 22 2 3 3 4 2 1 choos 2 substract 22 2 1 1 4 2 1 choos 0 substract 20 2 1 1 1 2 0 proven 3 minimum number oper need perform exampl 2 input num1 5 num2 7 output 1 explan proven imposs make 5 equal 0 given oper constraint 1 num1 109 109 num2 109 minimumoperationstomaketheintegerzero
given integ array num return true partit array two subset sum element subset equal fals otherwis exampl 1 input num 15115 output true explan array partit 1 5 5 11 exampl 2 input num 1235 output fals explan array partit equal sum subset constraint 1 numslength 200 1 numsi 100 partitionequalsubsetsum
complement integ integ get flip 0s 1s 1s 0s binari represent exampl integ 5 101 binari complement 010 integ 2 given integ n return complement exampl 1 input n 5 output 2 explan 5 101 binari complement 010 binari 2 base10 exampl 2 input n 7 output 0 explan 7 111 binari complement 000 binari 0 base10 exampl 3 input n 10 output 5 explan 10 1010 binari complement 0101 binari 5 base10 constraint 0 n 109 note question 476 httpsleetcodecomproblemsnumbercompl complementofbase10integ
given 0index integ array num integ pivot rearrang num follow condit satisfi everi element less pivot appear everi element greater pivot everi element equal pivot appear element less greater pivot rel order element less pivot element greater pivot maintain formal consid everi pi pj pi new posit ith element pj new posit jth element element less pivot j numsi pivot numsj pivot pi pj similarli element greater pivot j numsi pivot numsj pivot pi pj return num rearrang exampl 1 input num 91251014310 pivot 10 output 95310101214 explan element 9 5 3 less pivot left side array element 12 14 greater pivot right side array rel order element less greater pivot also maintain 9 5 3 12 14 respect order exampl 2 input num 3432 pivot 2 output 3243 explan element 3 less pivot left side array element 4 3 greater pivot right side array rel order element less greater pivot also maintain 3 4 3 respect order constraint 1 numslength 105 106 numsi 106 pivot equal element num partitionarrayaccordingtogivenpivot
given two integ array nums1 nums2 return array intersect element result must appear mani time show array may return result order exampl 1 input nums1 1221 nums2 22 output 22 exampl 2 input nums1 495 nums2 94984 output 49 explan 94 also accept constraint 1 nums1length nums2length 1000 0 nums1i nums2i 1000 follow given array alreadi sort would optim algorithm nums1 size small compar nums2 size algorithm better element nums2 store disk memori limit load element memori intersectionoftwoarraysii
given posit integ n repres number node direct acycl graph dag node number 0 n 1 inclus also given 2d integ array edg edgesi fromi toi denot unidirect edg fromi toi graph return list answer answeri list ancestor ith node sort ascend order node u ancestor anoth node v u reach v via set edg exampl 1 input n 8 edgelist 030413242735363746 output 0102013012340123 explan diagram repres input graph node 0 1 2 ancestor node 3 two ancestor 0 1 node 4 two ancestor 0 2 node 5 three ancestor 0 1 3 node 6 five ancestor 0 1 2 3 4 node 7 four ancestor 0 1 2 3 exampl 2 input n 5 edgelist 01020304121314232434 output 0010120123 explan diagram repres input graph node 0 ancestor node 1 one ancestor 0 node 2 two ancestor 0 1 node 3 three ancestor 0 1 2 node 4 four ancestor 0 1 2 3 constraint 1 n 1000 0 edgeslength min2000 n n 1 2 edgesilength 2 0 fromi toi n 1 fromi toi duplic edg graph direct acycl allancestorsofanodeinadirectedacyclicgraph
given 0index array num consist n posit integ array num call altern numsi 2 numsi 2 n 1 numsi 1 numsi 1 n 1 one oper choos index chang numsi posit integ return minimum number oper requir make array altern exampl 1 input num 313243 output 3 explan one way make array altern convert 313131 number oper requir case 3 proven possibl make array altern less 3 oper exampl 2 input num 12222 output 2 explan one way make array altern convert 12121 number oper requir case 2 note array convert 22222 case nums0 nums1 violat condit altern array constraint 1 numslength 105 1 numsi 105 minimumoperationstomakethearrayaltern
design hashset without use builtin hash tabl librari implement myhashset class void addkey insert valu key hashset bool containskey return whether valu key exist hashset void removekey remov valu key hashset key exist hashset noth exampl 1 input myhashset add add contain contain add contain remov contain 1 2 1 3 2 2 2 2 output null null null true fals null true null fals explan myhashset myhashset new myhashset myhashsetadd1 set 1 myhashsetadd2 set 1 2 myhashsetcontains1 return true myhashsetcontains3 return fals found myhashsetadd2 set 1 2 myhashsetcontains2 return true myhashsetremove2 set 1 myhashsetcontains2 return fals alreadi remov constraint 0 key 106 104 call made add remov contain designhashset
given 0index integ array num integ k initi stand index 0 one move jump k step forward without go outsid boundari array jump index index rang 1 minn 1 k inclus want reach last index array index n 1 score sum numsj index j visit array return maximum score get exampl 1 input num 112473 k 2 output 7 explan choos jump form subsequ 1143 underlin sum 7 exampl 2 input num 1052403 k 3 output 17 explan choos jump form subsequ 1043 underlin sum 17 exampl 3 input num 152041363 k 2 output 0 constraint 1 numslength k 105 104 numsi 104 jumpgamevi
given array distinct integ num target integ target return number possibl combin add target test case gener answer fit 32bit integ exampl 1 input num 123 target 4 output 7 explan possibl combin way 1 1 1 1 1 1 2 1 2 1 1 3 2 1 1 2 2 3 1 note differ sequenc count differ combin exampl 2 input num 9 target 3 output 0 constraint 1 numslength 200 1 numsi 1000 element num uniqu 1 target 1000 follow neg number allow given array chang problem limit need add question allow neg number combinationsumiv
given binari tree root node x tree name good path root x node valu greater x return number good node binari tree exampl 1 input root 3143null15 output 4 explan node blue good root node 3 alway good node node 4 34 maximum valu path start root node 5 345 maximum valu path node 3 313 maximum valu path exampl 2 input root 33null42 output 3 explan node 2 3 3 2 good 3 higher exampl 3 input root 1 output 1 explan root consid good constraint number node binari tree rang 1 105 node valu 104 104 countgoodnodesinbinarytre
given x n integ matrix mat integ target choos one integ row matrix absolut differ target sum chosen element minim return minimum absolut differ absolut differ two number b absolut valu b exampl 1 input mat 123456789 target 13 output 0 explan one possibl choic choos 1 first row choos 5 second row choos 7 third row sum chosen element 13 equal target absolut differ 0 exampl 2 input mat 123 target 100 output 94 explan best possibl choic choos 1 first row choos 2 second row choos 3 third row sum chosen element 6 absolut differ 94 exampl 3 input mat 12987 target 6 output 1 explan best choic choos 7 first row absolut differ 1 constraint matlength n matilength 1 n 70 1 matij 70 1 target 800 minimizethedifferencebetweentargetandchosenel
given n x n grid place 1 x 1 x 1 cube axisalign x z axe valu v gridij repres tower v cube place top cell j view project cube onto xy yz zx plane project like shadow map 3dimension figur 2dimension plane view shadow look cube top front side return total area three project exampl 1 input grid 1234 output 17 explan three project shadow shape made axisalign plane exampl 2 input grid 2 output 5 exampl 3 input grid 1002 output 8 constraint n gridlength gridilength 1 n 50 0 gridij 50 projectionareaof3dshap
given two posit integ array num numsdivid delet number element num return minimum number delet smallest element num divid element numsdivid possibl return 1 note integ x divid x 0 exampl 1 input num 23243 numsdivid 969315 output 2 explan smallest element 23243 2 divid element numsdivid use 2 delet delet element num equal 2 make num 343 smallest element 343 3 divid element numsdivid shown 2 minimum number delet need exampl 2 input num 436 numsdivid 82610 output 1 explan want smallest element num divid element numsdivid way delet element num allow constraint 1 numslength numsdividelength 105 1 numsi numsdividei 109 minimumdeletionstomakearraydivis
n pile coin tabl pile consist posit number coin assort denomin one move choos coin top pile remov add wallet given list pile pilesi list integ denot composit ith pile top bottom posit integ k return maximum total valu coin wallet choos exactli k coin optim exampl 1 input pile 11003789 k 2 output 101 explan diagram show differ way choos k coin maximum total obtain 101 exampl 2 input pile 100100100100100100111111700 k 7 output 706 explan maximum total obtain choos coin last pile constraint n pileslength 1 n 1000 1 pilesij 105 1 k sumpilesilength 2000 maximumvalueofkcoinsfrompil
given two integ array person time elect ith vote cast personsi time timesi queri time find person lead elect time vote cast time count toward queri case tie recent vote among tie candid win implement topvotedcandid class topvotedcandidateint person int time initi object person time array int qint return number person lead elect time accord mention rule exampl 1 input topvotedcandid q q q q q q 0 1 1 0 0 1 0 0 5 10 15 20 25 30 3 12 25 15 24 8 output null 0 1 1 0 0 1 explan topvotedcandid topvotedcandid new topvotedcandidate0 1 1 0 0 1 0 0 5 10 15 20 25 30 topvotedcandidateq3 return 0 time 3 vote 0 0 lead topvotedcandidateq12 return 1 time 12 vote 011 1 lead topvotedcandidateq25 return 1 time 25 vote 011001 1 lead tie go recent vote topvotedcandidateq15 return 0 topvotedcandidateq24 return 0 topvotedcandidateq8 return 1 constraint 1 personslength 5000 timeslength personslength 0 personsi personslength 0 timesi 109 time sort strictli increas order times0 109 104 call made q onlineelect
lemonad stand lemonad cost 5 custom stand queue buy order one time order specifi bill custom buy one lemonad pay either 5 10 20 bill must provid correct chang custom net transact custom pay 5 note chang hand first given integ array bill billsi bill ith custom pay return true provid everi custom correct chang fals otherwis exampl 1 input bill 5551020 output true explan first 3 custom collect three 5 bill order fourth custom collect 10 bill give back 5 fifth custom give 10 bill 5 bill sinc custom got correct chang output true exampl 2 input bill 55101020 output fals explan first two custom order collect two 5 bill next two custom order collect 10 bill give back 5 bill last custom give chang 15 back two 10 bill sinc everi custom receiv correct chang answer fals constraint 1 billslength 105 billsi either 5 10 20 lemonadechang
given string string array dictionari return longest string dictionari form delet given string charact one possibl result return longest word smallest lexicograph order possibl result return empti string exampl 1 input abpcplea dictionari aleapplemonkeyplea output appl exampl 2 input abpcplea dictionari abc output constraint 1 slength 1000 1 dictionarylength 1000 1 dictionaryilength 1000 dictionaryi consist lowercas english letter longestwordindictionarythroughdelet
given array num consist posit integ gcd sequenc number defin greatest integ divid number sequenc evenli exampl gcd sequenc 4616 2 subsequ array sequenc form remov element possibl none array exampl 2510 subsequ 121241510 return number differ gcd among nonempti subsequ num exampl 1 input num 6103 output 5 explan figur show nonempti subsequ gcd differ gcd 6 10 3 2 1 exampl 2 input num 5154056 output 7 constraint 1 numslength 105 1 numsi 2 105 numberofdifferentsubsequencesgcd
sequenc number call arithmet progress differ two consecut element given array number arr return true array rearrang form arithmet progress otherwis return fals exampl 1 input arr 351 output true explan reorder element 135 531 differ 2 2 respect consecut element exampl 2 input arr 124 output fals explan way reorder element obtain arithmet progress constraint 2 arrlength 1000 106 arri 106 canmakearithmeticprogressionfromsequ
given x n matrix board cell battleship x empti return number battleship board battleship place horizont vertic board word made shape 1 x k 1 row k column k x 1 k row 1 column k size least one horizont vertic cell separ two battleship ie adjac battleship exampl 1 input board xxxx output 2 exampl 2 input board output 0 constraint boardlength n boardilength 1 n 200 boardij either x follow could onepass use o1 extra memori without modifi valu board battleshipsinaboard
browser one tab start homepag visit anoth url get back histori number step move forward histori number step implement browserhistori class browserhistorystr homepag initi object homepag browser void visitstr url visit url current page clear forward histori string backint step move step back histori return x step histori step x return x step return current url move back histori step string forwardint step move step forward histori forward x step histori step x forward x step return current url forward histori step exampl input browserhistoryvisitvisitvisitbackbackforwardvisitforwardbackback leetcodecomgooglecomfacebookcomyoutubecom111linkedincom227 output nullnullnullnullfacebookcomgooglecomfacebookcomnulllinkedincomgooglecomleetcodecom explan browserhistori browserhistori new browserhistoryleetcodecom browserhistoryvisitgooglecom leetcodecom visit googlecom browserhistoryvisitfacebookcom googlecom visit facebookcom browserhistoryvisityoutubecom facebookcom visit youtubecom browserhistoryback1 youtubecom move back facebookcom return facebookcom browserhistoryback1 facebookcom move back googlecom return googlecom browserhistoryforward1 googlecom move forward facebookcom return facebookcom browserhistoryvisitlinkedincom facebookcom visit linkedincom browserhistoryforward2 linkedincom move forward step browserhistoryback2 linkedincom move back two step facebookcom googlecom return googlecom browserhistoryback7 googlecom move back one step leetcodecom return leetcodecom constraint 1 homepagelength 20 1 urllength 20 1 step 100 homepag url consist lower case english letter 5000 call made visit back forward designbrowserhistori
design implement circular queue circular queue linear data structur oper perform base fifo first first principl last posit connect back first posit make circl also call ring buffer one benefit circular queue make use space front queue normal queue queue becom full insert next element even space front queue use circular queue use space store new valu implement mycircularqueu class mycircularqueuek initi object size queue k int front get front item queue queue empti return 1 int rear get last item queue queue empti return 1 boolean enqueueint valu insert element circular queue return true oper success boolean dequeu delet element circular queue return true oper success boolean isempti check whether circular queue empti boolean isful check whether circular queue full must solv problem without use builtin queue data structur program languag exampl 1 input mycircularqueu enqueu enqueu enqueu enqueu rear isful dequeu enqueu rear 3 1 2 3 4 4 output null true true true fals 3 true true true 4 explan mycircularqueu mycircularqueu new mycircularqueue3 mycircularqueueenqueue1 return true mycircularqueueenqueue2 return true mycircularqueueenqueue3 return true mycircularqueueenqueue4 return fals mycircularqueuerear return 3 mycircularqueueisful return true mycircularqueuedequeu return true mycircularqueueenqueue4 return true mycircularqueuerear return 4 constraint 1 k 1000 0 valu 1000 3000 call made enqueu dequeu front rear isempti isful designcircularqueu
given string integ k letter letter integ repetit return lexicograph smallest subsequ length k letter letter appear least repetit time test case gener letter appear least repetit time subsequ string deriv anoth string delet charact without chang order remain charact string lexicograph smaller string b first posit b differ string letter appear earlier alphabet correspond letter b exampl 1 input leet k 3 letter e repetit 1 output eet explan four subsequ length 3 letter e appear least 1 time lee leet let leet let leet eet leet lexicograph smallest subsequ among eet exampl 2 input leetcod k 4 letter e repetit 2 output ecd explan ecd lexicograph smallest subsequ length 4 letter e appear least 2 time exampl 3 input bb k 2 letter b repetit 2 output bb explan bb subsequ length 2 letter b appear least 2 time constraint 1 repetit k slength 5 104 consist lowercas english letter letter lowercas english letter appear least repetit time smallestklengthsubsequencewithoccurrencesofalett
given integ x return true x palindrom fals otherwis exampl 1 input x 121 output true explan 121 read 121 left right right left exampl 2 input x 121 output fals explan left right read 121 right left becom 121 therefor palindrom exampl 3 input x 10 output fals explan read 01 right left therefor palindrom constraint 231 x 231 1 follow could solv without convert integ string palindromenumb
given undirect graph defin integ n number node 2d integ array edg edg graph edgesi ui vi indic undirect edg ui vi also given integ array queri let incidenta b defin number edg connect either node b answer jth queri number pair node b satisfi follow condit b incidenta b queriesj return array answer answerslength querieslength answersj answer jth queri note multipl edg two node exampl 1 input n 4 edg 1224132321 queri 23 output 65 explan calcul incidenta b shown tabl answer queri follow answers0 6 pair incidenta b valu greater 2 answers1 5 pair except 3 4 incidenta b valu greater 3 exampl 2 input n 5 edg 1515342513512325 queri 12345 output 1010986 constraint 2 n 2 104 1 edgeslength 105 1 ui vi n ui vi 1 querieslength 20 0 queriesj edgeslength countpairsofnod
2d plane place n stone integ coordin point coordin point may one stone stone remov share either row column anoth stone remov given array stone length n stonesi xi yi repres locat ith stone return largest possibl number stone remov exampl 1 input stone 000110122122 output 5 explan one way remov 5 stone follow 1 remov stone 22 share row 21 2 remov stone 21 share column 01 3 remov stone 12 share row 10 4 remov stone 10 share column 00 5 remov stone 01 share row 00 stone 00 remov sinc share rowcolumn anoth stone still plane exampl 2 input stone 0002112022 output 3 explan one way make 3 move follow 1 remov stone 22 share row 20 2 remov stone 20 share column 00 3 remov stone 02 share row 00 stone 00 11 remov sinc share rowcolumn anoth stone still plane exampl 3 input stone 00 output 0 explan 00 stone plane remov constraint 1 stoneslength 1000 0 xi yi 104 two stone coordin point moststonesremovedwithsameroworcolumn
given integ array rank repres rank mechan ranksi rank ith mechan mechan rank r repair n car r n2 minut also given integ car repres total number car wait garag repair return minimum time taken repair car note mechan repair car simultan exampl 1 input rank 4231 car 10 output 16 explan first mechan repair two car time requir 4 2 2 16 minut second mechan repair two car time requir 2 2 2 8 minut third mechan repair two car time requir 3 2 2 12 minut fourth mechan repair four car time requir 1 4 4 16 minut prove car repair less 16 minut exampl 2 input rank 518 car 6 output 16 explan first mechan repair one car time requir 5 1 1 5 minut second mechan repair four car time requir 1 4 4 16 minut third mechan repair one car time requir 8 1 1 8 minut prove car repair less 16 minut constraint 1 rankslength 105 1 ranksi 100 1 car 106 minimumtimetorepaircar
given integ n return binari string repres represent base 2 note return string lead zero unless string 0 exampl 1 input n 2 output 110 explant 22 21 2 exampl 2 input n 3 output 111 explant 22 21 20 3 exampl 3 input n 4 output 100 explant 22 4 constraint 0 n 109 converttobase2
given array log log spacedelimit string word first word identifi two type log letterlog word except identifi consist lowercas english letter digitlog word except identifi consist digit reorder log letterlog come digitlog letterlog sort lexicograph content content sort lexicograph identifi digitlog maintain rel order return final order log exampl 1 input log dig1 8 1 5 1let1 art candig2 3 6let2 kit diglet3 art zero output let1 art canlet3 art zerolet2 kit digdig1 8 1 5 1dig2 3 6 explan letterlog content differ order art art zero kit dig digitlog rel order dig1 8 1 5 1 dig2 3 6 exampl 2 input log a1 9 2 3 1g1 act carzo4 4 7ab1 key doga8 act zoo output g1 act cara8 act zooab1 key doga1 9 2 3 1zo4 4 7 constraint 1 logslength 100 3 logsilength 100 token logsi separ singl space logsi guarante identifi least one word identifi reorderdatainlogfil
stone differ posit xaxi given integ array stone posit stone call stone endpoint stone smallest largest posit one move pick endpoint stone move unoccupi posit longer endpoint stone particular stone say stone 125 move endpoint stone posit 5 sinc move posit 0 3 still keep stone endpoint stone game end make move ie stone three consecut posit return integ array answer length 2 answer0 minimum number move play answer1 maximum number move play exampl 1 input stone 749 output 12 explan move 4 8 one move finish game move 9 5 4 6 two move finish game exampl 2 input stone 654310 output 23 explan move 3 8 10 7 finish game move 3 7 4 8 5 9 finish game notic move 10 2 finish game would illeg move constraint 3 stoneslength 104 1 stonesi 109 valu stone uniqu movingstonesuntilconsecutiveii
work ball factori n ball number lowlimit highlimit inclus ie n highlimit lowlimit 1 infinit number box number 1 infin job factori put ball box number equal sum digit ball number exampl ball number 321 put box number 3 2 1 6 ball number 10 put box number 1 0 1 given two integ lowlimit highlimit return number ball box ball exampl 1 input lowlimit 1 highlimit 10 output 2 explan box number 1 2 3 4 5 6 7 8 9 10 11 ball count 2 1 1 1 1 1 1 1 1 0 0 box 1 number ball 2 ball exampl 2 input lowlimit 5 highlimit 15 output 2 explan box number 1 2 3 4 5 6 7 8 9 10 11 ball count 1 1 1 1 2 2 1 1 1 0 0 box 5 6 number ball 2 ball exampl 3 input lowlimit 19 highlimit 28 output 2 explan box number 1 2 3 4 5 6 7 8 9 10 11 12 ball count 0 1 1 1 1 1 1 1 1 2 0 0 box 10 number ball 2 ball constraint 1 lowlimit highlimit 105 maximumnumberofballsinabox
four function printfizz print word fizz consol printbuzz print word buzz consol printfizzbuzz print word fizzbuzz consol printnumb print given integ consol given instanc class fizzbuzz four function fizz buzz fizzbuzz number instanc fizzbuzz pass four differ thread thread call fizz output word fizz thread b call buzz output word buzz thread c call fizzbuzz output word fizzbuzz thread call number output integ modifi given class output seri 1 2 fizz 4 buzz ith token 1index seri fizzbuzz divis 3 5 fizz divis 3 5 buzz divis 5 3 divis 3 5 implement fizzbuzz class fizzbuzzint n initi object number n repres length sequenc print void fizzprintfizz call printfizz output fizz void buzzprintbuzz call printbuzz output buzz void fizzbuzzprintfizzbuzz call printfizzbuzz output fizzbuzz void numberprintnumb call printnumb output number exampl 1 input n 15 output 12fizz4buzzfizz78fizzbuzz11fizz1314fizzbuzz exampl 2 input n 5 output 12fizz4buzz constraint 1 n 50 fizzbuzzmultithread
given root node binari search tree two integ low high return sum valu node valu inclus rang low high exampl 1 input root 1051537null18 low 7 high 15 output 32 explan node 7 10 15 rang 7 15 7 10 15 32 exampl 2 input root 105153713181null6 low 6 high 10 output 23 explan node 6 7 10 rang 6 10 6 7 10 23 constraint number node tree rang 1 2 104 1 nodev 105 1 low high 105 nodev uniqu rangesumofbst
forest unknown number rabbit ask n rabbit mani rabbit color collect answer integ array answer answersi answer ith rabbit given array answer return minimum number rabbit could forest exampl 1 input answer 112 output 5 explan two rabbit answer 1 could color say red rabbit answer 2 cant red answer would inconsist say rabbit answer 2 blue 2 blue rabbit forest didnt answer array smallest possibl number rabbit forest therefor 5 3 answer plu 2 didnt exampl 2 input answer 101010 output 11 constraint 1 answerslength 1000 0 answersi 1000 rabbitsinforest
gang thiev plan rob bank given 0index integ array secur securityi number guard duti ith day day number start 0 also given integ time ith day good day rob bank least time day ith day number guard bank time day nonincreas number guard bank time day nondecreas formal mean day good day rob bank securityi time securityi time 1 securityi securityi time 1 securityi time return list day 0index good day rob bank order day return matter exampl 1 input secur 5333562 time 2 output 23 explan day 2 security0 security1 security2 security3 security4 day 3 security1 security2 security3 security4 security5 day satisfi condit day 2 3 good day rob bank exampl 2 input secur 11111 time 0 output 01234 explan sinc time equal 0 everi day good day rob bank return everi day exampl 3 input secur 123456 time 2 output explan day 2 day nonincreas number guard thu day good day rob bank return empti list constraint 1 securitylength 105 0 securityi time 105 findgooddaystorobthebank
given integ n return number prime number strictli less n exampl 1 input n 10 output 4 explan 4 prime number less 10 2 3 5 7 exampl 2 input n 0 output 0 exampl 3 input n 1 output 0 constraint 0 n 5 106 countprim
given array price pricesi price given stock ith day find maximum profit achiev may complet mani transact like ie buy one sell one share stock multipl time follow restrict sell stock buy stock next day ie cooldown one day note may engag multipl transact simultan ie must sell stock buy exampl 1 input price 12302 output 3 explan transact buy sell cooldown buy sell exampl 2 input price 1 output 0 constraint 1 priceslength 5000 0 pricesi 1000 besttimetobuyandsellstockwithcooldown
defin convers array conver array arr follow converi arri maxarr0i maxarr0i maximum valu arrj 0 j also defin score array arr sum valu convers array arr given 0index integ array num length n return array an length n ansi score prefix nums0i exampl 1 input num 237510 output 410243656 explan prefix 2 convers array 4 henc score 4 prefix 2 3 convers array 4 6 henc score 10 prefix 2 3 7 convers array 4 6 14 henc score 24 prefix 2 3 7 5 convers array 4 6 14 12 henc score 36 prefix 2 3 7 5 10 convers array 4 6 14 12 20 henc score 56 exampl 2 input num 1124816 output 248163264 explan prefix 1 convers array 2 henc score 2 prefix 1 1 convers array 2 2 henc score 4 prefix 1 1 2 convers array 2 2 4 henc score 8 prefix 1 1 2 4 convers array 2 2 4 8 henc score 16 prefix 1 1 2 4 8 convers array 2 2 4 8 16 henc score 32 prefix 1 1 2 4 8 16 convers array 2 2 4 8 16 32 henc score 64 constraint 1 numslength 105 1 numsi 109 findthescoreofallprefixesofanarray
given 0index 8 x 8 grid board boardrc repres cell r c game board board free cell repres white cell repres w black cell repres b move game consist choos free cell chang color play either white black howev move legal chang cell becom endpoint good line horizont vertic diagon good line line three cell includ endpoint endpoint line one color remain cell middl opposit color cell line free find exampl good line figur given two integ rmove cmove charact color repres color play white black return true chang cell rmove cmove color color legal move fals legal exampl 1 input board bwwwwbbwwwbbbw rmove 4 cmove 3 color b output true explan w b repres color blue white black respect cell rmove cmove mark x two good line chosen cell endpoint annot red rectangl exampl 2 input board bwwwbbwwb rmove 4 cmove 4 color w output fals explan good line chosen cell middl cell good line chosen cell endpoint constraint boardlength boardrlength 8 0 rmove cmove 8 boardrmovecmov color either b w checkifmoveisleg
sentenc string singlespac separ word word consist lowercas letter word uncommon appear exactli one sentenc appear sentenc given two sentenc s1 s2 return list uncommon word may return answer order exampl 1 input s1 appl sweet s2 appl sour output sweetsour exampl 2 input s1 appl appl s2 banana output banana constraint 1 s1length s2length 200 s1 s2 consist lowercas english letter space s1 s2 lead trail space word s1 s2 separ singl space uncommonwordsfromtwosent
given alphanumer string alphanumer string string consist lowercas english letter digit find permut string letter follow anoth letter digit follow anoth digit two adjac charact type return reformat string return empti string imposs reformat string exampl 1 input a0b1c2 output 0a1b2c explan two adjac charact type 0a1b2c a0b1c2 0a1b2c 0c2a1b also valid permut exampl 2 input leetcod output explan leetcod charact separ digit exampl 3 input 1229857369 output explan 1229857369 digit separ charact constraint 1 slength 500 consist lowercas english letter andor digit reformatthestr
farmer rectangular grid land row n column divid unit cell cell either fertil repres 1 barren repres 0 cell outsid grid consid barren pyramid plot land defin set cell follow criteria number cell set greater 1 cell must fertil apex pyramid topmost cell pyramid height pyramid number row cover let r c apex pyramid height h plot compris cell j r r h 1 c r j c r invers pyramid plot land defin set cell similar criteria number cell set greater 1 cell must fertil apex invers pyramid bottommost cell invers pyramid height invers pyramid number row cover let r c apex pyramid height h plot compris cell j r h 1 r c r j c r exampl valid invalid pyramid invers pyramid plot shown black cell indic fertil cell given 0index x n binari matrix grid repres farmland return total number pyramid invers pyramid plot found grid exampl 1 input grid 01101111 output 2 explan 2 possibl pyramid plot shown blue red respect invers pyramid plot grid henc total number pyramid invers pyramid plot 2 0 2 exampl 2 input grid 111111 output 2 explan pyramid plot shown blue invers pyramid plot shown red henc total number plot 1 1 2 exampl 3 input grid 11110111111111101001 output 13 explan 7 pyramid plot 3 shown 2nd 3rd figur 6 invers pyramid plot 2 shown last figur total number plot 7 6 13 constraint gridlength n gridilength 1 n 1000 1 n 105 gridij either 0 1 countfertilepyramidsinaland
given array point pointsi xi yi repres point xy plane return maximum number point lie straight line exampl 1 input point 112233 output 3 exampl 2 input point 113253412314 output 4 constraint 1 pointslength 300 pointsilength 2 104 xi yi 104 point uniqu maxpointsonalin
given two string part perform follow oper occurr substr part remov find leftmost occurr substr part remov return remov occurr part substr contigu sequenc charact string exampl 1 input daabcbaabcbc part abc output dab explan follow oper done daabcbaabcbc remov abc start index 2 dabaabcbc dabaabcbc remov abc start index 4 dababc dababc remov abc start index 3 dab occurr abc exampl 2 input axxxxyyyyb part xy output ab explan follow oper done axxxxyyyyb remov xy start index 4 axxxyyyb axxxyyyb remov xy start index 3 axxyyb axxyyb remov xy start index 2 axyb axyb remov xy start index 1 ab occurr xy constraint 1 slength 1000 1 partlength 1000 part consist lowercas english letter removealloccurrencesofasubstr
given posit integ p consid array num 1index consist integ inclus rang 1 2p 1 binari represent allow follow oper number time choos two element x num choos bit x swap correspond bit correspond bit refer bit posit integ exampl x 1101 0011 swap 2nd bit right x 1111 0001 find minimum nonzero product num perform oper number time return product modulo 109 7 note answer minimum product modulo oper done exampl 1 input p 1 output 1 explan num 1 one element product equal element exampl 2 input p 2 output 6 explan num 01 10 11 swap would either make product 0 stay thu array product 1 2 3 6 alreadi minim exampl 3 input p 3 output 1512 explan num 001 010 011 100 101 110 111 first oper swap leftmost bit second fifth element result array 001 110 011 100 001 110 111 second oper swap middl bit third fourth element result array 001 110 001 110 001 110 111 array product 1 6 1 6 1 6 7 1512 minimum possibl product constraint 1 p 60 minimumnonzeroproductofthearrayel
given integ n return count number uniqu digit x 0 x 10n exampl 1 input n 2 output 91 explan answer total number rang 0 ≤ x 100 exclud 112233445566778899 exampl 2 input n 0 output 1 constraint 0 n 8 countnumberswithuniquedigit
tribonacci sequenc tn defin follow t0 0 t1 1 t2 1 tn3 tn tn1 tn2 n 0 given n return valu tn exampl 1 input n 4 output 4 explan t3 0 1 1 2 t4 1 1 2 4 exampl 2 input n 25 output 1389537 constraint 0 n 37 answer guarante fit within 32bit integ ie answer 231 1 nthtribonaccinumb
given array integ distanc start point 0 0 xy plane move distance0 meter north distance1 meter west distance2 meter south distance3 meter east word move direct chang counterclockwis return true path cross fals exampl 1 input distanc 2112 output true explan path cross point 0 1 exampl 2 input distanc 1234 output fals explan path cross point exampl 3 input distanc 11121 output true explan path cross point 0 0 constraint 1 distancelength 105 1 distancei 105 selfcross
want schedul list job day job depend ie work ith job finish job j 0 j finish least one task everi day difficulti job schedul sum difficulti day day difficulti day maximum difficulti job done day given integ array jobdifficulti integ difficulti ith job jobdifficultyi return minimum difficulti job schedul find schedul job return 1 exampl 1 input jobdifficulti 654321 2 output 7 explan first day finish first 5 job total difficulti 6 second day finish last job total difficulti 1 difficulti schedul 6 1 7 exampl 2 input jobdifficulti 999 4 output 1 explan finish job per day still free day find schedul given job exampl 3 input jobdifficulti 111 3 output 3 explan schedul one job per day total difficulti 3 constraint 1 jobdifficultylength 300 0 jobdifficultyi 1000 1 10 minimumdifficultyofajobschedul
sql schema tabl mynumb column name type num int primari key tabl may contain duplic row tabl contain integ singl number number appear mynumb tabl write sql queri report largest singl number singl number report null queri result format follow exampl exampl 1 input mynumb tabl num 8 8 3 3 1 4 5 6 output num 6 explan singl number 1 4 5 6 sinc 6 largest singl number return exampl 2 input mynumb tabl num 8 8 7 7 3 3 3 output num null explan singl number input tabl return null biggestsinglenumb
given integ array num consist n element integ k find contigu subarray whose length equal k maximum averag valu return valu answer calcul error less 105 accept exampl 1 input num 11256503 k 4 output 1275000 explan maximum averag 12 5 6 50 4 51 4 1275 exampl 2 input num 5 k 1 output 500000 constraint n numslength 1 k n 105 104 numsi 104 maximumaveragesubarrayi
design eventemitt class interfac similar differ one found nodej event target interfac dom eventemitt allow subscrib event emit eventemitt class follow two method subscrib method take two argument name event string callback function callback function later call event emit event abl multipl listen event emit event multipl callback call order subscrib array result return assum callback pass subscrib referenti ident subscrib method also return object unsubscrib method enabl user unsubscrib call callback remov list subscript undefin return emit method take two argument name event string option array argument pass callback callback subscrib given event return empti array otherwis return array result callback call order subscrib exampl 1 input action eventemitt emit subscrib subscrib emit valu firstev function cb1 return 5 firstev function cb1 return 5 firstev output emittedsubscribedsubscribedemitted56 explan const emitt new eventemitt emitteremitfirstev callback subscrib yet emittersubscribefirstev function cb1 return 5 emittersubscribefirstev function cb2 return 6 emitteremitfirstev 5 6 return output cb1 cb2 exampl 2 input action eventemitt subscrib emit emit valu firstev function cb1arg return argsjoin firstev 123 firstev 346 output subscribedemitted123emitted346 explan note emit method abl accept option array argument const emitt new eventemitt emittersubscribefirstev function cb1arg return argsjoin emitteremitfirstev 1 2 3 123 emitteremitfirstev 3 4 6 346 exampl 3 input action eventemitt subscrib emit unsubscrib emit valu firstev arg argsjoin firstev 123 0 firstev 456 output subscribedemitted123unsubscribed0emit explan const emitt new eventemitt const sub emittersubscribefirstev arg argsjoin emitteremitfirstev 1 2 3 123 subunsubscrib undefin emitteremitfirstev 4 5 6 subscript exampl 4 input action eventemitt subscrib subscrib unsubscrib emit valu firstev x x 1 firstev x x 2 0 firstev 5 output subscribedemitted123unsubscribed0emitted7 explan const emitt new eventemitt const sub1 emittersubscribefirstev x x 1 const sub2 emittersubscribefirstev x x 2 sub1unsubscrib undefin emitteremitfirstev 5 7 constraint 1 actionslength 10 valueslength actionslength test case valid eg dont need handl scenario unsubscrib nonexist subscript 4 differ action eventemitt emit subscrib unsubscrib eventemitt action doesnt take argument emit action take either 1 2 argument first argument name event want emit 2nd argument pass callback function subscrib action take 2 argument first one event name second callback function unsubscrib action take one argument 0index order subscript made eventemitt
given integ array arr length n repres permut integ rang 0 n 1 split arr number chunk ie partit individu sort chunk concaten result equal sort array return largest number chunk make sort array exampl 1 input arr 43210 output 1 explan split two chunk return requir result exampl split 4 3 2 1 0 result 3 4 0 1 2 isnt sort exampl 2 input arr 10234 output 4 explan split two chunk 1 0 2 3 4 howev split 1 0 2 3 4 highest number chunk possibl constraint n arrlength 1 n 10 0 arri n element arr uniqu maxchunkstomakesort
given two string word1 word2 return minimum number oper requir convert word1 word2 follow three oper permit word insert charact delet charact replac charact exampl 1 input word1 hors word2 ro output 3 explan hors rors replac h r rors rose remov r rose ro remov e exampl 2 input word1 intent word2 execut output 5 explan intent inent remov inent enent replac e enent exent replac n x exent exect replac n c exect execut insert u constraint 0 word1length word2length 500 word1 word2 consist lowercas english letter editdist
given integ array num return sum floornumsi numsj pair indic 0 j numslength array sinc answer may larg return modulo 109 7 floor function return integ part divis exampl 1 input num 259 output 10 explan floor2 5 floor2 9 floor5 9 0 floor2 2 floor5 5 floor9 9 1 floor5 2 2 floor9 2 4 floor9 5 1 calcul floor divis everi pair indic array sum exampl 2 input num 7777777 output 49 constraint 1 numslength 105 1 numsi 105 sumofflooredpair
1base binari matrix 0 repres land 1 repres water given integ row col repres number row column matrix respect initi day 0 entir matrix land howev day new cell becom flood water given 1base 2d array cell cellsi ri ci repres ith day cell rith row cith column 1base coordin cover water ie chang 1 want find last day possibl walk top bottom walk land cell start cell top row end cell bottom row travel four cardin direct left right return last day possibl walk top bottom walk land cell exampl 1 input row 2 col 2 cell 11211222 output 2 explan imag depict matrix chang day start day 0 last day possibl cross top bottom day 2 exampl 2 input row 2 col 2 cell 11122122 output 1 explan imag depict matrix chang day start day 0 last day possibl cross top bottom day 1 exampl 3 input row 3 col 3 cell 122133221113233231 output 3 explan imag depict matrix chang day start day 0 last day possibl cross top bottom day 3 constraint 2 row col 2 104 4 row col 2 104 cellslength row col 1 ri row 1 ci col valu cell uniqu lastdaywhereyoucanstillcross
width sequenc differ maximum minimum element sequenc given array integ num return sum width nonempti subsequ num sinc answer may larg return modulo 109 7 subsequ sequenc deriv array delet element without chang order remain element exampl 3627 subsequ array 0316227 exampl 1 input num 213 output 6 explan subsequ 1 2 3 21 23 13 213 correspond width 0 0 0 1 1 2 2 sum width 6 exampl 2 input num 2 output 0 constraint 1 numslength 105 1 numsi 105 sumofsubsequencewidth
stack glass pyramid first row 1 glass second row 2 glass 100th row glass hold one cup champagn champagn pour first glass top topmost glass full excess liquid pour fall equal glass immedi left right glass becom full excess champagn fall equal left right glass glass bottom row excess champagn fall floor exampl one cup champagn pour top glass full two cup champagn pour two glass second row half full three cup champagn pour two cup becom full 3 full glass total four cup champagn pour third row middl glass half full two outsid glass quarter full pictur pour nonneg integ cup champagn return full jth glass ith row j 0index exampl 1 input pour 1 queryrow 1 queryglass 1 output 000000 explan pour 1 cup champang top glass tower index 0 0 excess liquid glass top glass remain empti exampl 2 input pour 2 queryrow 1 queryglass 1 output 050000 explan pour 2 cup champang top glass tower index 0 0 one cup excess liquid glass index 1 0 glass index 1 1 share excess liquid equal get half cup champang exampl 3 input pour 100000009 queryrow 33 queryglass 17 output 100000 constraint 0 pour 109 0 queryglass queryrow 100 champagnetow
given array num posit integ return longest possibl length array prefix num possibl remov exactli one element prefix everi number appear number occurr remov one element remain element still consid everi appear number number ocurr 0 exampl 1 input num 22115335 output 7 explan subarray 2211533 length 7 remov nums4 5 get 221133 number appear exactli twice exampl 2 input num 1112223334445 output 13 constraint 2 numslength 105 1 numsi 105 maximumequalfrequ
given two integ b return sum two integ without use oper exampl 1 input 1 b 2 output 3 exampl 2 input 2 b 3 output 5 constraint 1000 b 1000 sumoftwointeg
given two sort array distinct integ nums1 nums2 valid path defin follow choos array nums1 nums2 travers index0 travers current array left right read valu present nums1 nums2 allow chang path array one repeat valu consid valid path score defin sum uniqu valu valid path return maximum score obtain possibl valid path sinc answer may larg return modulo 109 7 exampl 1 input nums1 245810 nums2 4689 output 30 explan valid path 245810 24589 24689 246810 start nums1 4689 45810 4589 46810 start nums2 maximum obtain path green 246810 exampl 2 input nums1 13579 nums2 35100 output 109 explan maximum sum obtain path 135100 exampl 3 input nums1 12345 nums2 678910 output 40 explan common element nums1 nums2 maximum sum obtain path 678910 constraint 1 nums1length nums2length 105 1 nums1i nums2i 107 nums1 nums2 strictli increas getthemaximumscor
given x n grid cell one three valu 0 repres empti cell 1 repres fresh orang 2 repres rotten orang everi minut fresh orang 4direct adjac rotten orang becom rotten return minimum number minut must elaps cell fresh orang imposs return 1 exampl 1 input grid 211110011 output 4 exampl 2 input grid 211011101 output 1 explan orang bottom left corner row 2 column 0 never rotten rot happen 4direct exampl 3 input grid 02 output 0 explan sinc alreadi fresh orang minut 0 answer 0 constraint gridlength n gridilength 1 n 10 gridij 0 1 2 rottingorang
sql schema pandan schema tabl tweet column name type tweetid int content varchar sql tweetid primari key tabl tabl contain tweet social media app find id invalid tweet tweet invalid number charact use content tweet strictli greater 15 return result tabl order result format follow exampl exampl 1 input tweet tabl tweetid content 1 vote biden 2 let us make america great output tweetid 2 explan tweet 1 length 14 valid tweet tweet 2 length 32 invalid tweet invalidtweet
given two string b return minimum number time repeat string string b substr imposs b substr repeat return 1 notic string abc repeat 0 time repeat 1 time abc repeat 2 time abcabc exampl 1 input abcd b cdabcdab output 3 explan return 3 repeat three time abcdabcdabcd b substr exampl 2 input b aa output 2 constraint 1 alength blength 104 b consist lowercas english letter repeatedstringmatch
given n x n binari matrix grid return length shortest clear path matrix clear path return 1 clear path binari matrix path topleft cell ie 0 0 bottomright cell ie n 1 n 1 visit cell path 0 adjac cell path 8direct connect ie differ share edg corner length clear path number visit cell path exampl 1 input grid 0110 output 2 exampl 2 input grid 000110110 output 4 exampl 3 input grid 100110110 output 1 constraint n gridlength n gridilength 1 n 100 gridij 0 1 shortestpathinbinarymatrix
binari tree name evenodd meet follow condit root binari tree level index 0 children level index 1 children level index 2 etc everi evenindex level node level odd integ valu strictli increas order left right everi oddindex level node level even integ valu strictli decreas order left right given root binari tree return true binari tree evenodd otherwis return fals exampl 1 input root 11043null791286nullnull2 output true explan node valu level level 0 1 level 1 104 level 2 379 level 3 12862 sinc level 0 2 odd increas level 1 3 even decreas tree evenodd exampl 2 input root 542337 output fals explan node valu level level 0 5 level 1 42 level 2 337 node valu level 2 must strictli increas order tree evenodd exampl 3 input root 591357 output fals explan node valu level 1 even integ constraint number node tree rang 1 105 1 nodev 106 evenoddtre
special binari string binari string follow two properti number 0s equal number 1s everi prefix binari string least mani 1s 0s given special binari string move consist choos two consecut nonempti special substr swap two string consecut last charact first string exactli one index first charact second string return lexicograph largest result string possibl appli mention oper string exampl 1 input 11011000 output 11100100 explan string 10 occur s1 1100 s3 swap lexicograph largest string possibl number swap exampl 2 input 10 output 10 constraint 1 slength 50 si either 0 1 special binari string specialbinarystr
design skiplist without use builtin librari skiplist data structur take ologn time add eras search compar treap redblack tree function perform code length skiplist compar short idea behind skiplist simpl link list exampl skiplist contain 304050607090 want add 80 45 skiplist work way artyom kalinin cc bysa 30 via wikimedia common see mani layer skiplist layer sort link list help top layer add eras search faster proven averag time complex oper ologn space complex see skiplist httpsenwikipediaorgwikiskiplist implement skiplist class skiplist initi object skiplist bool searchint target return true integ target exist skiplist fals otherwis void addint num insert valu num skiplist bool eraseint num remov valu num skiplist return true num exist skiplist noth return fals exist multipl num valu remov one fine note duplic may exist skiplist code need handl situat exampl 1 input skiplist add add add search add search eras eras search 1 2 3 0 4 1 0 1 1 output null null null null fals null true fals true fals explan skiplist skiplist new skiplist skiplistadd1 skiplistadd2 skiplistadd3 skiplistsearch0 return fals skiplistadd4 skiplistsearch1 return true skiplisterase0 return fals 0 skiplist skiplisterase1 return true skiplistsearch1 return fals 1 alreadi eras constraint 0 num target 2 104 5 104 call made search add eras designskiplist
n citi connect number flight given array flight flightsi fromi toi pricei indic flight citi fromi citi toi cost pricei also given three integ src dst k return cheapest price src dst k stop rout return 1 exampl 1 input n 4 flight 0110012100201001360023200 src 0 dst 3 k 1 output 700 explan graph shown optim path 1 stop citi 0 3 mark red cost 100 600 700 note path citi 0123 cheaper invalid use 2 stop exampl 2 input n 3 flight 011001210002500 src 0 dst 2 k 1 output 200 explan graph shown optim path 1 stop citi 0 2 mark red cost 100 100 200 exampl 3 input n 3 flight 011001210002500 src 0 dst 2 k 0 output 500 explan graph shown optim path stop citi 0 2 mark red cost 500 constraint 1 n 100 0 flightslength n n 1 2 flightsilength 3 0 fromi toi n fromi toi 1 pricei 104 multipl flight two citi 0 src dst k n src dst cheapestflightswithinkstop
given two array arr1 arr2 return new array joinedarray object two input array contain id field integ valu joinedarray array form merg arr1 arr2 base id key length joinedarray length uniqu valu id return array sort ascend order base id key given id exist one array singl object id includ result array without modif two object share id properti merg singl object key exist one object singl keyvalu pair includ object key includ object valu object arr2 overrid valu arr1 exampl 1 input arr1 id 1 x 1 id 2 x 9 arr2 id 3 x 5 output id 1 x 1 id 2 x 9 id 3 x 5 explan duplic id arr1 simpli concaten arr2 exampl 2 input arr1 id 1 x 2 3 id 2 x 3 6 arr2 id 2 x 10 20 id 3 x 0 0 output id 1 x 2 3 id 2 x 10 20 id 3 x 0 0 explan two object id1 id3 includ result array without modifict two object id2 merg togeth key arr2 overrid valu arr1 exampl 3 input arr1 id 1 b b 94v 4 3 48 arr2 id 1 b c 84 v 1 3 output id 1 b c 84 v 1 3 48 explan two object id1 merg togeth key b v valu arr2 use sinc key exist arr1 valu taken form arr1 constraint arr1 arr2 valid json array object arr1 arr2 uniqu integ id key 2 jsonstringifyarr1length 106 2 jsonstringifyarr2length 106 jointwoarraysbyid
given array integ arr return true number occurr valu array uniqu fals otherwis exampl 1 input arr 122113 output true explan valu 1 3 occurr 2 2 3 1 two valu number occurr exampl 2 input arr 12 output fals exampl 3 input arr 30131113100 output true constraint 1 arrlength 1000 1000 arri 1000 uniquenumberofoccurr
given string reorder string use follow algorithm pick smallest charact append result pick smallest charact greater last append charact result append repeat step 2 pick charact pick largest charact append result pick largest charact smaller last append charact result append repeat step 5 pick charact repeat step 1 6 pick charact step smallest largest charact appear choos occurr append result return result string sort algorithm exampl 1 input aaaabbbbcccc output abccbaabccba explan step 1 2 3 first iter result abc step 4 5 6 first iter result abccba first iter done aabbcc go back step 1 step 1 2 3 second iter result abccbaabc step 4 5 6 second iter result abccbaabccba exampl 2 input rat output art explan word rat becom art reorder mention algorithm constraint 1 slength 500 consist lowercas english letter increasingdecreasingstr
factori posit integ n product posit integ less equal n exampl factorial10 10 9 8 7 6 5 4 3 2 1 make clumsi factori use integ decreas order swap multipli oper fix rotat oper multipli divid add subtract order exampl clumsy10 10 9 8 7 6 5 4 3 2 1 howev oper still appli use usual order oper arithmet multipl divis step addit subtract step multipl divis step process left right addit divis use floor divis 10 9 8 90 8 11 given integ n return clumsi factori n exampl 1 input n 4 output 7 explan 7 4 3 2 1 exampl 2 input n 10 output 12 explan 12 10 9 8 7 6 5 4 3 2 1 constraint 1 n 104 clumsyfactori
implement lastinfirstout lifo stack use two queue implement stack support function normal stack push top pop empti implement mystack class void pushint x push element x top stack int pop remov element top stack return int top return element top stack boolean empti return true stack empti fals otherwis note must use standard oper queue mean push back peekpop front size empti oper valid depend languag queue may support nativ may simul queue use list dequ doubleend queue long use queue standard oper exampl 1 input mystack push push top pop empti 1 2 output null null null 2 2 fals explan mystack mystack new mystack mystackpush1 mystackpush2 mystacktop return 2 mystackpop return 2 mystackempti return fals constraint 1 x 9 100 call made push pop top empti call pop top valid followup implement stack use one queue implementstackusingqueu
given sort array distinct integ target valu return index target found return index would insert order must write algorithm olog n runtim complex exampl 1 input num 1356 target 5 output 2 exampl 2 input num 1356 target 2 output 1 exampl 3 input num 1356 target 7 output 4 constraint 1 numslength 104 104 numsi 104 num contain distinct valu sort ascend order 104 target 104 searchinsertposit
run preorder depthfirst search df root binari tree node travers output dash depth node output valu node depth node depth immedi child 1 depth root node 0 node one child child guarante left child given output travers travers recov tree return root exampl 1 input travers 1234567 output 1253467 exampl 2 input travers 1234567 output 1253null6null4null7 exampl 3 input travers 14013499088 output 1401null3498890 constraint number node origin tree rang 1 1000 1 nodev 109 recoveratreefrompreordertravers
given two list close interv firstlist secondlist firstlisti starti endi secondlistj startj endj list interv pairwis disjoint sort order return intersect two interv list close interv b b denot set real number x x b intersect two close interv set real number either empti repres close interv exampl intersect 1 3 2 4 2 3 exampl 1 input firstlist 0251013232425 secondlist 1581215242526 output 1255810152324242525 exampl 2 input firstlist 1359 secondlist output constraint 0 firstlistlength secondlistlength 1000 firstlistlength secondlistlength 1 0 starti endi 109 endi starti1 0 startj endj 109 endj startj1 intervallistintersect
sql schema tabl log column name type id int num varchar id primari key tabl id autoincr column write sql queri find number appear least three time consecut return result tabl order queri result format follow exampl exampl 1 input log tabl id num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 output consecutivenum 1 explan 1 number appear consecut least three time consecutivenumb
complex number repres string form realimaginaryi real real part integ rang 100 100 imaginari imaginari part integ rang 100 100 i2 1 given two complex number num1 num2 string return string complex number repres multipl exampl 1 input num1 11i num2 11i output 02i explan 1 1 1 i2 2 2i need convert form 02i exampl 2 input num1 11i num2 11i output 02i explan 1 1 1 i2 2 2i need convert form 02i constraint num1 num2 valid complex number complexnumbermultipl
town n peopl label 1 n rumor one peopl secretli town judg town judg exist town judg trust nobodi everybodi except town judg trust town judg exactli one person satisfi properti 1 2 given array trust trusti ai bi repres person label ai trust person label bi trust relationship exist trust array trust relationship exist return label town judg town judg exist identifi return 1 otherwis exampl 1 input n 2 trust 12 output 2 exampl 2 input n 3 trust 1323 output 3 exampl 3 input n 3 trust 132331 output 1 constraint 1 n 1000 0 trustlength 104 trustilength 2 pair trust uniqu ai bi 1 ai bi n findthetownjudg
given 2d integ array stockpric stockpricesi dayi pricei indic price stock day dayi pricei line chart creat array plot point xy plane xaxi repres day yaxi repres price connect adjac point one exampl shown return minimum number line need repres line chart exampl 1 input stockpric 1726354454637281 output 3 explan diagram repres input xaxi repres day yaxi repres price follow 3 line drawn repres line chart line 1 red 17 44 pass 17 26 35 44 line 2 blue 44 54 line 3 green 54 81 pass 54 63 72 81 shown possibl repres line chart use less 3 line exampl 2 input stockpric 34127823 output 1 explan shown diagram line chart repres singl line constraint 1 stockpriceslength 105 stockpricesilength 2 1 dayi pricei 109 dayi distinct minimumlinestorepresentalinechart
given two integ n k return array integ length n differ everi two consecut digit k may return answer order note integ lead zero integ 02 043 allow exampl 1 input n 3 k 7 output 181292707818929 explan note 070 valid number lead zero exampl 2 input n 2 k 1 output 1012212332344345545665677678878998 constraint 2 n 9 0 k 9 numberswithsameconsecutivediffer
given string one step insert charact index string return minimum number step make palindrom palindrom string one read backward well forward exampl 1 input zzazz output 0 explan string zzazz alreadi palindrom need insert exampl 2 input mbadm output 2 explan string mbdadbm mdbabdm exampl 3 input leetcod output 5 explan insert 5 charact string becom leetcodocteel constraint 1 slength 500 consist lowercas english letter minimuminsertionstepstomakeastringpalindrom
given integ n n room number 0 n 1 given 2d integ array meet meetingsi starti endi mean meet held halfclos time interv starti endi valu starti uniqu meet alloc room follow manner meet take place unus room lowest number avail room meet delay room becom free delay meet durat origin meet room becom unus meet earlier origin start time given room return number room held meet multipl room return room lowest number halfclos interv b interv b includ includ b exampl 1 input n 2 meet 010152734 output 0 explan time 0 room use first meet start room 0 time 1 room 1 use second meet start room 1 time 2 room use third meet delay time 3 room use fourth meet delay time 5 meet room 1 finish third meet start room 1 time period 510 time 10 meet room finish fourth meet start room 0 time period 1011 room 0 1 held 2 meet return 0 exampl 2 input n 3 meet 120210354968 output 1 explan time 1 three room use first meet start room 0 time 2 room 1 2 use second meet start room 1 time 3 room 2 use third meet start room 2 time 4 three room use fourth meet delay time 5 meet room 2 finish fourth meet start room 2 time period 510 time 6 three room use fifth meet delay time 10 meet room 1 2 finish fifth meet start room 1 time period 1012 room 0 held 1 meet room 1 2 held 2 meet return 1 constraint 1 n 100 1 meetingslength 105 meetingsilength 2 0 starti endi 5 105 valu starti uniqu meetingroomsiii
given 0index string block length n blocksi either w b repres color ith block charact w b denot color white black respect also given integ k desir number consecut black block one oper recolor white block becom black block return minimum number oper need least one occurr k consecut black block exampl 1 input block wbbwwbbwbw k 7 output 3 explan one way achiev 7 consecut black block recolor 0th 3rd 4th block block bbbbbbbwbw shown way achiev 7 consecut black block less 3 oper therefor return 3 exampl 2 input block wbwbbbw k 2 output 0 explan chang need made sinc 2 consecut black block alreadi exist therefor return 0 constraint n blockslength 1 n 100 blocksi either w b 1 k n minimumrecolorstogetkconsecutiveblackblock
given array integ arr return true valid mountain array recal arr mountain array arrlength 3 exist 0 arrlength 1 arr0 arr1 arri 1 arri arri arri 1 arrarrlength 1 exampl 1 input arr 21 output fals exampl 2 input arr 355 output fals exampl 3 input arr 0321 output true constraint 1 arrlength 104 0 arri 104 validmountainarray
given integ zero one low high construct string start empti string step perform either follow append charact 0 zero time append charact 1 one time perform number time good string string construct process length low high inclus return number differ good string construct satisfi properti sinc answer larg return modulo 109 7 exampl 1 input low 3 high 3 zero 1 one 1 output 8 explan one possibl valid good string 011 construct follow 0 01 011 binari string 000 111 good string exampl exampl 2 input low 2 high 3 zero 1 one 2 output 5 explan good string 00 11 000 110 011 constraint 1 low high 105 1 zero one low countwaystobuildgoodstr
given two string s1 s2 equal length consist letter x task make two string equal swap two charact belong differ string mean swap s1i s2j return minimum number swap requir make s1 s2 equal return 1 imposs exampl 1 input s1 xx s2 yy output 1 explan swap s10 s21 s1 yx s2 yx exampl 2 input s1 xy s2 yx output 2 explan swap s10 s20 s1 yy s2 xx swap s10 s21 s1 xy s2 xy note swap s10 s11 make s1 equal yx caus swap char differ string exampl 3 input s1 xx s2 xy output 1 constraint 1 s1length s2length 1000 s1length s2length s1 s2 contain x minimumswapstomakestringsequ
given array word size n consist nonempti string defin score string word number string wordsi word prefix wordsi exampl word ab abc cab score ab 2 sinc ab prefix ab abc return array answer size n answeri sum score everi nonempti prefix wordsi note string consid prefix exampl 1 input word abcabbcb output 5432 explan answer string follow abc 3 prefix ab abc 2 string prefix 2 string prefix ab 1 string prefix abc total answer0 2 2 1 5 ab 2 prefix ab 2 string prefix 2 string prefix ab total answer1 2 2 4 bc 2 prefix b bc 2 string prefix b 1 string prefix bc total answer2 2 1 3 b 1 prefix b 2 string prefix b total answer3 2 exampl 2 input word abcd output 4 explan abcd 4 prefix ab abc abcd prefix score one total answer0 1 1 1 1 4 constraint 1 wordslength 1000 1 wordsilength 1000 wordsi consist lowercas english letter sumofprefixscoresofstr
given stream point xy plane design algorithm add new point stream data structur duplic point allow treat differ point given queri point count number way choos three point data structur three point queri point form axisalign squar posit area axisalign squar squar whose edg length either parallel perpendicular xaxi yaxi implement detectsquar class detectsquar initi object empti data structur void addint point add new point point x data structur int countint point count number way form axisalign squar point point x describ exampl 1 input detectsquar add add add count count add count 3 10 11 2 3 2 11 10 14 8 11 2 11 10 output null null null null 1 0 null 2 explan detectsquar detectsquar new detectsquar detectsquaresadd3 10 detectsquaresadd11 2 detectsquaresadd3 2 detectsquarescount11 10 return 1 choos first second third point detectsquarescount14 8 return 0 queri point form squar point data structur detectsquaresadd11 2 ad duplic point allow detectsquarescount11 10 return 2 choos first second third point first third fourth point constraint pointlength 2 0 x 1000 3000 call total made add count detectsquar
given hour list number hour work per day given employe day consid tire day number hour work strictli greater 8 wellperform interv interv day number tire day strictli larger number nontir day return length longest wellperform interv exampl 1 input hour 9960669 output 3 explan longest wellperform interv 996 exampl 2 input hour 666 output 0 constraint 1 hourslength 104 0 hoursi 16 longestwellperforminginterv
n peopl person uniqu id 0 n1 given array watchedvideo friend watchedvideosi friendsi contain list watch video list friend respect person id level 1 video watch video friend level 2 video watch video friend friend gener level k video watch video peopl shortest path exactli equal k given id level video return list video order frequenc increas video frequenc order alphabet least greatest exampl 1 input watchedvideo abcbcd friend 12030312 id 0 level 1 output bc explan id 0 green color figur friend yellow color figur person id 1 watchedvideo c person id 2 watchedvideo bc frequenc watchedvideo friend b 1 c 2 exampl 2 input watchedvideo abcbcd friend 12030312 id 0 level 2 output explan id 0 green color figur friend friend person id 3 yellow color figur constraint n watchedvideoslength friendslength 2 n 100 1 watchedvideosilength 100 1 watchedvideosijlength 8 0 friendsilength n 0 friendsij n 0 id n 1 level n friendsi contain j friendsj contain getwatchedvideosbyyourfriend
n build number 0 n 1 build number employe transfer season employe want chang build resid given array request requestsi fromi toi repres employe request transfer build fromi build toi build full list request achiev build net chang employe transfer zero mean number employe leav equal number employe move exampl n 3 two employe leav build 0 one leav build 1 one leav build 2 two employe move build 0 one employe move build 1 one employe move build 2 return maximum number achiev request exampl 1 input n 5 request 011001122034 output 5 explant let see request build 0 employe x want move build 1 build 1 employe b want move build 2 0 respect build 2 employe z want move build 0 build 3 employe c want move build 4 build 4 dont request achiev request user x b swap place achiev request user z swap place 3 build exampl 2 input n 3 request 001221 output 3 explant let see request build 0 employe x want stay build 0 build 1 employe want move build 2 build 2 employe z want move build 1 achiev request exampl 3 input n 4 request 03311220 output 4 constraint 1 n 20 1 requestslength 16 requestsilength 2 0 fromi toi n maximumnumberofachievabletransferrequest
given array integ num integ k return number contigu subarray product element subarray strictli less k exampl 1 input num 10526 k 100 output 8 explan 8 subarray product less 100 10 5 2 6 10 5 5 2 2 6 5 2 6 note 10 5 2 includ product 100 strictli less k exampl 2 input num 123 k 0 output 0 constraint 1 numslength 3 104 1 numsi 1000 0 k 106 subarrayproductlessthank
given root binari tree return inord travers node valu exampl 1 input root 1null23 output 132 exampl 2 input root output exampl 3 input root 1 output 1 constraint number node tree rang 0 100 100 nodev 100 follow recurs solut trivial could iter binarytreeinordertravers
sql schema tabl custom column name type customerid int name varchar visitedon date amount int customerid visitedon primari key tabl tabl contain data custom transact restaur visitedon date custom id customerid visit restaur amount total paid custom restaur owner want analyz possibl expans least one custom everi day write sql queri comput move averag much custom paid seven day window ie current day 6 day averageamount round two decim place return result tabl order visitedon ascend order queri result format follow exampl exampl 1 input custom tabl customerid name visitedon amount 1 jhon 20190101 100 2 daniel 20190102 110 3 jade 20190103 120 4 khale 20190104 130 5 winston 20190105 110 6 elvi 20190106 140 7 anna 20190107 150 8 maria 20190108 80 9 jaze 20190109 110 1 jhon 20190110 130 3 jade 20190110 150 output visitedon amount averageamount 20190107 860 12286 20190108 840 120 20190109 840 120 20190110 1000 14286 explan 1st move averag 20190101 20190107 averageamount 100 110 120 130 110 140 1507 12286 2nd move averag 20190102 20190108 averageamount 110 120 130 110 140 150 807 120 3rd move averag 20190103 20190109 averageamount 120 130 110 140 150 80 1107 120 4th move averag 20190104 20190110 averageamount 130 110 140 150 80 110 130 1507 14286 restaurantgrowth
countri infinit number lake initi lake empti rain nth lake nth lake becom full water rain lake full water flood goal avoid flood lake given integ array rain rainsi 0 mean rain rainsi lake rainsi 0 mean rain day choos one lake day dri return array an anslength rainslength ansi 1 rainsi 0 ansi lake choos dri ith day rainsi 0 multipl valid answer return imposs avoid flood return empti array notic chose dri full lake becom empti chose dri empti lake noth chang exampl 1 input rain 1234 output 1111 explan first day full lake 1 second day full lake 12 third day full lake 123 fourth day full lake 1234 there day dri lake flood lake exampl 2 input rain 120021 output 112111 explan first day full lake 1 second day full lake 12 third day dri lake 2 full lake 1 fourth day dri lake 1 full lake fifth day full lake 2 sixth day full lake 12 easi scenario floodfre 111211 anoth accept scenario exampl 3 input rain 12012 output explan second day full lake 12 dri one lake third day rain lake 12 easi prove matter lake choos dri 3rd day one flood constraint 1 rainslength 105 0 rainsi 109 avoidfloodinthec
given two nonempti link list repres two nonneg integ digit store revers order node contain singl digit add two number return sum link list may assum two number contain lead zero except number 0 exampl 1 input l1 243 l2 564 output 708 explan 342 465 807 exampl 2 input l1 0 l2 0 output 0 exampl 3 input l1 9999999 l2 9999 output 89990001 constraint number node link list rang 1 100 0 nodev 9 guarante list repres number lead zero addtwonumb
n room need visit label 0 n 1 day label start 0 go visit one room day initi day 0 visit room 0 order visit room come day determin follow rule given 0index array nextvisit length n assum day visit room room odd number time includ current visit next day visit room lower equal room number specifi nextvis 0 nextvis room even number time includ current visit next day visit room 1 mod n return label first day room shown day exist sinc answer may larg return modulo 109 7 exampl 1 input nextvisit 00 output 2 explan day 0 visit room 0 total time room 0 1 odd next day visit room nextvisit0 0 day 1 visit room 0 total time room 0 2 even next day visit room 0 1 mod 2 1 day 2 visit room 1 first day room exampl 2 input nextvisit 002 output 6 explan room visit order day 0010012 day 6 first day room exampl 3 input nextvisit 0120 output 6 explan room visit order day 0011223 day 6 first day room constraint n nextvisitlength 2 n 105 0 nextvis firstdaywhereyouhavebeeninalltheroom
given two 0index array nums1 nums2 2d array queri queri three type queri queri type 1 queriesi 1 l r flip valu 0 1 1 0 nums1 index l index r l r 0index queri type 2 queriesi 2 p 0 everi index 0 n set nums2i nums2i nums1i p queri type 3 queriesi 3 0 0 find sum element nums2 return array contain answer third type queri exampl 1 input nums1 101 nums2 000 queri 111210300 output 3 explan first queri nums1 becom 111 second queri nums2 becom 111 answer third queri 3 thu 3 return exampl 2 input nums1 1 nums2 5 queri 200300 output 5 explan first queri nums2 remain 5 answer second queri 5 thu 5 return constraint 1 nums1lengthnums2length 105 nums1length nums2length 1 querieslength 105 queriesilength 3 0 l r nums1length 1 0 p 106 0 nums1i 1 0 nums2i 109 handlingsumqueriesafterupd
given array integ num sort ascend order integ target write function search target num target exist return index otherwis return 1 must write algorithm olog n runtim complex exampl 1 input num 1035912 target 9 output 4 explan 9 exist num index 4 exampl 2 input num 1035912 target 2 output 1 explan 2 exist num return 1 constraint 1 numslength 104 104 numsi target 104 integ num uniqu num sort ascend order binarysearch
row hous small citi hous must paint one n color label 1 n hous paint last summer paint neighborhood maxim group continu hous paint color exampl hous 12233211 contain 5 neighborhood 1 22 33 2 11 given array hous x n matrix cost integ target housesi color hous 0 hous paint yet costij cost paint hous color j 1 return minimum cost paint remain hous way exactli target neighborhood possibl return 1 exampl 1 input hous 00000 cost 11010110111051 5 n 2 target 3 output 9 explan paint hous way 12211 array contain target 3 neighborhood 1 22 11 cost paint hous 1 1 1 1 5 9 exampl 2 input hous 02120 cost 11010110111051 5 n 2 target 3 output 11 explan hous alreadi paint paint hous way 22122 array contain target 3 neighborhood 22 1 22 cost paint first last hous 10 1 11 exampl 3 input hous 3123 cost 111111111111 4 n 3 target 3 output 1 explan hous alreadi paint total 4 neighborhood 3123 differ target 3 constraint houseslength costlength n costilength 1 100 1 n 20 1 target 0 housesi n 1 costij 104 painthouseiii
given integ array num integ threshold find subarray num length k everi element subarray greater threshold k return size subarray subarray return 1 subarray contigu nonempti sequenc element within array exampl 1 input num 13431 threshold 6 output 3 explan subarray 343 size 3 everi element greater 6 3 2 note valid subarray exampl 2 input num 65658 threshold 7 output 1 explan subarray 8 size 1 8 7 1 7 1 return note subarray 65 size 2 everi element greater 7 2 35 similarli subarray 656 6565 65658 also satisfi given condit therefor 2 3 4 5 may also return constraint 1 numslength 105 1 numsi threshold 109 subarraywithelementsgreaterthanvaryingthreshold
undirect tree n node label 0 n 1 root node 0 given 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree everi node gate also given array even integ amount amounti repres price need open gate node amounti neg cash reward obtain open gate node otherwis game goe follow initi alic node 0 bob node bob everi second alic bob move adjac node alic move toward leaf node bob move toward node 0 everi node along path alic bob either spend money open gate node accept reward note gate alreadi open price requir cash reward alic bob reach node simultan share pricereward open gate word price open gate c alic bob pay c 2 similarli reward gate c receiv c 2 alic reach leaf node stop move similarli bob reach node 0 stop move note event independ return maximum net incom alic travel toward optim leaf node exampl 1 input edg 01121334 bob 3 amount 24246 output 6 explan diagram repres given tree game goe follow alic initi node 0 bob node 3 open gate respect node alic net incom 2 alic bob move node 1 sinc reach simultan open gate togeth share reward alic net incom becom 2 4 2 0 alic move node 3 sinc bob alreadi open gate alic incom remain unchang bob move node 0 stop move alic move node 4 open gate net incom becom 0 6 6 neither alic bob make move game end possibl alic get higher net incom exampl 2 input edg 01 bob 1 amount 72802350 output 7280 explan alic follow path 01 wherea bob follow path 10 thu alic open gate node 0 henc net incom 7280 constraint 2 n 105 edgeslength n 1 edgesilength 2 0 ai bi n ai bi edg repres valid tree 1 bob n amountlength n amounti even integ rang 104 104 mostprofitablepathinatre
write code enhanc array call snailrowscount colscount method transform 1d array 2d array organis pattern known snail travers order invalid input valu output empti array rowscount colscount numslength input consid invalid snail travers order start top left cell first valu current array move entir first column top bottom follow move next column right travers bottom top pattern continu altern direct travers column entir current array cover exampl given input array 19 10 3 7 9 8 5 2 1 17 16 14 12 18 6 13 11 20 4 15 rowscount 5 colscount 4 desir output matrix shown note iter matrix follow arrow correspond order number origin array exampl 1 input num 19 10 3 7 9 8 5 2 1 17 16 14 12 18 6 13 11 20 4 15 rowscount 5 colscount 4 output 19171615 101144 321220 751811 98613 exampl 2 input num 1234 rowscount 1 colscount 4 output 1 2 3 4 exampl 3 input num 13 rowscount 2 colscount 2 output explan 2 multipli 2 4 origin array 13 length 2 therefor input invalid constraint 0 numslength 250 1 numsi 1000 1 rowscount 250 1 colscount 250 snailtravers
given root binari search tree bst convert greater tree everi key origin bst chang origin key plu sum key greater origin key bst remind binari search tree tree satisfi constraint left subtre node contain node key less node key right subtre node contain node key greater node key left right subtre must also binari search tree exampl 1 input root 4160257nullnullnull3nullnullnull8 output 30362136352615nullnullnull33nullnullnull8 exampl 2 input root 0null1 output 1null1 constraint number node tree rang 1 100 0 nodev 100 valu tree uniqu note question 538 httpsleetcodecomproblemsconvertbsttogreatertre binarysearchtreetogreatersumtre
problem root tree direct graph exactli one node root node descend node plu everi node exactli one parent except root node parent given input direct graph start root tree n node distinct valu 1 n one addit direct edg ad ad edg two differ vertic chosen 1 n edg alreadi exist result graph given 2darray edg element edg pair ui vi repres direct edg connect node ui vi ui parent child vi return edg remov result graph root tree n node multipl answer return answer occur last given 2darray exampl 1 input edg 121323 output 23 exampl 2 input edg 1223344115 output 41 constraint n edgeslength 3 n 1000 edgesilength 2 1 ui vi n ui vi redundantconnectionii
given x n matrix mat row sort nondecreas order integ k allow choos exactli one element row form array return kth smallest array sum among possibl array exampl 1 input mat 1311246 k 5 output 7 explan choos one element row first k smallest sum 12 14 32 34 16 5th sum 7 exampl 2 input mat 1311246 k 9 output 17 exampl 3 input mat 11010145236 k 7 output 9 explan choos one element row first k smallest sum 112 113 142 143 116 152 153 7th sum 9 constraint matlength n matlengthi 1 n 40 1 matij 5000 1 k min200 nm mati nondecreas array findthekthsmallestsumofamatrixwithsortedrow
given array hous housesi locat ith hous along street integ k alloc k mailbox street return minimum total distanc hous nearest mailbox test case gener answer fit 32bit integ exampl 1 input hous 1481020 k 3 output 5 explan alloc mailbox posit 3 9 20 minimum total distanc hous nearest mailbox 31 43 98 109 2020 5 exampl 2 input hous 2351218 k 2 output 9 explan alloc mailbox posit 3 14 minimum total distanc hous nearest mailbox 23 33 53 1214 1814 9 constraint 1 k houseslength 100 1 housesi 104 integ hous uniqu allocatemailbox
given list path directori info includ directori path file content directori return duplic file file system term path may return answer order group duplic file consist least two file content singl directori info string input list follow format rootd1d2dm f1txtf1content f2txtf2content fntxtfncontent mean n file f1txt f2txt fntxt content f1content f2content fncontent respect directori rootd1d2dm note n 1 0 0 mean directori root directori output list group duplic file path group contain file path file content file path string follow format directorypathfilenametxt exampl 1 input path roota 1txtabcd 2txtefghrootc 3txtabcdrootcd 4txtefghroot 4txtefgh output roota2txtrootcd4txtroot4txtroota1txtrootc3txt exampl 2 input path roota 1txtabcd 2txtefghrootc 3txtabcdrootcd 4txtefgh output roota2txtrootcd4txtroota1txtrootc3txt constraint 1 pathslength 2 104 1 pathsilength 3000 1 sumpathsilength 5 105 pathsi consist english letter digit may assum file directori share name directori may assum given directori info repres uniqu directori singl blank space separ directori path file info follow imagin given real file system search file df bf file content larg gb level modifi solut read file 1kb time modifi solut time complex modifi solut timeconsum part memoryconsum part optim make sure duplic file find fals posit findduplicatefileinsystem
given nonempti array nonneg integ num degre array defin maximum frequenc one element task find smallest possibl length contigu subarray num degre num exampl 1 input num 12231 output 2 explan input array degre 2 element 1 2 appear twice subarray degre 1 2 2 3 1 1 2 2 3 2 2 3 1 1 2 2 2 2 3 2 2 shortest length 2 return 2 exampl 2 input num 1223142 output 6 explan degre 3 element 2 repeat 3 time 223142 shortest subarray therefor return 6 constraint numslength 1 50000 numsi integ 0 49999 degreeofanarray
set 1 2 3 n contain total n uniqu permut list label permut order get follow sequenc n 3 123 132 213 231 312 321 given n k return kth permut sequenc exampl 1 input n 3 k 3 output 213 exampl 2 input n 4 k 9 output 2314 exampl 3 input n 3 k 1 output 123 constraint 1 n 9 1 k n permutationsequ
given two integ memory1 memory2 repres avail memori bit two memori stick current faulti program run consum increas amount memori everi second ith second start 1 bit memori alloc stick avail memori first memori stick avail memori neither stick least bit avail memori program crash return array contain crashtim memory1crash memory2crash crashtim time second program crash memory1crash memory2crash avail bit memori first second stick respect exampl 1 input memory1 2 memory2 2 output 310 explan memori alloc follow 1st second 1 bit memori alloc stick 1 first stick 1 bit avail memori 2nd second 2 bit memori alloc stick 2 second stick 0 bit avail memori 3rd second program crash stick 1 0 bit avail respect exampl 2 input memory1 8 memory2 11 output 604 explan memori alloc follow 1st second 1 bit memori alloc stick 2 second stick 10 bit avail memori 2nd second 2 bit memori alloc stick 2 second stick 8 bit avail memori 3rd second 3 bit memori alloc stick 1 first stick 5 bit avail memori 4th second 4 bit memori alloc stick 2 second stick 4 bit avail memori 5th second 5 bit memori alloc stick 1 first stick 0 bit avail memori 6th second program crash stick 0 4 bit avail respect constraint 0 memory1 memory2 231 1 incrementalmemoryleak
given 2d matrix matrix handl multipl queri follow type calcul sum element matrix insid rectangl defin upper left corner row1 col1 lower right corner row2 col2 implement nummatrix class nummatrixint matrix initi object integ matrix matrix int sumregionint row1 int col1 int row2 int col2 return sum element matrix insid rectangl defin upper left corner row1 col1 lower right corner row2 col2 must design algorithm sumregion work o1 time complex exampl 1 input nummatrix sumregion sumregion sumregion 3 0 1 4 2 5 6 3 2 1 1 2 0 1 5 4 1 0 1 7 1 0 3 0 5 2 1 4 3 1 1 2 2 1 2 2 4 output null 8 11 12 explan nummatrix nummatrix new nummatrix3 0 1 4 2 5 6 3 2 1 1 2 0 1 5 4 1 0 1 7 1 0 3 0 5 nummatrixsumregion2 1 4 3 return 8 ie sum red rectangl nummatrixsumregion1 1 2 2 return 11 ie sum green rectangl nummatrixsumregion1 2 2 4 return 12 ie sum blue rectangl constraint matrixlength n matrixilength 1 n 200 104 matrixij 104 0 row1 row2 0 col1 col2 n 104 call made sumregion rangesumquery2dimmut
given integ array arr choos set integ remov occurr integ array return minimum size set least half integ array remov exampl 1 input arr 3333555227 output 2 explan choos 37 make new array 55522 size 5 ie equal half size old array possibl set size 2 353252 choos set 27 possibl make new array 3333555 size greater half size old array exampl 2 input arr 777777 output 1 explan possibl set choos 7 make new array empti constraint 2 arrlength 105 arrlength even 1 arri 105 reducearraysizetothehalf
given two 2d integ array nums1 nums2 nums1i idi vali indic number id idi valu equal vali nums2i idi vali indic number id idi valu equal vali array contain uniqu id sort ascend order id merg two array one array sort ascend order id respect follow condit id appear least one two array includ result array id includ valu sum valu id two array id exist one two array valu array consid 0 return result array return array must sort ascend order id exampl 1 input nums1 122345 nums2 143241 output 16233246 explan result array contain follow id 1 valu id 2 4 6 id 2 valu id 3 id 3 valu id 2 id 4 valu id 5 1 6 exampl 2 input nums1 243655 nums2 1343 output 1324364355 explan common id includ id valu result list constraint 1 nums1length nums2length 200 nums1ilength nums2jlength 2 1 idi vali 1000 array contain uniqu id array strictli ascend order id mergetwo2darraysbysummingvalu
given phone number string number number consist digit space andor dash would like reformat phone number certain manner firstli remov space dash group digit left right block length 3 4 fewer digit final digit group follow 2 digit singl block length 2 3 digit singl block length 3 4 digit two block length 2 block join dash notic reformat process never produc block length 1 produc two block length 2 return phone number format exampl 1 input number 12345 6 output 123456 explan digit 123456 step 1 4 digit group next 3 digit 1st block 123 step 2 3 digit remain put singl block length 3 2nd block 456 join block give 123456 exampl 2 input number 123 4567 output 1234567 explan digit 1234567 step 1 4 digit group next 3 digit 1st block 123 step 2 4 digit left split two block length 2 block 45 67 join block give 1234567 exampl 3 input number 123 45678 output 12345678 explan digit 12345678 step 1 1st block 123 step 2 2nd block 456 step 3 2 digit left put singl block length 2 3rd block 78 join block give 12345678 constraint 2 numberlength 100 number consist digit charact least two digit number reformatphonenumb
given integ num return number step reduc zero one step current number even divid 2 otherwis subtract 1 exampl 1 input num 14 output 6 explan step 1 14 even divid 2 obtain 7 step 2 7 odd subtract 1 obtain 6 step 3 6 even divid 2 obtain 3 step 4 3 odd subtract 1 obtain 2 step 5 2 even divid 2 obtain 1 step 6 1 odd subtract 1 obtain 0 exampl 2 input num 8 output 4 explan step 1 8 even divid 2 obtain 4 step 2 4 even divid 2 obtain 2 step 3 2 even divid 2 obtain 1 step 4 1 odd subtract 1 obtain 0 exampl 3 input num 123 output 12 constraint 0 num 106 numberofstepstoreduceanumbertozero
given two integ array nums1 nums2 length n respect nums1 nums2 repres digit two number also given integ k creat maximum number length k n digit two number rel order digit array must preserv return array k digit repres answer exampl 1 input nums1 3465 nums2 912583 k 5 output 98653 exampl 2 input nums1 67 nums2 604 k 5 output 67604 exampl 3 input nums1 39 nums2 89 k 3 output 989 constraint nums1length n nums2length 1 n 500 0 nums1i nums2i 9 1 k n createmaximumnumb
given string dictionari string worddict add space construct sentenc word valid dictionari word return possibl sentenc order note word dictionari may reus multipl time segment exampl 1 input catsanddog worddict catcatsandsanddog output cat dogcat sand dog exampl 2 input pineapplepenappl worddict applepenapplepenpinepineappl output pine appl pen applepineappl pen applepin applepen appl explan note allow reus dictionari word exampl 3 input catsandog worddict catsdogsandandcat output constraint 1 slength 20 1 worddictlength 1000 1 worddictilength 10 worddicti consist lowercas english letter string worddict uniqu input gener way length answer doesnt exceed 105 wordbreakii
given 2d integ array order ordersi pricei amounti ordertypei denot amounti order place type ordertypei price pricei ordertypei 0 batch buy order 1 batch sell order note ordersi repres batch amounti independ order price order type order repres ordersi place order repres ordersi1 valid backlog consist order execut backlog initi empti order place follow happen order buy order look sell order smallest price backlog sell order price smaller equal current buy order price match execut sell order remov backlog els buy order ad backlog vice versa order sell order look buy order largest price backlog buy order price larger equal current sell order price match execut buy order remov backlog els sell order ad backlog return total amount order backlog place order input sinc number larg return modulo 109 7 exampl 1 input order 1050152125113040 output 6 explan happen order 5 order type buy price 10 place sell order 5 order ad backlog 2 order type sell price 15 place buy order price larger equal 15 2 order ad backlog 1 order type sell price 25 place buy order price larger equal 25 backlog order ad backlog 4 order type buy price 30 place first 2 order match 2 sell order least price 15 2 sell order remov backlog 3rd order match sell order least price 25 sell order remov backlog sell order backlog 4th order ad backlog final backlog 5 buy order price 10 1 buy order price 30 total number order backlog 6 exampl 2 input order 710000000001153059999999950511 output 999999984 explan happen order 109 order type sell price 7 place buy order 109 order ad backlog 3 order type buy price 15 place match 3 sell order least price 7 3 sell order remov backlog 999999995 order type buy price 5 place least price sell order 7 999999995 order ad backlog 1 order type sell price 5 place match buy order highest price 5 buy order remov backlog final backlog 10000000003 sell order price 7 9999999951 buy order price 5 total number order 1999999991 equal 999999984 109 7 constraint 1 orderslength 105 ordersilength 3 1 pricei amounti 109 ordertypei either 0 1 numberofordersinthebacklog
given x n matrix grid consist nonneg integ gridrowcol repres minimum time requir abl visit cell row col mean visit cell row col time visit greater equal gridrowcol stand topleft cell matrix 0th second must move adjac cell four direct left right move make take 1 second return minimum time requir visit bottomright cell matrix visit bottomright cell return 1 exampl 1 input grid 013251254386 output 7 explan one path take follow 0 cell 00 1 move cell 01 possibl grid01 1 2 move cell 11 possibl grid11 2 3 move cell 12 possibl grid12 3 4 move cell 11 possibl grid11 4 5 move cell 12 possibl grid12 5 6 move cell 13 possibl grid13 6 7 move cell 23 possibl grid23 7 final time 7 shown minimum time possibl exampl 2 input grid 024321104 output 1 explan path top left bottomright cell constraint gridlength n gridilength 2 n 1000 4 n 105 0 gridij 105 grid00 0 minimumtimetovisitacellinagrid
given array integ arr return number subarray odd sum sinc answer larg return modulo 109 7 exampl 1 input arr 135 output 4 explan subarray 1131353355 subarray sum 149385 odd sum 1935 answer 4 exampl 2 input arr 246 output 0 explan subarray 2242464466 subarray sum 26124106 subarray even sum answer 0 exampl 3 input arr 1234567 output 16 constraint 1 arrlength 105 1 arri 100 numberofsubarrayswithoddsum
decim number call decibinari digit either 0 1 without lead zero exampl 101 1100 decibinari 112 3001 given string n repres posit decim integ return minimum number posit decibinari number need sum n exampl 1 input n 32 output 3 explan 10 11 11 32 exampl 2 input n 82734 output 8 exampl 3 input n 27346209830709182346 output 9 constraint 1 nlength 105 n consist digit n contain lead zero repres posit integ partitioningintominimumnumberofdecibinarynumb
given 0index 2d integ array num initi score 0 perform follow oper matrix becom empti row matrix select largest number remov case tie matter number chosen identifi highest number amongst remov step 1 add number score return final score exampl 1 input num 721642653321 output 15 explan first oper remov 7 6 6 3 add 7 score next remov 2 4 5 2 add 5 score lastli remov 1 2 3 1 add 3 score thu final score 7 5 3 15 exampl 2 input num 1 output 1 explan remov 1 add answer return 1 constraint 1 numslength 300 1 numsilength 500 0 numsij 103 suminamatrix
given n x n binari matrix grid 1 repres land 0 repres water island 4direct connect group 1s connect 1s exactli two island grid may chang 0s 1s connect two island form one island return smallest number 0s must flip connect two island exampl 1 input grid 0110 output 1 exampl 2 input grid 010000001 output 2 exampl 3 input grid 1111110001101011000111111 output 1 constraint n gridlength gridilength 2 n 100 gridij either 0 1 exactli two island grid shortestbridg
given integ array num length n integ array queri length return array answer length answeri maximum size subsequ take num sum element less equal queriesi subsequ array deriv anoth array delet element without chang order remain element exampl 1 input num 4521 queri 31021 output 234 explan answer queri follow subsequ 21 sum less equal 3 proven 2 maximum size subsequ answer0 2 subsequ 451 sum less equal 10 proven 3 maximum size subsequ answer1 3 subsequ 4521 sum less equal 21 proven 4 maximum size subsequ answer2 4 exampl 2 input num 2345 queri 1 output 0 explan empti subsequ subsequ sum less equal 1 answer0 0 constraint n numslength querieslength 1 n 1000 1 numsi queriesi 106 longestsubsequencewithlimitedsum
given array num posit integ posit integ k subset num beauti contain two integ absolut differ equal k return number nonempti beauti subset array num subset num array obtain delet possibl none element num two subset differ chosen indic delet differ exampl 1 input num 246 k 2 output 4 explan beauti subset array num 2 4 6 2 6 prove 4 beauti subset array 246 exampl 2 input num 1 k 1 output 1 explan beauti subset array num 1 prove 1 beauti subset array 1 constraint 1 numslength 20 1 numsi k 1000 thenumberofbeautifulsubset
sql schema pandan schema tabl user column name type userid int name varchar sql userid primari key tabl tabl contain id name user name consist lowercas uppercas charact fix name first charact uppercas rest lowercas return result tabl order userid result format follow exampl exampl 1 input user tabl userid name 1 alic 2 bob output userid name 1 alic 2 bob fixnamesinat
frequenc element number time occur array given integ array num integ k one oper choos index num increment element index 1 return maximum possibl frequenc element perform k oper exampl 1 input num 124 k 5 output 3 explan increment first element three time second element two time make num 444 4 frequenc 3 exampl 2 input num 14813 k 5 output 2 explan multipl optim solut increment first element three time make num 44813 4 frequenc 2 increment second element four time make num 18813 8 frequenc 2 increment third element five time make num 141313 13 frequenc 2 exampl 3 input num 396 k 2 output 1 constraint 1 numslength 105 1 numsi 105 1 k 105 frequencyofthemostfrequentel
sql schema tabl employe column name type employeeid int departmentid int primaryflag varchar employeeid departmentid primari key tabl employeeid id employe departmentid id depart employe belong primaryflag enum type n flag depart primari depart employe flag n depart primari employe belong multipl depart employe join depart need decid depart primari depart note employe belong one depart primari column n write sql queri report employe primari depart employe belong one depart report depart return result tabl order queri result format follow exampl exampl 1 input employe tabl employeeid departmentid primaryflag 1 1 n 2 1 2 2 n 3 3 n 4 2 n 4 3 4 4 n output employeeid departmentid 1 1 2 1 3 3 4 3 explan primari depart employe 1 1 primari depart employe 2 1 primari depart employe 3 3 primari depart employe 4 3 primarydepartmentforeachemploye
given head singli link list element sort ascend order convert heightbalanc binari search tree exampl 1 input head 103059 output 03910null5 explan one possibl answer 03910null5 repres shown height balanc bst exampl 2 input head output constraint number node head rang 0 2 104 105 nodev 105 convertsortedlisttobinarysearchtre
given array posit integ arr necessarili distinct return lexicograph largest permut smaller arr made exactli one swap done return array note swap exchang posit two number arri arrj exampl 1 input arr 321 output 312 explan swap 2 1 exampl 2 input arr 115 output 115 explan alreadi smallest permut exampl 3 input arr 19467 output 17469 explan swap 9 7 constraint 1 arrlength 104 1 arri 104 previouspermutationwithoneswap
given undirect weight graph n node 0index repres edg list edgesi b undirect edg connect node b probabl success travers edg succprobi given two node start end find path maximum probabl success go start end return success probabl path start end return 0 answer accept differ correct answer 1e5 exampl 1 input n 3 edg 011202 succprob 050502 start 0 end 2 output 025000 explan two path start end one probabl success 02 05 05 025 exampl 2 input n 3 edg 011202 succprob 050503 start 0 end 2 output 030000 exampl 3 input n 3 edg 01 succprob 05 start 0 end 2 output 000000 explan path 0 2 constraint 2 n 104 0 start end n start end 0 b n b 0 succproblength edgeslength 2104 0 succprobi 1 one edg everi two node pathwithmaximumprob
string call happi satisfi follow condit contain letter b c contain aaa bbb ccc substr contain occurr letter contain b occurr letter b contain c occurr letter c given three integ b c return longest possibl happi string multipl longest happi string return string return empti string substr contigu sequenc charact within string exampl 1 input 1 b 1 c 7 output ccaccbcc explan ccbccacc would also correct answer exampl 2 input 7 b 1 c 0 output aabaa explan correct answer case constraint 0 b c 100 b c 0 longesthappystr
tree undirect graph two vertic connect exactli one path word connect graph without simpl cycl tree given tree n node label 0 n 1 array n 1 edg edgesi ai bi indic undirect edg two node ai bi tree choos node tree root select node x root result tree height h among possibl root tree minimum height ie minh call minimum height tree mht return list mht root label return answer order height root tree number edg longest downward path root leaf exampl 1 input n 4 edg 101213 output 1 explan shown height tree 1 root node label 1 mht exampl 2 input n 6 edg 3031323454 output 34 constraint 1 n 2 104 edgeslength n 1 0 ai bi n ai bi pair ai bi distinct given input guarante tree repeat edg minimumheighttre
given sort integ array num integ n addpatch element array number rang 1 n inclus form sum element array return minimum number patch requir exampl 1 input num 13 n 6 output 1 explan combin num 1 3 13 form possibl sum 1 3 4 addpatch 2 num combin 1 2 3 13 23 123 possibl sum 1 2 3 4 5 6 cover rang 1 6 need 1 patch exampl 2 input num 1510 n 20 output 2 explan two patch 2 4 exampl 3 input num 122 n 5 output 0 constraint 1 numslength 1000 1 numsi 104 num sort ascend order 1 n 231 1 patchingarray
given n x n binari grid board move swap two row two column return minimum number move transform board chessboard board task imposs return 1 chessboard board board 0s 1s 4direct adjac exampl 1 input board 0110011010011001 output 2 explan one potenti sequenc move shown first move swap first second column second move swap second third row exampl 2 input board 0110 output 0 explan also note board 0 top left corner also valid chessboard exampl 3 input board 1010 output 1 explan matter sequenc move make end valid chessboard constraint n boardlength n boardilength 2 n 30 boardij either 0 1 transformtochessboard
given integ array num need creat 2d array num satisfi follow condit 2d array contain element array num row 2d array contain distinct integ number row 2d array minim return result array multipl answer return note 2d array differ number element row exampl 1 input num 1341231 output 1342131 explan creat 2d array contain follow row 1342 13 1 element num use row 2d array contain distinct integ valid answer shown less 3 row valid array exampl 2 input num 1234 output 4321 explan element array distinct keep first row 2d array constraint 1 numslength 200 1 numsi numslength convertanarrayintoa2darraywithcondit
messag contain letter az encod number use follow map 1 b 2 z 26 decod encod messag digit must group map back letter use revers map may multipl way exampl 11106 map aajf group 1 1 10 6 kjf group 11 10 6 note group 1 11 06 invalid 06 map f sinc 6 differ 06 addit map encod messag may contain charact repres digit 1 9 0 exclud exampl encod messag 1 may repres encod messag 11 12 13 14 15 16 17 18 19 decod 1 equival decod encod messag repres given string consist digit charact return number way decod sinc answer may larg return modulo 109 7 exampl 1 input output 9 explan encod messag repres encod messag 1 2 3 4 5 6 7 8 9 decod string b c e f g h respect henc total 9 way decod exampl 2 input 1 output 18 explan encod messag repres encod messag 11 12 13 14 15 16 17 18 19 encod messag 2 way decod eg 11 decod aa k henc total 9 2 18 way decod 1 exampl 3 input 2 output 15 explan encod messag repres encod messag 21 22 23 24 25 26 27 28 29 21 22 23 24 25 26 2 way decod 27 28 29 1 way henc total 6 2 3 1 12 3 15 way decod 2 constraint 1 slength 105 si digit decodewaysii
alic n candi ith candi type candytypei alic notic start gain weight visit doctor doctor advis alic eat n 2 candi n alway even alic like candi much want eat maximum number differ type candi still follow doctor advic given integ array candytyp length n return maximum number differ type candi eat eat n 2 exampl 1 input candytyp 112233 output 3 explan alic eat 6 2 3 candi sinc 3 type eat one type exampl 2 input candytyp 1123 output 2 explan alic eat 4 2 2 candi whether eat type 12 13 23 still eat 2 differ type exampl 3 input candytyp 6666 output 1 explan alic eat 4 2 2 candi even though eat 2 candi 1 type constraint n candytypelength 2 n 104 n even 105 candytypei 105 distributecandi
given string consist digit integ k round complet length greater k one round follow divid consecut group size k first k charact first group next k charact second group note size last group smaller k replac group string repres sum digit exampl 346 replac 13 3 4 6 13 merg consecut group togeth form new string length string greater k repeat step 1 return round complet exampl 1 input 11111222223 k 3 output 135 explan first round divid group size 3 111 112 222 23 calcul digit sum group 1 1 1 3 1 1 2 4 2 2 2 6 2 3 5 becom 3 4 6 5 3465 first round second round divid 346 5 calcul digit sum group 3 4 6 13 5 5 becom 13 5 135 second round slength k return 135 answer exampl 2 input 00000000 k 3 output 000 explan divid 000 000 00 calcul digit sum group 0 0 0 0 0 0 0 0 0 0 0 becom 0 0 0 000 whose length equal k return 000 constraint 1 slength 100 2 k 100 consist digit calculatedigitsumofastr
given list bomb rang bomb defin area effect felt area shape circl center locat bomb bomb repres 0index 2d integ array bomb bombsi xi yi ri xi yi denot xcoordin ycoordin locat ith bomb wherea ri denot radiu rang may choos deton singl bomb bomb deton deton bomb lie rang bomb deton bomb lie rang given list bomb return maximum number bomb deton allow deton one bomb exampl 1 input bomb 213614 output 2 explan figur show posit rang 2 bomb deton left bomb right bomb affect deton right bomb bomb deton maximum bomb deton max1 2 2 exampl 2 input bomb 11510105 output 1 explan deton either bomb deton bomb maximum number bomb deton 1 exampl 3 input bomb 123231342453564 output 5 explan best bomb deton bomb 0 bomb 0 deton bomb 1 2 red circl denot rang bomb 0 bomb 2 deton bomb 3 blue circl denot rang bomb 2 bomb 3 deton bomb 4 green circl denot rang bomb 3 thu 5 bomb deton constraint 1 bombslength 100 bombsilength 3 1 xi yi ri 105 detonatethemaximumbomb
given integ array num return true valu appear least twice array return fals everi element distinct exampl 1 input num 1231 output true exampl 2 input num 1234 output fals exampl 3 input num 1113343242 output true constraint 1 numslength 105 109 numsi 109 containsdupl
given c program remov comment program sourc array string sourc sourcei ith line sourc code repres result split origin sourc code string newlin charact n c two type comment line comment block comment string denot line comment repres rest charact right line ignor string denot block comment repres charact next nonoverlap occurr ignor occurr happen read order line line left right clear string yet end block comment end would overlap begin first effect comment take preced other exampl string occur block comment ignor similarli string occur line block comment also ignor certain line code empti remov comment must output line string answer list nonempti control charact singl quot doubl quot charact exampl sourc string comment test case also noth els defin macro interfer comment guarante everi open block comment eventu close outsid line block comment alway start new comment final implicit newlin charact delet block comment pleas see exampl detail remov comment sourc code return sourc code format exampl 1 input sourc test program int main variabl declar int b c test multilin comment test b c output int main int b ca b c explan line line code visual test program int main variabl declar int b c test multilin comment test b c string denot block comment includ line 1 line 69 string denot line 4 comment line line output code visual int main int b c b c exampl 2 input sourc acom line morecommentb output ab explan origin sourc string acommentnlinenmorecommentb bold newlin charact delet implicit newlin charact delet leav string ab delimit newlin charact becom ab constraint 1 sourcelength 100 0 sourceilength 80 sourcei consist printabl ascii charact everi open block comment eventu close singlequot doublequot input removecom
given array charact letter sort nondecreas order charact target least two differ charact letter return smallest charact letter lexicograph greater target charact exist return first charact letter exampl 1 input letter cfj target output c explan smallest charact lexicograph greater letter c exampl 2 input letter cfj target c output f explan smallest charact lexicograph greater c letter f exampl 3 input letter xxyy target z output x explan charact letter lexicograph greater z return letters0 constraint 2 letterslength 104 lettersi lowercas english letter letter sort nondecreas order letter contain least two differ charact target lowercas english letter findsmallestlettergreaterthantarget
due bug mani duplic folder file system given 2d array path pathsi array repres absolut path ith folder file system exampl one two three repres path onetwothre two folder necessarili level ident contain nonempti set ident subfold underli subfold structur folder need root level ident two folder ident mark folder well subfold exampl folder b file structur ident well subfold mark ax axi az b bx bxi bz howev file structur also includ path bw folder b would ident note ax bx would still consid ident even ad folder ident folder subfold mark file system delet file system run delet folder becom ident initi delet delet return 2d array an contain path remain folder delet mark folder path may return order exampl 1 input path acdabcbda output dda explan file structur shown folder c subfold mark delet contain empti folder name b exampl 2 input path acabcbabxabxywwi output ccbaab explan file structur shown folder abx w subfold mark delet contain empti folder name note folder c ident delet delet mark beforehand exampl 3 input path abcdca output ccdaab explan folder uniqu file system note return array differ order order matter constraint 1 pathslength 2 104 1 pathsilength 500 1 pathsijlength 10 1 sumpathsijlength 2 105 pathij consist lowercas english letter two path lead folder folder root level parent folder also input deleteduplicatefoldersinsystem
given array rectangl rectanglesi li wi repres ith rectangl length li width wi cut ith rectangl form squar side length k k li k wi exampl rectangl 46 cut get squar side length 4 let maxlen side length largest squar obtain given rectangl return number rectangl make squar side length maxlen exampl 1 input rectangl 5839512165 output 3 explan largest squar get rectangl length 5355 largest possibl squar length 5 get 3 rectangl exampl 2 input rectangl 23374337 output 3 constraint 1 rectangleslength 1000 rectanglesilength 2 1 li wi 109 li wi numberofrectanglesthatcanformthelargestsquar
roman numer repres seven differ symbol v x l c symbol valu 1 v 5 x 10 l 50 c 100 500 1000 exampl 2 written ii roman numer two one ad togeth 12 written xii simpli x ii number 27 written xxvii xx v ii roman numer usual written largest smallest left right howev numer four iiii instead number four written iv one five subtract make four principl appli number nine written ix six instanc subtract use place v 5 x 10 make 4 9 x place l 50 c 100 make 40 90 c place 500 1000 make 400 900 given integ convert roman numer exampl 1 input num 3 output iii explan 3 repres 3 one exampl 2 input num 58 output lviii explan l 50 v 5 iii 3 exampl 3 input num 1994 output mcmxciv explan 1000 cm 900 xc 90 iv 4 constraint 1 num 3999 integertoroman
storekeep game player push box around warehous tri get target locat game repres x n grid charact grid element wall floor box task move box b target posit follow rule charact repres player player move left right grid floor empti cell charact repres floor mean free cell walk charact repres wall mean obstacl imposs walk one box b one target cell grid box move adjac free cell stand next box move direct box push player walk box return minimum number push move box target way reach target return 1 exampl 1 input grid b output 3 explan return number time box push exampl 2 input grid b output 1 exampl 3 input grid b output 5 explan push box left left constraint gridlength n gridilength 1 n 20 grid contain charact b one charact b grid minimummovestomoveaboxtotheirtargetloc
sql schema pandan schema tabl world column name type name varchar contin varchar area int popul int gdp bigint sql name primari key column tabl row tabl give inform name countri contin belong area popul gdp valu countri big area least three million ie 3000000 km2 popul least twentyf million ie 25000000 find name popul area big countri return result tabl order result format follow exampl exampl 1 input world tabl name contin area popul gdp afghanistan asia 652230 25500100 20343000000 albania europ 28748 2831741 12960000000 algeria africa 2381741 37100000 188681000000 andorra europ 468 78115 3712000000 angola africa 1246700 20609294 100990000000 output name popul area afghanistan 25500100 652230 algeria 37100000 2381741 bigcountri
given two integ array push pop distinct valu return true could result sequenc push pop oper initi empti stack fals otherwis exampl 1 input push 12345 pop 45321 output true explan might follow sequenc push1 push2 push3 push4 pop 4 push5 pop 5 pop 3 pop 2 pop 1 exampl 2 input push 12345 pop 43512 output fals explan 1 pop 2 constraint 1 pushedlength 1000 0 pushedi 1000 element push uniqu poppedlength pushedlength pop permut push validatestacksequ
given undirect tree consist n vertic number 0 n1 appl vertic spend 1 second walk one edg tree return minimum time second spend collect appl tree start vertex 0 come back vertex edg undirect tree given array edg edgesi ai bi mean exist edg connect vertic ai bi addit boolean array hasappl hasapplei true mean vertex appl otherwis appl exampl 1 input n 7 edg 010214152326 hasappl falsefalsetruefalsetruetruefals output 8 explan figur repres given tree red vertic appl one optim path collect appl shown green arrow exampl 2 input n 7 edg 010214152326 hasappl falsefalsetruefalsefalsetruefals output 6 explan figur repres given tree red vertic appl one optim path collect appl shown green arrow exampl 3 input n 7 edg 010214152326 hasappl falsefalsefalsefalsefalsefalsefals output 0 constraint 1 n 105 edgeslength n 1 edgesilength 2 0 ai bi n 1 hasapplelength n minimumtimetocollectallapplesinatre
given integ array num one move choos one element num chang valu return minimum differ largest smallest valu num perform three move exampl 1 input num 5324 output 0 explan make 3 move first move chang 2 3 num becom 5334 second move chang 4 3 num becom 5333 third move chang 5 3 num becom 3333 perform 3 move differ minimum maximum 3 3 0 exampl 2 input num 1501014 output 1 explan make 3 move first move chang 5 0 num becom 1001014 second move chang 10 0 num becom 100014 third move chang 14 1 num becom 10001 perform 3 move differ minimum maximum 1 0 1 shown way make differ 0 3 move exampl 3 input num 310020 output 0 explan make 3 move first move chang 100 7 num becom 3720 second move chang 20 7 num becom 377 third move chang 3 7 num becom 777 perform 3 move differ minimum maximum 7 7 0 constraint 1 numslength 105 109 numsi 109 minimumdifferencebetweenlargestandsmallestvalueinthreemov
n box given binari string box length n boxesi 0 ith box empti 1 contain one ball one oper move one ball box adjac box box adjac box j absi j 1 note may one ball box return array answer size n answeri minimum number oper need move ball ith box answeri calcul consid initi state box exampl 1 input box 110 output 113 explan answer box follow 1 first box move one ball second box first box one oper 2 second box move one ball first box second box one oper 3 third box move one ball first box third box two oper move one ball second box third box one oper exampl 2 input box 001011 output 1185434 constraint n boxeslength 1 n 2000 boxesi either 0 1 minimumnumberofoperationstomoveallballstoeachbox
given integ total indic amount money also given two integ cost1 cost2 indic price pen pencil respect spend part money buy multipl quantiti none kind write utensil return number distinct way buy number pen pencil exampl 1 input total 20 cost1 10 cost2 5 output 9 explan price pen 10 price pencil 5 buy 0 pen buy 0 1 2 3 4 pencil buy 1 pen buy 0 1 2 pencil buy 2 pen buy pencil total number way buy pen pencil 5 3 1 9 exampl 2 input total 5 cost1 10 cost2 10 output 1 explan price pen pencil 10 cost total buy write utensil therefor 1 way buy 0 pen 0 pencil constraint 1 total cost1 cost2 106 numberofwaystobuypensandpencil
given integ array num handl multipl queri follow type calcul sum element num indic left right inclus left right implement numarray class numarrayint num initi object integ array num int sumrangeint left int right return sum element num indic left right inclus ie numsleft numsleft 1 numsright exampl 1 input numarray sumrang sumrang sumrang 2 0 3 5 2 1 0 2 2 5 0 5 output null 1 1 3 explan numarray numarray new numarray2 0 3 5 2 1 numarraysumrange0 2 return 2 0 3 1 numarraysumrange2 5 return 3 5 2 1 1 numarraysumrange0 5 return 2 0 3 5 2 1 3 constraint 1 numslength 104 105 numsi 105 0 left right numslength 104 call made sumrang rangesumqueryimmut
minimum absolut differ array defin minimum valu ai aj 0 j alength ai aj element minimum absolut differ 1 exampl minimum absolut differ array 52372 2 3 1 note 0 ai aj must differ given integ array num array queri queriesi li ri queri comput minimum absolut differ subarray numsliri contain element num 0base indic li ri inclus return array an ansi answer ith queri subarray contigu sequenc element array valu x defin x x 0 x x 0 exampl 1 input num 1348 queri 01122303 output 2141 explan queri process follow queries0 01 subarray 13 minimum absolut differ 13 2 queries1 12 subarray 34 minimum absolut differ 34 1 queries2 23 subarray 48 minimum absolut differ 48 4 queries3 03 subarray 1348 minimum absolut differ 34 1 exampl 2 input num 4522710 queri 23020535 output 1113 explan queri process follow queries0 23 subarray 22 minimum absolut differ 1 element queries1 02 subarray 452 minimum absolut differ 45 1 queries2 05 subarray 4522710 minimum absolut differ 45 1 queries3 35 subarray 2710 minimum absolut differ 710 3 constraint 2 numslength 105 1 numsi 100 1 querieslength 2 104 0 li ri numslength minimumabsolutedifferencequeri
long thin paint repres number line paint paint multipl overlap segment segment paint uniqu color given 2d integ array segment segmentsi starti endi colori repres halfclos segment starti endi colori color color overlap segment paint mix paint two color mix form new color repres set mix color exampl color 2 4 6 mix result mix color 246 sake simplic output sum element set rather full set want describ paint minimum number nonoverlap halfclos segment mix color segment repres 2d array paint paintingj leftj rightj mixj describ halfclos segment leftj rightj mix color sum mixj exampl paint creat segment 145177 describ paint 1412477 14 color 57 sum 12 first second segment 47 color 7 second segment return 2d array paint describ finish paint exclud part paint may return segment order halfclos segment b section number line point b includ point includ point b exampl 1 input segment 145477179 output 14144716 explan paint describ follow 14 color 59 sum 14 first third segment 47 color 79 sum 16 second third segment exampl 2 input segment 17968158107 output 169672478158107 explan paint describ follow 16 color 9 first segment 67 color 915 sum 24 first second segment 78 color 15 second segment 810 color 7 third segment exampl 3 input segment 1451474714711 output 14124712 explan paint describ follow 14 color 57 sum 12 first second segment 47 color 111 sum 12 third fourth segment note return singl segment 17 incorrect mix color set differ constraint 1 segmentslength 2 104 segmentsilength 3 1 starti endi 105 1 colori 109 colori distinct describethepaint
given string find two disjoint palindrom subsequ product length maxim two subsequ disjoint pick charact index return maximum possibl product length two palindrom subsequ subsequ string deriv anoth string delet charact without chang order remain charact string palindrom read forward backward exampl 1 input leetcodecom output 9 explan optim solut choos ete 1st subsequ cdc 2nd subsequ product length 3 3 9 exampl 2 input bb output 1 explan optim solut choos b first charact 1st subsequ b second charact 2nd subsequ product length 1 1 1 exampl 3 input accbcaxxcxx output 25 explan optim solut choos accca 1st subsequ xxcxx 2nd subsequ product length 5 5 25 constraint 2 slength 12 consist lowercas english letter maximumproductofthelengthoftwopalindromicsubsequ
given equat repres word left side result right side need check equat solvabl follow rule charact decod one digit 0 9 two charact map digit wordsi result decod one number without lead zero sum number left side word equal number right side result return true equat solvabl otherwis return fals exampl 1 input word sendmor result money output true explan map 9 e5 n6 d7 m1 o0 r8 y2 send money 9567 1085 10652 exampl 2 input word sixsevenseven result twenti output true explan map 6 i5 x0 e8 v7 n2 t1 w3 y4 six seven seven twenti 650 68782 68782 138214 exampl 3 input word leetcod result point output fals explan possibl map satisfi equat return fals note two differ charact map digit constraint 2 wordslength 5 1 wordsilength resultlength 7 wordsi result contain uppercas english letter number differ charact use express 10 verbalarithmeticpuzzl
given two string p return array start indic ps anagram may return answer order anagram word phrase form rearrang letter differ word phrase typic use origin letter exactli exampl 1 input cbaebabacd p abc output 06 explan substr start index 0 cba anagram abc substr start index 6 bac anagram abc exampl 2 input abab p ab output 012 explan substr start index 0 ab anagram ab substr start index 1 ba anagram ab substr start index 2 ab anagram ab constraint 1 slength plength 3 104 p consist lowercas english letter findallanagramsinastr
n box label 0 n 1 given four array statu candi key containedbox statusi 1 ith box open 0 ith box close candiesi number candi ith box keysi list label box open open ith box containedboxesi list box found insid ith box given integ array initialbox contain label box initi take candi open box use key open new box also use box find return maximum number candi get follow rule exampl 1 input statu 1010 candi 754100 key 1 containedbox 123 initialbox 0 output 16 explan initi given box 0 find 7 candi box 1 2 box 1 close key open box 2 find 4 candi key box 1 box 2 box 1 find 5 candi box 3 find key box 3 box 3 remain close total number candi collect 7 4 5 16 candi exampl 2 input statu 100000 candi 111111 key 12345 containedbox 12345 initialbox 0 output 6 explan initi box 0 open find box 1234 5 key total number candi 6 constraint n statuslength candieslength keyslength containedboxeslength 1 n 1000 statusi either 0 1 1 candiesi 1000 0 keysilength n 0 keysij n valu keysi uniqu 0 containedboxesilength n 0 containedboxesij n valu containedboxesi uniqu box contain one box 0 initialboxeslength n 0 initialboxesi n maximumcandiesyoucangetfrombox
given row x col binari matrix fill 0s 1s find largest rectangl contain 1s return area exampl 1 input matrix 10100101111111110010 output 6 explan maxim rectangl shown pictur exampl 2 input matrix 0 output 0 exampl 3 input matrix 1 output 1 constraint row matrixlength col matrixilength 1 row col 200 matrixij 0 1 maximalrectangl
given head singli link list return true palindrom fals otherwis exampl 1 input head 1221 output true exampl 2 input head 12 output fals constraint number node list rang 1 105 0 nodev 9 follow could time o1 space palindromelinkedlist
given circular integ array num length n return maximum possibl sum nonempti subarray num circular array mean end array connect begin array formal next element numsi numsi 1 n previou element numsi numsi 1 n n subarray may includ element fix buffer num formal subarray numsi numsi 1 numsj exist k1 k2 j k1 n k2 n exampl 1 input num 1232 output 3 explan subarray 3 maximum sum 3 exampl 2 input num 535 output 10 explan subarray 55 maximum sum 5 5 10 exampl 3 input num 323 output 2 explan subarray 2 maximum sum 2 constraint n numslength 1 n 3 104 3 104 numsi 3 104 maximumsumcircularsubarray
pointer index 0 array size arrlen step move 1 posit left 1 posit right array stay place pointer place outsid array time given two integ step arrlen return number way pointer still index 0 exactli step step sinc answer may larg return modulo 109 7 exampl 1 input step 3 arrlen 2 output 4 explan 4 differ way stay index 0 3 step right left stay stay right left right stay left stay stay stay exampl 2 input step 2 arrlen 4 output 2 explan 2 differ way stay index 0 2 step right left stay stay exampl 3 input step 4 arrlen 2 output 8 constraint 1 step 500 1 arrlen 106 numberofwaystostayinthesameplaceaftersomestep
given string consist lowercas english letter return first letter appear twice note letter appear twice anoth letter b second occurr second occurr b contain least one letter appear twice exampl 1 input abccbaacz output c explan letter appear index 0 5 6 letter b appear index 1 4 letter c appear index 2 3 7 letter z appear index 8 letter c first letter appear twice letter index second occurr smallest exampl 2 input abcdd output explan letter appear twice return constraint 2 slength 100 consist lowercas english letter least one repeat letter firstlettertoappeartwic
english concept call root follow word form anoth longer word let call word successor exampl root follow successor word form new word anoth given dictionari consist mani root sentenc consist word separ space replac successor sentenc root form successor replac one root replac root shortest length return sentenc replac exampl 1 input dictionari catbatrat sentenc cattl rattl batteri output cat rat bat exampl 2 input dictionari abc sentenc aadsfasf absb bbab cadsfaf output b c constraint 1 dictionarylength 1000 1 dictionaryilength 100 dictionaryi consist lowercas letter 1 sentencelength 106 sentenc consist lowercas letter space number word sentenc rang 1 1000 length word sentenc rang 1 1000 everi two consecut word sentenc separ exactli one space sentenc lead trail space replaceword
let play minesweep game wikipedia onlin game given x n char matrix board repres game board repres unrev mine e repres unrev empti squar b repres reveal blank squar adjac mine ie left right 4 diagon digit 1 8 repres mani mine adjac reveal squar x repres reveal mine also given integ array click click clickr clickc repres next click posit among unrev squar e return board reveal posit accord follow rule mine reveal game chang x empti squar e adjac mine reveal chang reveal blank b adjac unrev squar reveal recurs empti squar e least one adjac mine reveal chang digit 1 8 repres number adjac mine return board squar reveal exampl 1 input board eeeeeeemeeeeeeeeeee click 30 output b1e1bb1m1bb111bbbbbb exampl 2 input board b1e1bb1m1bb111bbbbbb click 12 output b1e1bb1x1bb111bbbbbb constraint boardlength n boardilength 1 n 50 boardij either e b digit 1 8 clicklength 2 0 clickr 0 clickc n boardclickrclickc either e minesweep
binari string monoton increas consist number 0s possibl none follow number 1s also possibl none given binari string flip si chang 0 1 1 0 return minimum number flip make monoton increas exampl 1 input 00110 output 1 explan flip last digit get 00111 exampl 2 input 010110 output 2 explan flip get 011111 altern 000111 exampl 3 input 00011000 output 2 explan flip get 00000000 constraint 1 slength 105 si either 0 1 flipstringtomonotoneincreas
shop sell candi discount everi two candi sold shop give third candi free custom choos candi take away free long cost chosen candi less equal minimum cost two candi bought exampl 4 candi cost 1 2 3 4 custom buy candi cost 2 3 take candi cost 1 free candi cost 4 given 0index integ array cost costi denot cost ith candi return minimum cost buy candi exampl 1 input cost 123 output 5 explan buy candi cost 2 3 take candi cost 1 free total cost buy candi 2 3 5 way buy candi note buy candi cost 1 3 take candi cost 2 free cost free candi less equal minimum cost purchas candi exampl 2 input cost 657922 output 23 explan way get minimum cost describ buy candi cost 9 7 take candi cost 6 free buy candi cost 5 2 take last remain candi cost 2 free henc minimum cost buy candi 9 7 5 2 23 exampl 3 input cost 55 output 10 explan sinc 2 candi buy third candi take free henc minimum cost buy candi 5 5 10 constraint 1 costlength 100 1 costi 100 minimumcostofbuyingcandieswithdiscount
given x n integ matrix matrix follow two properti row sort nondecreas order first integ row greater last integ previou row given integ target return true target matrix fals otherwis must write solut ologm n time complex exampl 1 input matrix 13571011162023303460 target 3 output true exampl 2 input matrix 13571011162023303460 target 13 output fals constraint matrixlength n matrixilength 1 n 100 104 matrixij target 104 searcha2dmatrix
given 0index 2d integ array grid size x n repres map item shop integ grid repres follow 0 repres wall pass 1 repres empti cell freeli move posit integ repres price item cell may also freeli move item cell take 1 step travel adjac grid cell also given integ array price start price low high start row col indic start posit row col interest item price rang low high inclus given integ k interest posit k highestrank item whose price within given price rang rank determin first criteria differ distanc defin length shortest path start shorter distanc higher rank price lower price higher rank must price rang row number smaller row number higher rank column number smaller column number higher rank return k highestrank item within price rang sort rank highest lowest fewer k reachabl item within price rang return exampl 1 input grid 120113010251 price 25 start 00 k 3 output 011121 explan start 00 price rang 25 take item 01 11 21 22 rank item 01 distanc 1 11 distanc 2 21 distanc 3 22 distanc 4 thu 3 highest rank item price rang 01 11 21 exampl 2 input grid 120113310251 price 23 start 23 k 2 output 2112 explan start 23 price rang 23 take item 01 11 12 21 rank item 21 distanc 2 price 2 12 distanc 2 price 3 11 distanc 3 01 distanc 4 thu 2 highest rank item price rang 21 12 exampl 3 input grid 111001234 price 23 start 00 k 3 output 2120 explan start 00 price rang 23 take item 20 21 rank item 21 distanc 5 20 distanc 6 thu 2 highest rank item price rang 21 20 note k 3 2 reachabl item within price rang constraint gridlength n gridilength 1 n 105 1 n 105 0 gridij 105 pricinglength 2 2 low high 105 startlength 2 0 row 1 0 col n 1 gridrowcol 0 1 k n khighestrankeditemswithinapricerang
atm machin store banknot 5 denomin 20 50 100 200 500 dollar initi atm empti user use machin deposit withdraw amount money withdraw machin priorit use banknot larger valu exampl want withdraw 300 2 50 banknot 1 100 banknot 1 200 banknot machin use 100 200 banknot howev tri withdraw 600 3 200 banknot 1 500 banknot withdraw request reject machin first tri use 500 banknot unabl use banknot complet remain 100 note machin allow use 200 banknot instead 500 banknot implement atm class atm initi atm object void depositint banknotescount deposit new banknot order 20 50 100 200 500 int withdrawint amount return array length 5 number banknot hand user order 20 50 100 200 500 updat number banknot atm withdraw return 1 possibl withdraw banknot case exampl 1 input atm deposit withdraw deposit withdraw withdraw 00121 600 01011 600 550 output null null 00101 null 1 01001 explan atm atm new atm atmdeposit00121 deposit 1 100 banknot 2 200 banknot 1 500 banknot atmwithdraw600 return 00101 machin use 1 100 banknot 1 500 banknot banknot left machin 00020 atmdeposit01011 deposit 1 50 200 500 banknot banknot machin 01031 atmwithdraw600 return 1 machin tri use 500 banknot unabl complet remain 100 withdraw request reject sinc request reject number banknot machin modifi atmwithdraw550 return 01001 machin use 1 50 banknot 1 500 banknot constraint banknotescountlength 5 0 banknotescounti 109 1 amount 109 5000 call total made withdraw deposit least one call made function withdraw deposit designanatmmachin
given 0index integ array num pair indic j bad pair j j numsj numsi return total number bad pair num exampl 1 input num 4133 output 5 explan pair 0 1 bad pair sinc 1 0 1 4 pair 0 2 bad pair sinc 2 0 3 4 2 1 pair 0 3 bad pair sinc 3 0 3 4 3 1 pair 1 2 bad pair sinc 2 1 3 1 1 2 pair 2 3 bad pair sinc 3 2 3 3 1 0 total 5 bad pair return 5 exampl 2 input num 12345 output 0 explan bad pair constraint 1 numslength 105 1 numsi 109 countnumberofbadpair
robot stand infinit number line initi coordin given 0index integ array num start move given command move robot move unit distanc second given string denot direct robot move command l mean robot move toward left side neg side number line wherea r mean robot move toward right side posit side number line two robot collid start move opposit direct return sum distanc pair robot second command sinc sum larg return modulo 109 7 note two robot index j pair ij pair ji consid pair robot collid instantli chang direct without wast time collis happen two robot share place moment exampl robot posit 0 go right anoth posit 2 go left next second theyll 1 chang direct next second first one 0 head left anoth 2 head right exampl robot posit 0 go right anoth posit 1 go left next second first one 0 head left anoth 1 head right exampl 1 input num 202 rll 3 output 8 explan 1 second posit 111 robot index 0 move left robot index 1 move right 2 second posit 200 robot index 1 move left robot index 2 move right 3 second posit 311 distanc robot index 0 1 abs3 1 2 distanc robot index 0 2 abs3 1 4 distanc robot index 1 2 abs1 1 2 sum pair distanc 2 4 2 8 exampl 2 input num 10 rl 2 output 5 explan 1 second posit 21 2 second posit 32 distanc two robot abs2 3 5 constraint 2 numslength 105 2 109 numsi 2 109 0 109 numslength slength consist l r numsi uniqu movementofrobot
given string return number palindrom substr string palindrom read backward forward substr contigu sequenc charact within string exampl 1 input abc output 3 explan three palindrom string b c exampl 2 input aaa output 6 explan six palindrom string aa aa aaa constraint 1 slength 1000 consist lowercas english letter palindromicsubstr
given posit integ n repres number node undirect graph node label 1 n also given 2d integ array edg edgesi ai bi indic bidirect edg node ai bi notic given graph may disconnect divid node graph group 1index node graph belong exactli one group everi pair node graph connect edg ai bi ai belong group index x bi belong group index x 1 return maximum number group ie maximum divid node return 1 imposs group node given condit exampl 1 input n 6 edg 121415262346 output 4 explan shown imag add node 5 first group add node 1 second group add node 2 4 third group add node 3 6 fourth group see everi edg satisfi shown creat fifth group move node third fourth group least edg satisfi exampl 2 input n 3 edg 122331 output 1 explan add node 1 first group node 2 second group node 3 third group satisfi first two edg see third edg satisfi shown group possibl constraint 1 n 500 1 edgeslength 104 edgesilength 2 1 ai bi n ai bi one edg pair vertic dividenodesintothemaximumnumberofgroup
famili tree root 0 consist n node number 0 n 1 given 0index integ array parent parentsi parent node sinc node 0 root parents0 1 105 genet valu repres integ inclus rang 1 105 given 0index integ array num numsi distinct genet valu node return array an length n ansi smallest genet valu miss subtre root node subtre root node x contain node x descend node exampl 1 input parent 1002 num 1234 output 5111 explan answer subtre calcul follow 0 subtre contain node 0123 valu 1234 5 smallest miss valu 1 subtre contain node 1 valu 2 1 smallest miss valu 2 subtre contain node 23 valu 34 1 smallest miss valu 3 subtre contain node 3 valu 4 1 smallest miss valu exampl 2 input parent 101033 num 546213 output 711421 explan answer subtre calcul follow 0 subtre contain node 012345 valu 546213 7 smallest miss valu 1 subtre contain node 12 valu 46 1 smallest miss valu 2 subtre contain node 2 valu 6 1 smallest miss valu 3 subtre contain node 345 valu 213 4 smallest miss valu 4 subtre contain node 4 valu 1 2 smallest miss valu 5 subtre contain node 5 valu 3 1 smallest miss valu exampl 3 input parent 1230241 num 2345678 output 1111111 explan valu 1 miss subtre constraint n parentslength numslength 2 n 105 0 parentsi n 1 0 parents0 1 parent repres valid tree 1 numsi 105 numsi distinct smallestmissinggeneticvalueineachsubtre
given integ array num need find one continu subarray sort subarray nondecreas order whole array sort nondecreas order return shortest subarray output length exampl 1 input num 264810915 output 5 explan need sort 6 4 8 10 9 ascend order make whole array sort ascend order exampl 2 input num 1234 output 0 exampl 3 input num 1 output 0 constraint 1 numslength 104 105 numsi 105 follow solv time complex shortestunsortedcontinuoussubarray
bookstor owner store open n minut everi minut number custom enter store given integ array custom length n customersi number custom enter store start ith minut custom leav end minut minut bookstor owner grumpi given binari array grumpi grumpyi 1 bookstor owner grumpi ith minut 0 otherwis bookstor owner grumpi custom minut satisfi otherwis satisfi bookstor owner know secret techniqu keep grumpi minut consecut minut use return maximum number custom satisfi throughout day exampl 1 input custom 10121175 grumpi 01010101 minut 3 output 16 explan bookstor owner keep grumpi last 3 minut maximum number custom satisfi 1 1 1 1 7 5 16 exampl 2 input custom 1 grumpi 0 minut 1 output 1 constraint n customerslength grumpylength 1 minut n 2 104 0 customersi 1000 grumpyi either 0 1 grumpybookstoreown
given integ array num reorder nums0 nums1 nums2 nums3 may assum input array alway valid answer exampl 1 input num 151164 output 161514 explan 141516 also accept exampl 2 input num 132231 output 231312 constraint 1 numslength 5 104 0 numsi 5000 guarante answer given input num follow time andor inplac o1 extra space wigglesortii
data structur employe inform includ employe uniqu id import valu direct subordin id given array employe employe employeesiid id ith employe employeesiimport import valu ith employe employeesisubordin list id direct subordin ith employe given integ id repres employe id return total import valu employe direct indirect subordin exampl 1 input employe 15232333 id 1 output 11 explan employe 1 import valu 5 two direct subordin employe 2 employe 3 import valu 3 thu total import valu employe 1 5 3 3 11 exampl 2 input employe 12553 id 5 output 3 explan employe 5 import valu 3 direct subordin thu total import valu employe 5 3 constraint 1 employeeslength 2000 1 employeesiid 2000 employeesiid uniqu 100 employeesiimport 100 one employe one direct leader may sever subordin id employeesisubordin valid id employeeimport
exam room n seat singl row label 0 n 1 student enter room must sit seat maxim distanc closest person multipl seat sit seat lowest number one room student sit seat number 0 design class simul mention exam room implement examroom class examroomint n initi object exam room number seat n int seat return label seat next student set void leaveint p indic student sit seat p leav room guarante student sit seat p exampl 1 input examroom seat seat seat seat leav seat 10 4 output null 0 9 4 2 null 5 explan examroom examroom new examroom10 examroomseat return 0 one room student sit seat number 0 examroomseat return 9 student sit last seat number 9 examroomseat return 4 student sit last seat number 4 examroomseat return 2 student sit last seat number 2 examroomleave4 examroomseat return 5 student sit last seat number 5 constraint 1 n 109 guarante student sit seat p 104 call made seat leav examroom
given array num consist posit integ start score 0 appli follow algorithm choos smallest integ array mark tie choos one smallest index add valu chosen integ score mark chosen element two adjac element exist repeat array element mark return score get appli algorithm exampl 1 input num 213452 output 7 explan mark element follow 1 smallest unmark element mark two adjac element 213452 2 smallest unmark element mark left adjac element 213452 4 remain unmark element mark 213452 score 1 2 4 7 exampl 2 input num 235132 output 5 explan mark element follow 1 smallest unmark element mark two adjac element 235132 2 smallest unmark element sinc two choos leftmost one mark one index 0 right adjac element 235132 2 remain unmark element mark 235132 score 1 2 2 5 constraint 1 numslength 105 1 numsi 106 findscoreofanarrayaftermarkingallel
design stacklik data structur push element stack pop frequent element stack implement freqstack class freqstack construct empti frequenc stack void pushint val push integ val onto top stack int pop remov return frequent element stack tie frequent element element closest stack top remov return exampl 1 input freqstack push push push push push push pop pop pop pop 5 7 5 7 4 5 output null null null null null null null 5 7 5 4 explan freqstack freqstack new freqstack freqstackpush5 stack 5 freqstackpush7 stack 57 freqstackpush5 stack 575 freqstackpush7 stack 5757 freqstackpush4 stack 57574 freqstackpush5 stack 575745 freqstackpop return 5 5 frequent stack becom 57574 freqstackpop return 7 5 7 frequent 7 closest top stack becom 5754 freqstackpop return 5 5 frequent stack becom 574 freqstackpop return 4 4 5 7 frequent 4 closest top stack becom 57 constraint 0 val 109 2 104 call made push pop guarante least one element stack call pop maximumfrequencystack
given head singli link list return middl node link list two middl node return second middl node exampl 1 input head 12345 output 345 explan middl node list node 3 exampl 2 input head 123456 output 456 explan sinc list two middl node valu 3 4 return second one constraint number node list rang 1 100 1 nodev 100 middleofthelinkedlist
given x n binari matrix grid cell either 0 empti 1 occupi given stamp size stampheight x stampwidth want fit stamp follow given restrict requir cover empti cell cover occupi cell put mani stamp want stamp overlap stamp allow rotat stamp must stay complet insid grid return true possibl fit stamp follow given restrict requir otherwis return fals exampl 1 input grid 10001000100010001000 stampheight 4 stampwidth 3 output true explan two overlap stamp label 1 2 imag abl cover empti cell exampl 2 input grid 1000010000100001 stampheight 2 stampwidth 2 output fals explan way fit stamp onto empti cell without stamp go outsid grid constraint gridlength n gridrlength 1 n 105 1 n 2 105 gridrc either 0 1 1 stampheight stampwidth 105 stampingthegrid
sql schema pandan schema tabl view column name type articleid int authorid int viewerid int viewdat date tabl may duplic row word primari key tabl sql row tabl indic viewer view articl written author date note equal authorid viewerid indic person find author view least one articl return result tabl sort id ascend order result format follow exampl exampl 1 input view tabl articleid authorid viewerid viewdat 1 3 5 20190801 1 3 6 20190802 2 7 7 20190801 2 7 6 20190802 4 7 1 20190722 3 4 4 20190721 3 4 4 20190721 output id 4 7 articleviewsi
along long librari corridor line seat decor plant given 0index string corridor length n consist letter p repres seat p repres plant one room divid alreadi instal left index 0 anoth right index n 1 addit room divid instal posit indic 1 1 n 1 one divid instal divid corridor nonoverlap section section exactli two seat number plant may multipl way perform divis two way differ posit room divid instal first way second way return number way divid corridor sinc answer may larg return modulo 109 7 way return 0 exampl 1 input corridor ssppsp output 3 explan 3 differ way divid corridor black bar imag indic two room divid alreadi instal note way section exactli two seat exampl 2 input corridor ppspsp output 1 explan 1 way divid corridor instal addit divid instal would creat section exactli two seat exampl 3 input corridor output 0 explan way divid corridor alway section exactli two seat constraint n corridorlength 1 n 105 corridori either p numberofwaystodividealongcorridor
given array arr posit integ also given array queri queriesi lefti righti queri comput xor element lefti righti arrlefti xor arrlefti 1 xor xor arrrighti return array answer answeri answer ith queri exampl 1 input arr 1348 queri 01120333 output 27148 explan binari represent element array 1 0001 3 0011 4 0100 8 1000 xor valu queri 01 1 xor 3 2 12 3 xor 4 7 03 1 xor 3 xor 4 xor 8 14 33 8 exampl 2 input arr 48210 queri 23130003 output 8044 constraint 1 arrlength querieslength 3 104 1 arri 109 queriesilength 2 0 lefti righti arrlength xorqueriesofasubarray
given array order repres order custom done restaur specif ordersicustomernameitablenumberifooditemi customernamei name custom tablenumberi tabl custom sit fooditemi item custom order return restaur “ display tabl ” “ display tabl ” tabl whose row entri denot mani food item tabl order first column tabl number remain column correspond food item alphabet order first row header whose first column “ tabl ” follow name food item note custom name part tabl addit row sort numer increas order exampl 1 input order david3cevichecorina10beef burritodavid3fri chickencarla5watercarla5cevicherous3cevich output tablebeef burritocevichefri chickenwater3021050101101000 explan display tabl look like tablebeef burritocevichefri chickenwat 3 0 2 1 0 5 0 1 0 1 10 1 0 0 0 tabl 3 david order cevich fri chicken rou order cevich tabl 5 carla order water cevich tabl 10 corina order beef burrito exampl 2 input order james12fri chickenratesh12fri chickenamadeus12fri chickenadam1canadian wafflesbrianna1canadian waffl output tablecanadian wafflesfri chicken1201203 explan tabl 1 adam brianna order canadian waffl tabl 12 jame ratesh amadeu order fri chicken exampl 3 input order laura2bean burritojhon2beef burritomelissa2soda output tablebean burritobeef burritosoda2111 constraint 1 orderslength 5 104 ordersilength 3 1 customernameilength fooditemilength 20 customernamei fooditemi consist lowercas uppercas english letter space charact tablenumberi valid integ 1 500 displaytableoffoodordersinarestaur
given 0index integ array num partit array one contigu subarray call partit array valid obtain subarray satisfi one follow condit subarray consist exactli 2 equal element exampl subarray 22 good subarray consist exactli 3 equal element exampl subarray 444 good subarray consist exactli 3 consecut increas element differ adjac element 1 exampl subarray 345 good subarray 135 return true array least one valid partit otherwis return fals exampl 1 input num 44456 output true explan array partit subarray 44 456 partit valid return true exampl 2 input num 1112 output fals explan valid partit array constraint 2 numslength 105 1 numsi 106 checkifthereisavalidpartitionforthearray
given array string equat repres relationship variabl string equationsi length 4 take one two differ form xiyi xiyiher xi yi lowercas letter necessarili differ repres onelett variabl name return true possibl assign integ variabl name satisfi given equat fals otherwis exampl 1 input equat abba output fals explan assign say 1 b 1 first equat satisfi second way assign variabl satisfi equat exampl 2 input equat baab output true explan could assign 1 b 1 satisfi equat constraint 1 equationslength 500 equationsilength 4 equationsi0 lowercas letter equationsi1 either equationsi2 equationsi3 lowercas letter satisfiabilityofequalityequ
given nest list integ nestedlist element either integ list whose element may also integ list implement iter flatten implement nestediter class nestediteratorlistnestedinteg nestedlist initi iter nest list nestedlist int next return next integ nest list boolean hasnext return true still integ nest list fals otherwis code test follow pseudocod initi iter nestedlist re iteratorhasnext append iteratornext end re return re re match expect flatten list code judg correct exampl 1 input nestedlist 11211 output 11211 explan call next repeatedli hasnext return fals order element return next 11211 exampl 2 input nestedlist 146 output 146 explan call next repeatedli hasnext return fals order element return next 146 constraint 1 nestedlistlength 500 valu integ nest list rang 106 106 flattennestedlistiter
posit integ magic divis either b given three integ n b return nth magic number sinc answer may larg return modulo 109 7 exampl 1 input n 1 2 b 3 output 2 exampl 2 input n 4 2 b 3 output 6 constraint 1 n 109 2 b 4 104 nthmagicalnumb
given integ array job jobsi amount time take complet ith job k worker assign job job assign exactli one worker work time worker sum time take complet job assign goal devis optim assign maximum work time worker minim return minimum possibl maximum work time assign exampl 1 input job 323 k 3 output 3 explan assign person one job maximum time 3 exampl 2 input job 12478 k 2 output 11 explan assign job follow way worker 1 1 2 8 work time 1 2 8 11 worker 2 4 7 work time 4 7 11 maximum work time 11 constraint 1 k jobslength 12 1 jobsi 107 findminimumtimetofinishalljob
given 0index n x n integ matrix grid return number pair ri cj row ri column cj equal row column pair consid equal contain element order ie equal array exampl 1 input grid 321176277 output 1 explan 1 equal row column pair row 2 column 1 277 exampl 2 input grid 3122144524222422 output 3 explan 3 equal row column pair row 0 column 0 3122 row 2 column 2 2422 row 3 column 2 2422 constraint n gridlength gridilength 1 n 200 1 gridij 105 equalrowandcolumnpair
given integ array num duplic maximum binari tree built recurs num use follow algorithm creat root node whose valu maximum valu num recurs build left subtre subarray prefix left maximum valu recurs build right subtre subarray suffix right maximum valu return maximum binari tree built num exampl 1 input num 321605 output 635null20nullnull1 explan recurs call follow largest valu 321605 6 left prefix 321 right suffix 05 largest valu 321 3 left prefix right suffix 21 empti array child largest valu 21 2 left prefix right suffix 1 empti array child one element child node valu 1 largest valu 05 5 left prefix 0 right suffix one element child node valu 0 empti array child exampl 2 input num 321 output 3null2null1 constraint 1 numslength 1000 0 numsi 1000 integ num uniqu maximumbinarytre
n item belong zero one group groupi group ith item belong equal 1 ith item belong group item group zero index group item belong return sort list item item belong group next sort list relat item beforeitemsi list contain item come ith item sort array left ith item return solut one solut return empti list solut exampl 1 input n 8 2 group 11100101 beforeitem 65636 output 63415207 exampl 2 input n 8 2 group 11100101 beforeitem 65634 output explan exampl 1 except 4 need 6 sort list constraint 1 n 3 104 grouplength beforeitemslength n 1 groupi 1 0 beforeitemsilength n 1 0 beforeitemsij n 1 beforeitemsij beforeitemsi contain duplic element sortitemsbygroupsrespectingdepend
sql schema tabl stadium column name type id int visitd date peopl int visitd primari key tabl row tabl contain visit date visit id stadium number peopl visit two row visitd id increas date increas well write sql queri display record three row consecut id number peopl greater equal 100 return result tabl order visitd ascend order queri result format follow exampl exampl 1 input stadium tabl id visitd peopl 1 20170101 10 2 20170102 109 3 20170103 150 4 20170104 99 5 20170105 145 6 20170106 1455 7 20170107 199 8 20170109 188 output id visitd peopl 5 20170105 145 6 20170106 1455 7 20170107 199 8 20170109 188 explan four row id 5 6 7 8 consecut id 100 peopl attend note row 8 includ even though visitd next day row 7 row id 2 3 includ need least three consecut id humantrafficofstadium
given 0index integ array task tasksi repres difficulti level task round complet either 2 3 task difficulti level return minimum round requir complet task 1 possibl complet task exampl 1 input task 2233244444 output 4 explan complet task possibl plan first round complet 3 task difficulti level 2 second round complet 2 task difficulti level 3 third round complet 3 task difficulti level 4 fourth round complet 2 task difficulti level 4 shown task complet fewer 4 round answer 4 exampl 2 input task 233 output 1 explan 1 task difficulti level 2 round complet either 2 3 task difficulti level henc complet task answer 1 constraint 1 taskslength 105 1 tasksi 109 minimumroundstocompletealltask
given head singli link list sort list use insert sort return sort list head step insert sort algorithm insert sort iter consum one input element repetit grow sort output list iter insert sort remov one element input data find locat belong within sort list insert repeat input element remain follow graphic exampl insert sort algorithm partial sort list black initi contain first element list one element red remov input data insert inplac sort list iter exampl 1 input head 4213 output 1234 exampl 2 input head 15340 output 10345 constraint number node list rang 1 5000 5000 nodev 5000 insertionsortlist
given sort array consist integ everi element appear exactli twice except one element appear exactli return singl element appear solut must run olog n time o1 space exampl 1 input num 112334488 output 2 exampl 2 input num 3377101111 output 10 constraint 1 numslength 105 0 numsi 105 singleelementinasortedarray
given posit integ k also given 2d integ array rowcondit size n rowconditionsi abovei belowi 2d integ array colcondit size colconditionsi lefti righti two array contain integ 1 k build k x k matrix contain number 1 k exactli remain cell valu 0 matrix also satisfi follow condit number abovei appear row strictli row number belowi appear 0 n 1 number lefti appear column strictli left column number righti appear 0 1 return matrix satisfi condit answer exist return empti matrix exampl 1 input k 3 rowcondit 1232 colcondit 2132 output 300001020 explan diagram show valid exampl matrix satisfi condit row condit follow number 1 row 1 number 2 row 2 1 2 matrix number 3 row 0 number 2 row 2 3 2 matrix column condit follow number 2 column 1 number 1 column 2 2 left 1 matrix number 3 column 0 number 2 column 1 3 left 2 matrix note may multipl correct answer exampl 2 input k 3 rowcondit 12233123 colcondit 21 output explan first two condit 3 1 third condit need 3 1 satisfi matrix satisfi condit return empti matrix constraint 2 k 400 1 rowconditionslength colconditionslength 104 rowconditionsilength colconditionsilength 2 1 abovei belowi lefti righti k abovei belowi lefti righti buildamatrixwithcondit
given asynchron function fn time millisecond return new time limit version input function fn take argument provid time limit function time limit function follow rule fn complet within time limit millisecond time limit function resolv result execut fn exce time limit time limit function reject string time limit exceed exampl 1 input fn async n await new promiser settimeoutr 100 return n n input 5 50 output rejectedtim limit exceededtime50 explan const limit timelimitfn const start performancenow let result tri const re await limitedinput result resolv re time mathfloorperformancenow start catch err result reject err time mathfloorperformancenow start consolelogresult output provid function set resolv 100m howev time limit set 50m reject t50m time limit reach exampl 2 input fn async n await new promiser settimeoutr 100 return n n input 5 150 output resolved25time100 explan function resolv 5 5 25 t100m time limit never reach exampl 3 input fn async b await new promiser settimeoutr 120 return b input 510 150 output resolved15time120 explan function resolv 5 10 15 t120m time limit never reach exampl 4 input fn async throw error input 1000 output rejectederrortime0 explan function immedi throw error constraint 0 inputslength 10 0 1000 fn return promis promisetimelimit
given integ n denot number node weight direct graph node number 0 n 1 also given 2d integ array edg edgesi fromi toi weighti denot exist direct edg fromi toi weight weighti lastli given three distinct integ src1 src2 dest denot three distinct node graph return minimum weight subgraph graph possibl reach dest src1 src2 via set edg subgraph case subgraph exist return 1 subgraph graph whose vertic edg subset origin graph weight subgraph sum weight constitu edg exampl 1 input n 6 edg 022056103145211233234342451 src1 0 src2 1 dest 5 output 9 explan figur repres input graph blue edg repres one subgraph yield optim answer note subgraph 103056 also yield optim answer possibl get subgraph less weight satisfi constraint exampl 2 input n 3 edg 011211 src1 0 src2 1 dest 2 output 1 explan figur repres input graph seen exist path node 1 node 2 henc subgraph satisfi constraint constraint 3 n 105 0 edgeslength 105 edgesilength 3 0 fromi toi src1 src2 dest n 1 fromi toi src1 src2 dest pairwis distinct 1 weighti 105 minimumweightedsubgraphwiththerequiredpath
compani organ meet list n employe wait invit arrang larg circular tabl capabl seat number employe employe number 0 n 1 employe favorit person attend meet sit next favorit person tabl favorit person employe themself given 0index integ array favorit favoritei denot favorit person ith employe return maximum number employe invit meet exampl 1 input favorit 2212 output 3 explan figur show compani invit employe 0 1 2 seat round tabl employe invit employe 2 sit besid employe 0 1 3 simultan note compani also invit employe 1 2 3 give desir seat maximum number employe invit meet 3 exampl 2 input favorit 120 output 3 explan employe favorit person least one employe way compani invit invit everi employe seat arrang figur given exampl 1 employe 0 sit employe 2 1 employe 1 sit employe 0 2 employe 2 sit employe 1 0 maximum number employe invit meet 3 exampl 3 input favorit 30141 output 4 explan figur show compani invit employe 0 1 3 4 seat round tabl employe 2 invit two spot next favorit employe 1 taken compani leav meet maximum number employe invit meet 4 constraint n favoritelength 2 n 105 0 favoritei n 1 favoritei maximumemployeestobeinvitedtoameet
given string word insert letter b c anywher number time return minimum number letter must insert word becom valid string call valid form concaten string abc sever time exampl 1 input word b output 2 explan insert letter right b letter c right next obtain valid string abc exampl 2 input word aaa output 6 explan insert letter b c next obtain valid string abcabcabc exampl 3 input word abc output 0 explan word alreadi valid modif need constraint 1 wordlength 50 word consist letter b c minimumadditionstomakevalidstr
given array string name size n creat n folder file system ith minut creat folder name namesi sinc two file name enter folder name previous use system suffix addit name form k k smallest posit integ obtain name remain uniqu return array string length n ansi actual name system assign ith folder creat exampl 1 input name pesfifagtapes2019 output pesfifagtapes2019 explan let see file system creat folder name pe assign remain pe fifa assign remain fifa gta assign remain gta pes2019 assign remain pes2019 exampl 2 input name gtagta1gtaavalon output gtagta1gta2avalon explan let see file system creat folder name gta assign remain gta gta1 assign remain gta1 gta name reserv system add k sinc gta1 also reserv system put k 2 becom gta2 avalon assign remain avalon exampl 3 input name onepieceonepiece1onepiece2onepiece3onepiec output onepieceonepiece1onepiece2onepiece3onepiece4 explan last folder creat smallest posit valid k 4 becom onepiece4 constraint 1 nameslength 5 104 1 namesilength 20 namesi consist lowercas english letter digit andor round bracket makingfilenamesuniqu
given n point plane distinct pointsi xi yi boomerang tupl point j k distanc j equal distanc k order tupl matter return number boomerang exampl 1 input point 001020 output 2 explan two boomerang 100020 102000 exampl 2 input point 112233 output 2 exampl 3 input point 11 output 0 constraint n pointslength 1 n 500 pointsilength 2 104 xi yi 104 point uniqu numberofboomerang
given two posit integ array spell potion length n respect spellsi repres strength ith spell potionsj repres strength jth potion also given integ success spell potion pair consid success product strength least success return integ array pair length n pairsi number potion form success pair ith spell exampl 1 input spell 513 potion 12345 success 7 output 403 explan 0th spell 5 12345 510152025 4 pair success 1st spell 1 12345 12345 0 pair success 2nd spell 3 12345 3691215 3 pair success thu 403 return exampl 2 input spell 312 potion 858 success 16 output 202 explan 0th spell 3 858 241524 2 pair success 1st spell 1 858 858 0 pair success 2nd spell 2 858 161016 2 pair success thu 202 return constraint n spellslength potionslength 1 n 105 1 spellsi potionsi 105 1 success 1010 successfulpairsofspellsandpot
given string return last substr lexicograph order exampl 1 input abab output bab explan substr ab aba abab b ba bab lexicograph maximum substr bab exampl 2 input leetcod output tcode constraint 1 slength 4 105 contain lowercas english letter lastsubstringinlexicographicalord
given string consist letter b singl step remov one palindrom subsequ return minimum number step make given string empti string subsequ given string gener delet charact given string without chang order note subsequ necessarili need contigu string call palindrom one read backward well forward exampl 1 input ababa output 1 explan alreadi palindrom entireti remov singl step exampl 2 input abb output 2 explan abb bb remov palindrom subsequ bb exampl 3 input baabb output 2 explan baabb b remov palindrom subsequ baab b constraint 1 slength 1000 si either b removepalindromicsubsequ
given two array integ equal length return maximum valu arr1i arr1j arr2i arr2j j maximum taken 0 j arr1length exampl 1 input arr1 1234 arr2 1456 output 13 exampl 2 input arr1 125010 arr2 02174 output 20 constraint 2 arr1length arr2length 40000 106 arr1i arr2i 106 maximumofabsolutevalueexpress
given x n matrix board repres current state crossword puzzl crossword contain lowercas english letter solv word repres empti cell repres block cell word place horizont left right right left vertic top bottom bottom top board occupi cell contain charact cell letter place must either empti match letter alreadi board must empti cell lowercas letter directli left right word word place horizont must empti cell lowercas letter directli word word place vertic given string word return true word place board fals otherwis exampl 1 input board c word abc output true explan word abc place shown top bottom exampl 2 input board c word ac output fals explan imposs place word alway spacelett exampl 3 input board c word ca output true explan word ca place shown right left constraint boardlength n boardilength 1 n 2 105 boardij lowercas english letter 1 wordlength maxm n word contain lowercas english letter checkifwordcanbeplacedincrossword
given array integ num half integ num odd half even sort array whenev numsi odd odd whenev numsi even even return answer array satisfi condit exampl 1 input num 4257 output 4527 explan 4725 2547 2745 would also accept exampl 2 input num 23 output 23 constraint 2 numslength 2 104 numslength even half integ num even 0 numsi 1000 follow could solv inplac sortarraybyparityii
given integ n return number string length n consist vowel e u lexicograph sort string lexicograph sort valid si come si1 alphabet exampl 1 input n 1 output 5 explan 5 sort string consist vowel aeiou exampl 2 input n 2 output 15 explan 15 sort string consist vowel aaaeaiaoaueeeieoeuiiioiuooouuu note ea valid string sinc e come alphabet exampl 3 input n 33 output 66045 constraint 1 n 50 countsortedvowelstr
given 1index array integ number alreadi sort nondecreas order find two number add specif target number let two number numbersindex1 numbersindex2 1 index1 index2 numberslength return indic two number index1 index2 ad one integ array index1 index2 length 2 test gener exactli one solut may use element twice solut must use constant extra space exampl 1 input number 271115 target 9 output 12 explan sum 2 7 9 therefor index1 1 index2 2 return 1 2 exampl 2 input number 234 target 6 output 13 explan sum 2 4 6 therefor index1 1 index2 3 return 1 3 exampl 3 input number 10 target 1 output 12 explan sum 1 0 1 therefor index1 1 index2 2 return 1 2 constraint 2 numberslength 3 104 1000 numbersi 1000 number sort nondecreas order 1000 target 1000 test gener exactli one solut twosumiiinputarrayissort
given array num obtain subsequ array whose sum element strictli greater sum non includ element subsequ multipl solut return subsequ minimum size still exist multipl solut return subsequ maximum total sum element subsequ array obtain eras possibl zero element array note solut given constraint guarante uniqu also return answer sort nonincreas order exampl 1 input num 431098 output 109 explan subsequ 109 108 minim sum element strictli greater sum element includ howev subsequ 109 maximum total sum element exampl 2 input num 44767 output 776 explan subsequ 77 sum element equal 14 strictli greater sum element includ 14 4 4 6 therefor subsequ 767 minim satisfi condit note subsequ return nondecreas order constraint 1 numslength 500 1 numsi 100 minimumsubsequenceinnonincreasingord
given array num consist nonneg integ also given queri array queriesi xi mi answer ith queri maximum bitwis xor valu xi element num exceed mi word answer maxnumsj xor xi j numsj mi element num larger mi answer 1 return integ array answer answerlength querieslength answeri answer ith queri exampl 1 input num 01234 queri 311356 output 337 explan 1 0 1 two integ greater 1 0 xor 3 3 1 xor 3 2 larger two 3 2 1 xor 2 3 3 5 xor 2 7 exampl 2 input num 524663 queri 1248163 output 1515 constraint 1 numslength querieslength 105 queriesilength 2 0 numsj xi mi 109 maximumxorwithanelementfromarray
given floatingpoint number hour repres amount time reach offic commut offic must take n train sequenti order also given integ array dist length n disti describ distanc kilomet ith train ride train depart integ hour may need wait train ride exampl 1st train ride take 15 hour must wait addit 05 hour depart 2nd train ride 2 hour mark return minimum posit integ speed kilomet per hour train must travel reach offic time 1 imposs time test gener answer exceed 107 hour two digit decim point exampl 1 input dist 132 hour 6 output 1 explan speed 1 first train ride take 11 1 hour sinc alreadi integ hour depart immedi 1 hour mark second train take 31 3 hour sinc alreadi integ hour depart immedi 4 hour mark third train take 21 2 hour arriv exactli 6 hour mark exampl 2 input dist 132 hour 27 output 3 explan speed 3 first train ride take 13 033333 hour sinc integ hour wait 1 hour mark depart second train ride take 33 1 hour sinc alreadi integ hour depart immedi 2 hour mark third train take 23 066667 hour arriv 266667 hour mark exampl 3 input dist 132 hour 19 output 1 explan imposs earliest third train depart 2 hour mark constraint n distlength 1 n 105 1 disti 105 1 hour 109 two digit decim point hour minimumspeedtoarriveontim
given charact array key contain uniqu charact string array valu contain string length 2 also given anoth string array dictionari contain permit origin string decrypt implement data structur encrypt decrypt 0index string string encrypt follow process charact c string find index satisfi keysi c key replac c valuesi string note case charact string present key encrypt process carri empti string return string decrypt follow process substr length 2 occur even index string find valuesi multipl valid choos one mean string could multipl possibl string decrypt replac keysi string implement encrypt class encrypterchar key string valu string dictionari initi encrypt class key valu dictionari string encryptstr word1 encrypt word1 encrypt process describ return encrypt string int decryptstr word2 return number possibl string word2 could decrypt also appear dictionari exampl 1 input encrypt encrypt decrypt b c ei zf ei abcd acbd adbc badc dacb cadb cbda abad abcd eizfeiam output null eizfeiam 2 explan encrypt encrypt new encryptera b c ei zf ei abcd acbd adbc badc dacb cadb cbda abad encrypterencryptabcd return eizfeiam map ei b map zf c map ei map encrypterdecrypteizfeiam return 2 ei map c zf map b map thu possibl string decrypt abad cbad abcd cbcd 2 string abad abcd appear dictionari answer 2 constraint 1 keyslength valueslength 26 valuesilength 2 1 dictionarylength 100 1 dictionaryilength 100 keysi dictionaryi uniqu 1 word1length 2000 1 word2length 200 word1i appear key word2length even key valuesi dictionaryi word1 word2 contain lowercas english letter 200 call made encrypt decrypt total encryptanddecryptstr
given root binari tree return length diamet tree diamet binari tree length longest path two node tree path may may pass root length path two node repres number edg exampl 1 input root 12345 output 3 explan 3 length path 4213 5213 exampl 2 input root 12 output 1 constraint number node tree rang 1 104 100 nodev 100 diameterofbinarytre
given binari string consist zero one substr consid balanc zero one number zero equal number one insid substr notic empti substr consid balanc substr return length longest balanc substr substr contigu sequenc charact within string exampl 1 input 01000111 output 6 explan longest balanc substr 000111 length 6 exampl 2 input 00111 output 4 explan longest balanc substr 0011 length 4 exampl 3 input 111 output 0 explan balanc substr except empti substr answer 0 constraint 1 slength 50 0 si 1 findthelongestbalancedsubstringofabinarystr
given doubli link list contain node next pointer previou pointer addit child pointer child pointer may may point separ doubli link list also contain special node child list may one children produc multilevel data structur shown exampl given head first level list flatten list node appear singlelevel doubli link list let curr node child list node child list appear curr currnext flatten list return head flatten list node list must child pointer set null exampl 1 input head 123456nullnullnull78910nullnull1112 output 123781112910456 explan multilevel link list input shown flatten multilevel link list becom exampl 2 input head 12null3 output 132 explan multilevel link list input shown flatten multilevel link list becom exampl 3 input head output explan could empti list input constraint number node exceed 1000 1 nodev 105 multilevel link list repres test case use multilevel link list exampl 1 123456null 78910null 1112null serial level follow 123456null 78910null 1112null serial level togeth add null level signifi node connect upper node previou level serial becom 1 2 3 4 5 6 null null null 7 8 9 10 null null 11 12 null merg serial level remov trail null obtain 123456nullnullnull78910nullnull1112 flattenamultileveldoublylinkedlist
0index array num length n initi element uncolor valu 0 given 2d integ array queri queriesi indexi colori queri color index indexi color colori array num return array answer length queri answeri number adjac element color ith queri formal answeri number indic j 0 j n 1 numsj numsj 1 numsj 0 ith queri exampl 1 input n 4 queri 0212311121 output 01102 explan initi array num 0000 0 denot uncolor element array 1st queri num 2000 count adjac element color 0 2nd queri num 2200 count adjac element color 1 3rd queri num 2201 count adjac element color 1 4th queri num 2101 count adjac element color 0 5th queri num 2111 count adjac element color 2 exampl 2 input n 1 queri 0100000 output 0 explan initi array num 0 0 denot uncolor element array 1st queri num 100000 count adjac element color 0 constraint 1 n 105 1 querieslength 105 queriesilength 2 0 indexi n 1 1 colori 105 numberofadjacentelementswiththesamecolor
given integ num return string repres hexadecim represent neg integ two ’ complement method use letter answer string lowercas charact lead zero answer except zero note allow use builtin librari method directli solv problem exampl 1 input num 26 output 1a exampl 2 input num 1 output ffffffff constraint 231 num 231 1 convertanumbertohexadecim
underground railway system keep track custom travel time differ station use data calcul averag time take travel one station anoth implement undergroundsystem class void checkinint id string stationnam int custom card id equal id check station stationnam time custom check one place time void checkoutint id string stationnam int custom card id equal id check station stationnam time doubl getaveragetimestr startstat string endstat return averag time take travel startstat endstat averag time comput previou travel time startstat endstat happen directli mean check startstat follow check endstat time take travel startstat endstat may differ time take travel endstat startstat least one custom travel startstat endstat getaveragetim call may assum call checkin checkout method consist custom check time t1 check time t2 t1 t2 event happen chronolog order exampl 1 input undergroundsystemcheckincheckincheckincheckoutcheckoutcheckoutgetaveragetimegetaveragetimecheckingetaveragetimecheckoutgetaveragetim 45leyton332paradise827leyton1045waterloo1527waterloo2032cambridge22paradisecambridgeleytonwaterloo10leyton24leytonwaterloo10waterloo38leytonwaterloo output nullnullnullnullnullnullnull14000001100000null1100000null1200000 explan undergroundsystem undergroundsystem new undergroundsystem undergroundsystemcheckin45 leyton 3 undergroundsystemcheckin32 paradis 8 undergroundsystemcheckin27 leyton 10 undergroundsystemcheckout45 waterloo 15 custom 45 leyton waterloo 153 12 undergroundsystemcheckout27 waterloo 20 custom 27 leyton waterloo 2010 10 undergroundsystemcheckout32 cambridg 22 custom 32 paradis cambridg 228 14 undergroundsystemgetaveragetimeparadis cambridg return 1400000 one trip paradis cambridg 14 1 14 undergroundsystemgetaveragetimeleyton waterloo return 1100000 two trip leyton waterloo 10 12 2 11 undergroundsystemcheckin10 leyton 24 undergroundsystemgetaveragetimeleyton waterloo return 1100000 undergroundsystemcheckout10 waterloo 38 custom 10 leyton waterloo 3824 14 undergroundsystemgetaveragetimeleyton waterloo return 1200000 three trip leyton waterloo 10 12 14 3 12 exampl 2 input undergroundsystemcheckincheckoutgetaveragetimecheckincheckoutgetaveragetimecheckincheckoutgetaveragetim 10leyton310paradise8leytonparadise5leyton105paradise16leytonparadise2leyton212paradise30leytonparadis output nullnullnull500000nullnull550000nullnull666667 explan undergroundsystem undergroundsystem new undergroundsystem undergroundsystemcheckin10 leyton 3 undergroundsystemcheckout10 paradis 8 custom 10 leyton paradis 83 5 undergroundsystemgetaveragetimeleyton paradis return 500000 5 1 5 undergroundsystemcheckin5 leyton 10 undergroundsystemcheckout5 paradis 16 custom 5 leyton paradis 1610 6 undergroundsystemgetaveragetimeleyton paradis return 550000 5 6 2 55 undergroundsystemcheckin2 leyton 21 undergroundsystemcheckout2 paradis 30 custom 2 leyton paradis 3021 9 undergroundsystemgetaveragetimeleyton paradis return 666667 5 6 9 3 666667 constraint 1 id 106 1 stationnamelength startstationlength endstationlength 10 string consist uppercas lowercas english letter digit 2 104 call total checkin checkout getaveragetim answer within 105 actual valu accept designundergroundsystem
given integ array num ith bag contain numsi ball also given integ maxoper perform follow oper maxoper time take bag ball divid two new bag posit number ball exampl bag 5 ball becom two new bag 1 4 ball two new bag 2 3 ball penalti maximum number ball bag want minim penalti oper return minimum possibl penalti perform oper exampl 1 input num 9 maxoper 2 output 3 explan divid bag 9 ball two bag size 6 3 9 63 divid bag 6 ball two bag size 3 3 63 333 bag number ball 3 ball penalti 3 return 3 exampl 2 input num 2482 maxoper 4 output 2 explan divid bag 8 ball two bag size 4 4 2482 24442 divid bag 4 ball two bag size 2 2 24442 222442 divid bag 4 ball two bag size 2 2 222442 2222242 divid bag 4 ball two bag size 2 2 2222242 22222222 bag number ball 2 ball penalti 2 return 2 constraint 1 numslength 105 1 maxoper numsi 109 minimumlimitofballsinabag
set contain posit integ 1 2 3 4 5 implement smallestinfiniteset class smallestinfiniteset initi smallestinfiniteset object contain posit integ int popsmallest remov return smallest integ contain infinit set void addbackint num add posit integ num back infinit set alreadi infinit set exampl 1 input smallestinfiniteset addback popsmallest popsmallest popsmallest addback popsmallest popsmallest popsmallest 2 1 output null null 1 2 3 null 1 4 5 explan smallestinfiniteset smallestinfiniteset new smallestinfiniteset smallestinfinitesetaddback2 2 alreadi set chang made smallestinfinitesetpopsmallest return 1 sinc 1 smallest number remov set smallestinfinitesetpopsmallest return 2 remov set smallestinfinitesetpopsmallest return 3 remov set smallestinfinitesetaddback1 1 ad back set smallestinfinitesetpopsmallest return 1 sinc 1 ad back set smallest number remov set smallestinfinitesetpopsmallest return 4 remov set smallestinfinitesetpopsmallest return 5 remov set constraint 1 num 1000 1000 call made total popsmallest addback smallestnumberininfiniteset
given array integ arr even length n integ k want divid array exactli n 2 pair sum pair divis k return true find way fals otherwis exampl 1 input arr 12345106789 k 5 output true explan pair 19283746 510 exampl 2 input arr 123456 k 7 output true explan pair 1625 and34 exampl 3 input arr 123456 k 10 output fals explan tri possibl pair see way divid arr 3 pair sum divis 10 constraint arrlength n 1 n 105 n even 109 arri 109 1 k 105 checkifarraypairsaredivisiblebyk
design data structur effici find major element given subarray major element subarray element occur threshold time subarray implement majoritycheck class majoritycheckerint arr initi instanc class given array arr int queryint left int right int threshold return element subarray arrleftright occur least threshold time 1 element exist exampl 1 input majoritycheck queri queri queri 1 1 2 2 1 1 0 5 4 0 3 3 2 3 2 output null 1 1 2 explan majoritycheck majoritycheck new majoritychecker1 1 2 2 1 1 majoritycheckerquery0 5 4 return 1 majoritycheckerquery0 3 3 return 1 majoritycheckerquery2 3 2 return 2 constraint 1 arrlength 2 104 1 arri 2 104 0 left right arrlength threshold right left 1 2 threshold right left 1 104 call made queri onlinemajorityelementinsubarray
write function expect help develop test code take valu val return object follow two function tobev accept anoth valu return true two valu equal throw error equal nottobev accept anoth valu return true two valu equal throw error equal exampl 1 input func expect5tobe5 output valu true explan 5 5 express return true exampl 2 input func expect5tobenul output error equal explan 5 null express throw error equal exampl 3 input func expect5nottobenul output valu true explan 5 null express return true tobeornottob
sql schema tabl employe column name type employeeid int name varchar reportsto int age int employeeid primari key tabl tabl contain inform employe id manag report employe report anyon reportsto null problem consid manag employe least 1 employe report write sql queri report id name manag number employe report directli averag age report round nearest integ return result tabl order employeeid queri result format follow exampl exampl 1 input employe tabl employeeid name reportsto age 9 herci null 43 6 alic 9 41 4 bob 9 36 2 winston null 37 output employeeid name reportscount averageag 9 herci 2 39 explan herci 2 peopl report directli alic bob averag age 41362 385 39 round nearest integ thenumberofemployeeswhichreporttoeachemploye
design map allow follow map string key given valu return sum valu key prefix equal given string implement mapsum class mapsum initi mapsum object void insertstr key int val insert keyval pair map key alreadi exist origin keyvalu pair overridden new one int sumstr prefix return sum pair valu whose key start prefix exampl 1 input mapsum insert sum insert sum appl 3 ap app 2 ap output null null 3 null 5 explan mapsum mapsum new mapsum mapsuminsertappl 3 mapsumsumap return 3 appl 3 mapsuminsertapp 2 mapsumsumap return 5 appl app 3 2 5 constraint 1 keylength prefixlength 50 key prefix consist lowercas english letter 1 val 1000 50 call made insert sum mapsumpair
given integ n return smallest prime palindrom greater equal n integ prime exactli two divisor 1 note 1 prime number exampl 2 3 5 7 11 13 prime integ palindrom read left right right left exampl 101 12321 palindrom test case gener answer alway exist rang 2 2 108 exampl 1 input n 6 output 7 exampl 2 input n 8 output 11 exampl 3 input n 13 output 101 constraint 1 n 108 primepalindrom
given posit integ n return smallest posit integ multipl 2 n exampl 1 input n 5 output 10 explan smallest multipl 5 2 10 exampl 2 input n 6 output 6 explan smallest multipl 6 2 6 note number multipl constraint 1 n 150 smallestevenmultipl
given root binari tree return averag valu node level form array answer within 105 actual answer accept exampl 1 input root 3920nullnull157 output 30000014500001100000 explan averag valu node level 0 3 level 1 145 level 2 11 henc return 3 145 11 exampl 2 input root 3920157 output 30000014500001100000 constraint number node tree rang 1 104 231 nodev 231 1 averageoflevelsinbinarytre
given array num integ k xor segment left right left right xor element indic left right inclus numsleft xor numsleft1 xor xor numsright return minimum number element chang array xor segment size k equal zero exampl 1 input num 12030 k 1 output 3 explan modifi array 12030 00000 exampl 2 input num 345217347 k 3 output 3 explan modifi array 345217347 347347347 exampl 3 input num 124125126 k 3 output 3 explan modifi array 124125126 123123123 constraint 1 k numslength 2000 0 numsi 210 makethexorofallsegmentsequaltozero
x n binari grid matrix valu set 0 initi design algorithm randomli pick index j matrixij 0 flip 1 indic j matrixij 0 equal like return optim algorithm minim number call made builtin random function languag optim time space complex implement solut class solutionint int n initi object size binari matrix n int flip return random index j matrix matrixij 0 flip 1 void reset reset valu matrix 0 exampl 1 input solut flip flip flip reset flip 3 1 output null 1 0 2 0 0 0 null 2 0 explan solut solut new solution3 1 solutionflip return 1 0 00 10 20 equal like return solutionflip return 2 0 sinc 10 return 20 00 solutionflip return 0 0 base previous return indic 00 return solutionreset valu reset 0 return solutionflip return 2 0 00 10 20 equal like return constraint 1 n 104 least one free cell call flip 1000 call made flip reset randomflipmatrix
given string array string word string word length concaten substr substr contain string permut word concaten exampl word abcdef abcdef abefcd cdabef cdefab efabcd efcdab concaten string acdbef concaten substr concaten permut word return start indic concaten substr return answer order exampl 1 input barfoothefoobarman word foobar output 09 explan sinc wordslength 2 wordsilength 3 concaten substr length 6 substr start 0 barfoo concaten barfoo permut word substr start 9 foobar concaten foobar permut word output order matter return 90 fine exampl 2 input wordgoodgoodgoodbestword word wordgoodbestword output explan sinc wordslength 4 wordsilength 4 concaten substr length 16 substr length 16 equal concaten permut word return empti array exampl 3 input barfoofoobarthefoobarman word barfooth output 6912 explan sinc wordslength 3 wordsilength 3 concaten substr length 9 substr start 6 foobarth concaten foobarth permut word substr start 9 barthefoo concaten barthefoo permut word substr start 12 thefoobar concaten thefoobar permut word constraint 1 slength 104 1 wordslength 5000 1 wordsilength 30 wordsi consist lowercas english letter substringwithconcatenationofallword
total numcours cours take label 0 numcours 1 given array prerequisit prerequisitesi ai bi indic must take cours ai first want take cours bi exampl pair 0 1 indic take cours 0 take cours 1 prerequisit also indirect cours prerequisit cours b cours b prerequisit cours c cours prerequisit cours c also given array queri queriesj uj vj jth queri answer whether cours uj prerequisit cours vj return boolean array answer answerj answer jth queri exampl 1 input numcours 2 prerequisit 10 queri 0110 output falsetru explan pair 1 0 indic take cours 1 take cours 0 cours 0 prerequisit cours 1 opposit true exampl 2 input numcours 2 prerequisit queri 1001 output falsefals explan prerequisit cours independ exampl 3 input numcours 3 prerequisit 121020 queri 1012 output truetru constraint 2 numcours 100 0 prerequisiteslength numcours numcours 1 2 prerequisitesilength 2 0 ai bi n 1 ai bi pair ai bi uniqu prerequisit graph cycl 1 querieslength 104 0 ui vi n 1 ui vi coursescheduleiv
given two posit integ array num target length one oper choos two distinct indic j 0 j numslength set numsi numsi 2 set numsj numsj 2 two array consid similar frequenc element return minimum number oper requir make num similar target test case gener num alway similar target exampl 1 input num 8126 target 21410 output 2 explan possibl make num similar target two oper choos 0 j 2 num 10124 choos 1 j 2 num 10142 shown 2 minimum number oper need exampl 2 input num 125 target 413 output 1 explan make num similar target one oper choos 1 j 2 num 143 exampl 3 input num 11111 target 11111 output 0 explan array num alreadi similiar target constraint n numslength targetlength 1 n 105 1 numsi targeti 106 possibl make num similar target minimumnumberofoperationstomakearrayssimilar
given string consist lowercas english letter one oper follow select nonempti substr possibl entir string replac one charact previou charact english alphabet exampl b convert convert z return lexicograph smallest string obtain perform oper exactli substr contigu sequenc charact string string x lexicograph smaller string length xi come yi alphabet order first posit xi yi exampl 1 input cbabc output baabc explan appli oper substr start index 0 end index 1 inclus proven result string lexicograph smallest exampl 2 input acbbc output abaab explan appli oper substr start index 1 end index 4 inclus proven result string lexicograph smallest exampl 3 input leetcod output kddsbncd explan appli oper entir string proven result string lexicograph smallest constraint 1 slength 3 105 consist lowercas english letter lexicographicallysmalleststringaftersubstringoper
given string remov duplic letter everi letter appear must make sure result smallest lexicograph order among possibl result exampl 1 input bcabc output abc exampl 2 input cbacdcbc output acdb constraint 1 slength 104 consist lowercas english letter note question 1081 httpsleetcodecomproblemssmallestsubsequenceofdistinctcharact removeduplicatelett
given circl repres radiu xcenter ycenter axisalign rectangl repres x1 y1 x2 y2 x1 y1 coordin bottomleft corner x2 y2 coordin topright corner rectangl return true circl rectangl overlap otherwis return fals word check point xi yi belong circl rectangl time exampl 1 input radiu 1 xcenter 0 ycenter 0 x1 1 y1 1 x2 3 y2 1 output true explan circl rectangl share point 10 exampl 2 input radiu 1 xcenter 1 ycenter 1 x1 1 y1 3 x2 2 y2 1 output fals exampl 3 input radiu 1 xcenter 0 ycenter 0 x1 1 y1 0 x2 0 y2 1 output true constraint 1 radiu 2000 104 xcenter ycenter 104 104 x1 x2 104 104 y1 y2 104 circleandrectangleoverlap
minimumaveragediffer
given n pair parenthes write function gener combin wellform parenthes exampl 1 input n 3 output exampl 2 input n 1 output constraint 1 n 8 generateparenthes
given two string one step append charact either return minimum number step make anagram anagram string string contain charact differ order exampl 1 input leetcod coat output 7 explan 2 step append letter onto leetcod form leetcodea 5 step append letter leed onto coat form coatsleed leetcodea coatsleed anagram use total 2 5 7 step shown way make anagram less 7 step exampl 2 input night thing output 0 explan given string alreadi anagram thu need step constraint 1 slength tlength 2 105 consist lowercas english letter minimumnumberofstepstomaketwostringsanagramii
alic bob continu game pile stone sever stone arrang row stone associ valu integ given array stonevalu alic bob take turn alic start first player turn player take 1 2 3 stone first remain stone row score player sum valu stone taken score player 0 initi object game end highest score winner player highest score could tie game continu stone taken assum alic bob play optim return alic alic win bob bob win tie end game score exampl 1 input stonevalu 1237 output bob explan alic alway lose best move take three pile score becom 6 score bob 7 bob win exampl 2 input stonevalu 1239 output alic explan alic must choos three pile first move win leav bob neg score alic choos one pile score 1 next move bob score becom 5 next move alic take pile valu 9 lose alic choos two pile score 3 next move bob score becom 3 next move alic take pile valu 9 also lose rememb play optim alic choos scenario make win exampl 3 input stonevalu 1236 output tie explan alic win game end game draw decid choos first three pile otherwis lose constraint 1 stonevaluelength 5 104 1000 stonevaluei 1000 stonegameiii
given 0index integ array num size n two integ lower upper return number fair pair pair j fair 0 j n lower numsi numsj upper exampl 1 input num 017445 lower 3 upper 6 output 6 explan 6 fair pair 03 04 05 13 14 15 exampl 2 input num 17925 lower 11 upper 11 output 1 explan singl fair pair 23 constraint 1 numslength 105 numslength n 109 numsi 109 109 lower upper 109 countthenumberoffairpair
given array string word width maxwidth format text line exactli maxwidth charact fulli left right justifi pack word greedi approach pack mani word line pad extra space necessari line exactli maxwidth charact extra space word distribut evenli possibl number space line divid evenli word empti slot left assign space slot right last line text leftjustifi extra space insert word note word defin charact sequenc consist nonspac charact word length guarante greater 0 exceed maxwidth input array word contain least one word exampl 1 input word exampl text justif maxwidth 16 output exampl text justif exampl 2 input word whatmustbeacknowledgmentshallb maxwidth 16 output must acknowledg shall explan note last line shall instead shall last line must leftjustifi instead fullyjustifi note second line also leftjustifi contain one word exampl 3 input word scienceiswhatweunderstandwellenoughtoexplaintoacomputerartiseverythingelsewedo maxwidth 20 output scienc understand well enough explain comput art everyth els constraint 1 wordslength 300 1 wordsilength 20 wordsi consist english letter symbol 1 maxwidth 100 wordsilength maxwidth textjustif
n differ onlin cours number 1 n given array cours coursesi durationi lastdayi indic ith cours taken continu durationi day must finish lastdayi start 1st day take two cours simultan return maximum number cours take exampl 1 input cours 10020020013001000125020003200 output 3 explan total 4 cours take 3 cours first take 1st cours cost 100 day finish 100th day readi take next cours 101st day second take 3rd cours cost 1000 day finish 1100th day readi take next cours 1101st day third take 2nd cours cost 200 day finish 1300th day 4th cours taken sinc finish 3300th day exce close date exampl 2 input cours 12 output 1 exampl 3 input cours 3243 output 0 constraint 1 courseslength 104 1 durationi lastdayi 104 coursescheduleiii
given two 0index integ array server task length n respect serversi weight ith server tasksj time need process jth task second task assign server use task queue initi server free queue empti second j jth task insert queue start 0th task insert second 0 long free server queue empti task front queue assign free server smallest weight case tie assign free server smallest index free server queue empti wait server becom free immedi assign next task multipl server becom free time multipl task queue assign order insert follow weight index prioriti server assign task j second free second tasksj build array an length ansj index server jth task assign return array an exampl 1 input server 332 task 123212 output 220212 explan event chronolog order go follow second 0 task 0 ad process use server 2 second 1 second 1 server 2 becom free task 1 ad process use server 2 second 3 second 2 task 2 ad process use server 0 second 5 second 3 server 2 becom free task 3 ad process use server 2 second 5 second 4 task 4 ad process use server 1 second 5 second 5 server becom free task 5 ad process use server 2 second 7 exampl 2 input server 51432 task 2124521 output 1414132 explan event chronolog order go follow second 0 task 0 ad process use server 1 second 2 second 1 task 1 ad process use server 4 second 2 second 2 server 1 4 becom free task 2 ad process use server 1 second 4 second 3 task 3 ad process use server 4 second 7 second 4 server 1 becom free task 4 ad process use server 1 second 9 second 5 task 5 ad process use server 3 second 7 second 6 task 6 ad process use server 2 second 7 constraint serverslength n taskslength 1 n 2 105 1 serversi tasksj 2 105 processtasksusingserv
given 0index integ array num array num beauti numslength even numsi numsi 1 2 0 note empti array consid beauti delet number element num delet element element right delet element shift one unit left fill gap creat element left delet element remain unchang return minimum number element delet num make beauti exampl 1 input num 11235 output 1 explan delet either nums0 nums1 make num 1235 beauti proven need least 1 delet make num beauti exampl 2 input num 112233 output 2 explan delet nums0 nums5 make num 1223 beauti proven need least 2 delet make num beauti constraint 1 numslength 105 0 numsi 105 minimumdeletionstomakearraybeauti
given two string return true anagram fals otherwis anagram word phrase form rearrang letter differ word phrase typic use origin letter exactli exampl 1 input anagram nagaram output true exampl 2 input rat car output fals constraint 1 slength tlength 5 104 consist lowercas english letter follow input contain unicod charact would adapt solut case validanagram
given 0index x n binari matrix grid let us call nonempti subset row good sum column subset half length subset formal length chosen subset row k sum column floork 2 return integ array contain row indic good subset sort ascend order multipl good subset return good subset return empti array subset row matrix grid matrix obtain delet possibl none row grid exampl 1 input grid 011000011111 output 01 explan choos 0th 1st row creat good subset row length chosen subset 2 sum 0th column 0 0 0 half length subset sum 1st column 1 0 1 half length subset sum 2nd column 1 0 1 half length subset sum 3rd column 0 1 1 half length subset exampl 2 input grid 0 output 0 explan choos 0th row creat good subset row length chosen subset 1 sum 0th column 0 half length subset exampl 3 input grid 111111 output explan imposs choos subset row creat good subset constraint gridlength n gridilength 1 104 1 n 5 gridij either 0 1 findagoodsubsetofthematrix
given 0index integ array num integ p find p pair indic num maximum differ amongst pair minim also ensur index appear amongst p pair note pair element index j differ pair numsi numsj x repres absolut valu x return minimum maximum differ among p pair defin maximum empti set zero exampl 1 input num 1012713 p 2 output 1 explan first pair form indic 1 4 second pair form indic 2 5 maximum differ maxnums1 nums4 nums2 nums5 max0 1 1 therefor return 1 exampl 2 input num 4212 p 1 output 0 explan let indic 1 3 form pair differ pair 2 2 0 minimum attain constraint 1 numslength 105 0 numsi 109 0 p numslength2 minimizethemaximumdifferenceofpair
given two integ dividend divisor divid two integ without use multipl divis mod oper integ divis truncat toward zero mean lose fraction part exampl 8345 would truncat 8 27335 would truncat 2 return quotient divid dividend divisor note assum deal environ could store integ within 32bit sign integ rang −231 231 − 1 problem quotient strictli greater 231 1 return 231 1 quotient strictli less 231 return 231 exampl 1 input dividend 10 divisor 3 output 3 explan 103 333333 truncat 3 exampl 2 input dividend 7 divisor 3 output 2 explan 73 233333 truncat 2 constraint 231 dividend divisor 231 1 divisor 0 dividetwointeg
given array price pricesi price given stock ith day want maxim profit choos singl day buy one stock choos differ day futur sell stock return maximum profit achiev transact achiev profit return 0 exampl 1 input price 715364 output 5 explan buy day 2 price 1 sell day 5 price 6 profit 61 5 note buy day 2 sell day 1 allow must buy sell exampl 2 input price 76431 output 0 explan case transact done max profit 0 constraint 1 priceslength 105 0 pricesi 104 besttimetobuyandsellstock
n citi number 0 n1 given array edg edgesi fromi toi weighti repres bidirect weight edg citi fromi toi given integ distancethreshold return citi smallest number citi reachabl path whose distanc distancethreshold multipl citi return citi greatest number notic distanc path connect citi j equal sum edg weight along path exampl 1 input n 4 edg 013121134231 distancethreshold 4 output 3 explan figur describ graph neighbor citi distancethreshold 4 citi citi 0 citi 1 citi 2 citi 1 citi 0 citi 2 citi 3 citi 2 citi 0 citi 1 citi 3 citi 3 citi 1 citi 2 citi 0 3 2 neighbor citi distancethreshold 4 return citi 3 sinc greatest number exampl 2 input n 5 edg 012048123142231341 distancethreshold 2 output 0 explan figur describ graph neighbor citi distancethreshold 2 citi citi 0 citi 1 citi 1 citi 0 citi 4 citi 2 citi 3 citi 4 citi 3 citi 2 citi 4 citi 4 citi 1 citi 2 citi 3 citi 0 1 neighbor citi distancethreshold 2 constraint 2 n 100 1 edgeslength n n 1 2 edgesilength 3 0 fromi toi n 1 weighti distancethreshold 104 pair fromi toi distinct findthecitywiththesmallestnumberofneighborsatathresholddist
given integ array num perform follow oper number time num swap posit two element numsi numsj gcdnumsi numsj 1 gcdnumsi numsj greatest common divisor numsi numsj return true possibl sort num nondecreas order use swap method fals otherwis exampl 1 input num 7213 output true explan sort 7213 perform follow oper swap 7 21 gcd721 7 num 2173 swap 21 3 gcd213 3 num 3721 exampl 2 input num 5262 output fals explan imposs sort array 5 swap element exampl 3 input num 1059315 output true sort 1059315 perform follow oper swap 10 15 gcd1015 5 num 1559310 swap 15 3 gcd153 3 num 3591510 swap 10 15 gcd1015 5 num 3591015 constraint 1 numslength 3 104 2 numsi 105 gcdsortofanarray
may recal array arr mountain array arrlength 3 exist index 0index 0 arrlength 1 arr0 arr1 arri 1 arri arri arri 1 arrarrlength 1 given integ array num return minimum number element remov make num mountain array exampl 1 input num 131 output 0 explan array mountain array need remov element exampl 2 input num 21156231 output 3 explan one solut remov element indic 0 1 5 make array num 15631 constraint 3 numslength 1000 1 numsi 109 guarante make mountain array num minimumnumberofremovalstomakemountainarray
given x n matrix grid consist posit integ perform follow oper grid becom empti delet element greatest valu row multipl element exist delet add maximum delet element answer note number column decreas one oper return answer perform oper describ exampl 1 input grid 124331 output 8 explan diagram show remov valu step first oper remov 4 first row 3 second row notic two cell valu 3 remov add 4 answer second oper remov 2 first row 3 second row add 3 answer third oper remov 1 first row 1 second row add 1 answer final answer 4 3 1 8 exampl 2 input grid 10 output 10 explan diagram show remov valu step first oper remov 10 first row add 10 answer final answer 10 constraint gridlength n gridilength 1 n 50 1 gridij 100 deletegreatestvalueineachrow
given posit integ num split two nonneg integ num1 num2 concaten num1 num2 permut num word sum number occurr digit num1 num2 equal number occurr digit num num1 num2 contain lead zero return minimum possibl sum num1 num2 note guarante num contain lead zero order occurr digit num1 num2 may differ order occurr num exampl 1 input num 4325 output 59 explan split 4325 num1 24 num2 35 give sum 59 prove 59 inde minim possibl sum exampl 2 input num 687 output 75 explan split 687 num1 68 num2 7 would give optim sum 75 constraint 10 num 109 splitwithminimumsum
direct weight graph consist n node number 0 n 1 edg graph initi repres given array edg edgesi fromi toi edgecosti mean edg fromi toi cost edgecosti implement graph class graphint n int edg initi object n node given edg addedgeint edg add edg list edg edg edgecost guarante edg two node ad one int shortestpathint node1 int node2 return minimum cost path node1 node2 path exist return 1 cost path sum cost edg path exampl 1 input graph shortestpath shortestpath addedg shortestpath 4 0 2 5 0 1 2 1 2 1 3 0 3 3 2 0 3 1 3 4 0 3 output null 6 1 null 6 explan graph g new graph4 0 2 5 0 1 2 1 2 1 3 0 3 gshortestpath3 2 return 6 shortest path 3 2 first diagram 3 0 1 2 total cost 3 2 1 6 gshortestpath0 3 return 1 path 0 3 gaddedge1 3 4 add edg node 1 node 3 get second diagram gshortestpath0 3 return 6 shortest path 0 3 0 1 3 total cost 2 4 6 constraint 1 n 100 0 edgeslength n n 1 edgesilength edgelength 3 0 fromi toi node1 node2 n 1 1 edgecosti edgecost 106 repeat edg selfloop graph point 100 call made addedg 100 call made shortestpath designgraphwithshortestpathcalcul
distanc pair integ b defin absolut differ b given integ array num integ k return kth smallest distanc among pair numsi numsj 0 j numslength exampl 1 input num 131 k 1 output 0 explan pair 13 2 11 0 31 2 1st smallest distanc pair 11 distanc 0 exampl 2 input num 111 k 2 output 0 exampl 3 input num 161 k 3 output 5 constraint n numslength 2 n 104 0 numsi 106 1 k n n 1 2 findkthsmallestpairdist
given integ array num rang subarray num differ largest smallest element subarray return sum subarray rang num subarray contigu nonempti sequenc element within array exampl 1 input num 123 output 4 explan 6 subarray num follow 1 rang largest smallest 1 1 0 2 rang 2 2 0 3 rang 3 3 0 12 rang 2 1 1 23 rang 3 2 1 123 rang 3 1 2 sum rang 0 0 0 1 1 2 4 exampl 2 input num 133 output 4 explan 6 subarray num follow 1 rang largest smallest 1 1 0 3 rang 3 3 0 3 rang 3 3 0 13 rang 3 1 2 33 rang 3 3 0 133 rang 3 1 2 sum rang 0 0 0 2 0 2 4 exampl 3 input num 42341 output 59 explan sum subarray rang num 59 constraint 1 numslength 1000 109 numsi 109 followup could find solut time complex sumofsubarrayrang
write function check given valu instanc given class superclass problem object consid instanc given class object access classs method constraint data type pass function exampl valu class could undefin exampl 1 input func checkifinstanceofnew date date output true explan object return date constructor definit instanc date exampl 2 input func class anim class dog extend anim return checkifinstanceofnew dog anim output true explan class anim class dog extend anim checkifinstanceofnew dog anim true dog subclass anim therefor dog object instanc dog anim exampl 3 input func checkifinstanceofd date output fals explan date constructor logic instanc exampl 4 input func checkifinstanceof5 number output true explan 5 number note instanceof keyword would return fals howev still consid instanc number access number method exampl tofix checkifobjectinstanceofclass
given 2d grid 0s 1s return number element largest squar subgrid 1s border 0 subgrid doesnt exist grid exampl 1 input grid 111101111 output 9 exampl 2 input grid 1100 output 1 constraint 1 gridlength 100 1 grid0length 100 gridij 0 1 largest1borderedsquar
given posit integ check whether altern bit name two adjac bit alway differ valu exampl 1 input n 5 output true explan binari represent 5 101 exampl 2 input n 7 output fals explan binari represent 7 111 exampl 3 input n 11 output fals explan binari represent 11 1011 constraint 1 n 231 1 binarynumberwithalternatingbit
given integ n denot number citi countri citi number 0 n 1 also given 2d integ array road roadsi ai bi denot exist bidirect road connect citi ai bi need assign citi integ valu 1 n valu use import road defin sum valu two citi connect return maximum total import road possibl assign valu optim exampl 1 input n 5 road 011223021324 output 43 explan figur show countri assign valu 24531 road 01 import 2 4 6 road 12 import 4 5 9 road 23 import 5 3 8 road 02 import 2 5 7 road 13 import 4 3 7 road 24 import 5 1 6 total import road 6 9 8 7 7 6 43 shown obtain greater total import 43 exampl 2 input n 5 road 032413 output 20 explan figur show countri assign valu 43251 road 03 import 4 5 9 road 24 import 2 1 3 road 13 import 3 5 8 total import road 9 3 8 20 shown obtain greater total import 20 constraint 2 n 5 104 1 roadslength 5 104 roadsilength 2 0 ai bi n 1 ai bi duplic road maximumtotalimportanceofroad
given larg sampl integ rang 0 255 sinc sampl larg repres array count countk number time k appear sampl calcul follow statist minimum minimum element sampl maximum maximum element sampl mean averag sampl calcul total sum element divid total number element median sampl odd number element median middl element sampl sort sampl even number element median averag two middl element sampl sort mode number appear sampl guarante uniqu return statist sampl array floatingpoint number minimum maximum mean median mode answer within 105 actual answer accept exampl 1 input count 0134000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 output 100000300000237500250000300000 explan sampl repres count 12223333 minimum maximum 1 3 respect mean 12223333 8 19 8 2375 sinc size sampl even median averag two middl element 2 3 25 mode 3 appear sampl exampl 2 input count 0432200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 output 100000400000218182200000100000 explan sampl repres count 11112223344 minimum maximum 1 4 respect mean 11112223344 11 24 11 218181818 display purpos output show round number 218182 sinc size sampl odd median middl element 2 mode 1 appear sampl constraint countlength 256 0 counti 109 1 sumcount 109 mode sampl count repres uniqu statisticsfromalargesampl
hash 0index string length k given integ p comput use follow function hash p vals0 p0 vals1 p1 valsk1 pk1 mod valsi repres index si alphabet vala 1 valz 26 given string integ power modulo k hashvalu return sub first substr length k hashsub power modulo hashvalu test case gener answer alway exist substr contigu nonempti sequenc charact within string exampl 1 input leetcod power 7 modulo 20 k 2 hashvalu 0 output ee explan hash ee comput hashe 7 20 5 1 5 7 mod 20 40 mod 20 0 ee first substr length 2 hashvalu 0 henc return ee exampl 2 input fbxzaad power 31 modulo 100 k 3 hashvalu 32 output fbx explan hash fbx comput hashfbx 31 100 6 1 2 31 24 312 mod 100 23132 mod 100 32 hash bxz comput hashbxz 31 100 2 1 24 31 26 312 mod 100 25732 mod 100 32 fbx first substr length 3 hashvalu 32 henc return fbx note bxz also hash 32 appear later fbx constraint 1 k slength 2 104 1 power modulo 109 0 hashvalu modulo consist lowercas english letter test case gener answer alway exist findsubstringwithgivenhashvalu
given multidimension array integ return gener object yield integ order inord travers multidimension array recurs data structur contain integ multidimension array inord travers iter array left right yield integ encount appli inord travers array encount exampl 1 input arr 613 output 613 explan const gener inordertraversalarr generatornextvalu 6 generatornextvalu 1 generatornextvalu 3 generatornextdon true exampl 2 input arr output explan integ gener doesnt yield anyth constraint 0 arrflatlength 105 0 arrflati 105 maxnestingdepth 105 solv without creat new flatten version array nestedarraygener
n bulb initi first turn bulb turn everi second bulb third round toggl everi third bulb turn turn ith round toggl everi bulb nth round toggl last bulb return number bulb n round exampl 1 input n 3 output 1 explan first three bulb first round three bulb second round three bulb third round three bulb return 1 one bulb exampl 2 input n 0 output 0 exampl 3 input n 1 output 1 constraint 0 n 109 bulbswitch
k list sort integ nondecreas order find smallest rang includ least one number k list defin rang b smaller rang c b c c b c exampl 1 input num 4101524260912205182230 output 2024 explan list 1 4 10 15 2426 24 rang 2024 list 2 0 9 12 20 20 rang 2024 list 3 5 18 22 30 22 rang 2024 exampl 2 input num 123123123 output 11 constraint numslength k 1 k 3500 1 numsilength 50 105 numsij 105 numsi sort nondecreas order smallestrangecoveringelementsfromklist
infinit number stack arrang row number left right 0 stack maximum capac implement dinnerpl class dinnerplatesint capac initi object maximum capac stack capac void pushint val push given integ val leftmost stack size less capac int pop return valu top rightmost nonempti stack remov stack return 1 stack empti int popatstackint index return valu top stack given index index remov stack return 1 stack given index empti exampl 1 input dinnerpl push push push push push popatstack push push popatstack popatstack pop pop pop pop pop 2 1 2 3 4 5 0 20 21 0 2 output null null null null null null 2 null null 20 21 5 4 3 1 1 explan dinnerpl dinnerplates2 initi capac 2 dpush1 dpush2 dpush3 dpush4 dpush5 stack 2 4 1 3 5 ﹈ ﹈ ﹈ dpopatstack0 return 2 stack 4 1 3 5 ﹈ ﹈ ﹈ dpush20 stack 20 4 1 3 5 ﹈ ﹈ ﹈ dpush21 stack 20 4 21 1 3 5 ﹈ ﹈ ﹈ dpopatstack0 return 20 stack 4 21 1 3 5 ﹈ ﹈ ﹈ dpopatstack2 return 21 stack 4 1 3 5 ﹈ ﹈ ﹈ dpop return 5 stack 4 1 3 ﹈ ﹈ dpop return 4 stack 1 3 ﹈ ﹈ dpop return 3 stack 1 ﹈ dpop return 1 stack dpop return 1 still stack constraint 1 capac 2 104 1 val 2 104 0 index 105 2 105 call made push pop popatstack dinnerplatestack
given head refer node singlylink list valu node link list either 0 1 link list hold binari represent number return decim valu number link list signific bit head link list exampl 1 input head 101 output 5 explan 101 base 2 5 base 10 exampl 2 input head 0 output 0 constraint link list empti number node exceed 30 node valu either 0 1 convertbinarynumberinalinkedlisttointeg
sentenc list word separ singl space lead trail space given array string sentenc sentencesi repres singl sentenc return maximum number word appear singl sentenc exampl 1 input sentenc alic bob love leetcod think great thank much output 6 explan first sentenc alic bob love leetcod 5 word total second sentenc think 4 word total third sentenc great thank much 6 word total thu maximum number word singl sentenc come third sentenc 6 word exampl 2 input sentenc pleas wait continu fight continu win output 3 explan possibl multipl sentenc contain number word exampl second third sentenc underlin number word constraint 1 sentenceslength 100 1 sentencesilength 100 sentencesi consist lowercas english letter sentencesi lead trail space word sentencesi separ singl space maximumnumberofwordsfoundinsent
given binari tree follow rule rootval 0 treenodev x treenodeleft null treenodeleftv 2 x 1 treenodev x treenoderight null treenoderightv 2 x 2 binari tree contamin mean treenodev chang 1 implement findel class findelementstreenod root initi object contamin binari tree recov bool findint target return true target valu exist recov binari tree exampl 1 input findelementsfindfind 1null112 output nullfalsetru explan findel findel new findelements1null1 findelementsfind1 return fals findelementsfind2 return true exampl 2 input findelementsfindfindfind 11111135 output nulltruetruefals explan findel findel new findelements11111 findelementsfind1 return true findelementsfind3 return true findelementsfind5 return fals exampl 3 input findelementsfindfindfindfind 1null11null12345 output nulltruefalsefalsetru explan findel findel new findelements1null11null1 findelementsfind2 return true findelementsfind3 return fals findelementsfind4 return fals findelementsfind5 return true constraint treenodev 1 height binari tree less equal 20 total number node 1 104 total call find 1 104 0 target 106 findelementsinacontaminatedbinarytre
given integ array num integ k find maximum subarray sum subarray num meet follow condit length subarray k element subarray distinct return maximum subarray sum subarray meet condit subarray meet condit return 0 subarray contigu nonempti sequenc element within array exampl 1 input num 1542999 k 3 output 15 explan subarray num length 3 154 meet requir sum 10 542 meet requir sum 11 429 meet requir sum 15 299 meet requir element 9 repeat 999 meet requir element 9 repeat return 15 maximum subarray sum subarray meet condit exampl 2 input num 444 k 3 output 0 explan subarray num length 3 444 meet requir element 4 repeat return 0 subarray meet condit constraint 1 k numslength 105 1 numsi 105 maximumsumofdistinctsubarrayswithlengthk
defin usag capit word right one follow case hold letter word capit like usa letter word capit like leetcod first letter word capit like googl given string word return true usag capit right exampl 1 input word usa output true exampl 2 input word flag output fals constraint 1 wordlength 100 word consist lowercas uppercas english letter detectcapit
given two string first second consid occurr text form first second third second come immedi first third come immedi second return array word third occurr first second third exampl 1 input text alic good girl good student first second good output girlstud exampl 2 input text rock first second output werock constraint 1 textlength 1000 text consist lowercas english letter space word text separ singl space 1 firstlength secondlength 10 first second consist lowercas english letter occurrencesafterbigram
given x n grid cell grid sign point next cell visit current cell sign gridij 1 mean go cell right ie go gridij gridij 1 2 mean go cell left ie go gridij gridij 1 3 mean go lower cell ie go gridij gridi 1j 4 mean go upper cell ie go gridij gridi 1j notic could sign cell grid point outsid grid initi start upper left cell 0 0 valid path grid path start upper left cell 0 0 end bottomright cell 1 n 1 follow sign grid valid path shortest modifi sign cell cost 1 modifi sign cell one time return minimum cost make grid least one valid path exampl 1 input grid 1111222211112222 output 3 explan start point 0 0 path 3 3 follow 0 0 0 1 0 2 0 3 chang arrow cost 1 1 3 1 2 1 1 1 0 chang arrow cost 1 2 0 2 1 2 2 2 3 chang arrow cost 1 3 3 total cost 3 exampl 2 input grid 113322114 output 0 explan follow path 0 0 2 2 exampl 3 input grid 1243 output 1 constraint gridlength n gridilength 1 n 100 1 gridij 4 minimumcosttomakeatleastonevalidpathinagrid
given array point pointsi xi yi coordin ith point 2d plane multipl point coordin also given array queri queriesj xj yj rj describ circl center xj yj radiu rj queri queriesj comput number point insid jth circl point border circl consid insid return array answer answerj answer jth queri exampl 1 input point 13335322 queri 231431112 output 322 explan point circl shown queries0 green circl queries1 red circl queries2 blue circl exampl 2 input point 1122334455 queri 122222432433 output 2324 explan point circl shown queries0 green queries1 red queries2 blue queries3 purpl constraint 1 pointslength 500 pointsilength 2 0 xi yi 500 1 querieslength 500 queriesjlength 3 0 xj yj 500 1 rj 500 coordin integ follow could find answer queri better complex queriesonnumberofpointsinsideacircl
given string return lexicograph smallest subsequ contain distinct charact exactli exampl 1 input bcabc output abc exampl 2 input cbacdcbc output acdb constraint 1 slength 1000 consist lowercas english letter note question 316 httpsleetcodecomproblemsremoveduplicatelett smallestsubsequenceofdistinctcharact
given array integ cost integ target return maximum integ paint follow rule cost paint digit 1 given costi 0index total cost use must equal target integ 0 digit sinc answer may larg return string way paint integ given condit return 0 exampl 1 input cost 432567255 target 9 output 7772 explan cost paint digit 7 2 digit 2 3 cost7772 23 31 9 could also paint 977 7772 largest number digit cost 1 4 2 3 3 2 4 5 5 6 6 7 7 2 8 5 9 5 exampl 2 input cost 765556878 target 12 output 85 explan cost paint digit 8 7 digit 5 5 cost85 7 5 12 exampl 3 input cost 246246444 target 5 output 0 explan imposs paint integ total cost equal target constraint costlength 9 1 costi target 5000 formlargestintegerwithdigitsthatadduptotarget
sentenc list word separ singl space lead trail space exampl hello world hello hello world hello world sentenc word consist uppercas lowercas english letter uppercas lowercas english letter consid differ sentenc circular last charact word equal first charact next word last charact last word equal first charact first word exampl leetcod exercis sound delight eetcod leetcod eat soul circular sentenc howev leetcod cool happi leetcod leetcod like leetcod circular sentenc given string sentenc return true circular otherwis return fals exampl 1 input sentenc leetcod exercis sound delight output true explan word sentenc leetcod exercis sound delight leetcod last charact equal exercisess first charact exercisess last charact equal sound first charact sound last charact equal delight first charact delight last charact equal leetcod first charact sentenc circular exampl 2 input sentenc eetcod output true explan word sentenc eetcod eetcod last charact equal eetcod first charact sentenc circular exampl 3 input sentenc leetcod cool output fals explan word sentenc leetcod cool leetcod last charact equal iss first charact sentenc circular constraint 1 sentencelength 500 sentenc consist lowercas uppercas english letter space word sentenc separ singl space lead trail space circularsent
two mice n differ type chees type chees eaten exactli one mous point chees index 0index reward1i first mous eat reward2i second mous eat given posit integ array reward1 posit integ array reward2 nonneg integ k return maximum point mice achiev first mous eat exactli k type chees exampl 1 input reward1 1134 reward2 4411 k 2 output 15 explan exampl first mous eat 2nd 0index 3rd type chees second mous eat 0th 1st type chees total point 4 4 3 4 15 proven 15 maximum total point mice achiev exampl 2 input reward1 11 reward2 11 k 2 output 2 explan exampl first mous eat 0th 0index 1st type chees second mous eat chees total point 1 1 2 proven 2 maximum total point mice achiev constraint 1 n reward1length reward2length 105 1 reward1i reward2i 1000 0 k n miceandchees
play video game defend citi group n monster given 0index integ array dist size n disti initi distanc kilomet ith monster citi monster walk toward citi constant speed speed monster given integ array speed size n speedi speed ith monster kilomet per minut weapon fulli charg elimin singl monster howev weapon take one minut chargeth weapon fulli charg start lose monster reach citi monster reach citi exact moment weapon fulli charg count loss game end use weapon return maximum number monster elimin lose n elimin monster reach citi exampl 1 input dist 134 speed 111 output 3 explan begin distanc monster 134 elimin first monster minut distanc monster x23 elimin second monster minut distanc monster xx2 elimin thrid monster 3 monster elimin exampl 2 input dist 1123 speed 1111 output 1 explan begin distanc monster 1123 elimin first monster minut distanc monster x012 lose elimin 1 monster exampl 3 input dist 324 speed 532 output 1 explan begin distanc monster 324 elimin first monster minut distanc monster x02 lose elimin 1 monster constraint n distlength speedlength 1 n 105 1 disti speedi 105 eliminatemaximumnumberofmonst
koko love eat banana n pile banana ith pile pilesi banana guard gone come back h hour koko decid bananasperhour eat speed k hour choos pile banana eat k banana pile pile less k banana eat instead eat banana hour koko like eat slowli still want finish eat banana guard return return minimum integ k eat banana within h hour exampl 1 input pile 36711 h 8 output 4 exampl 2 input pile 301123420 h 5 output 30 exampl 3 input pile 301123420 h 6 output 23 constraint 1 pileslength 104 pileslength h 109 1 pilesi 109 kokoeatingbanana
given integ array arr distinct integ integ k game play first two element array ie arr0 arr1 round game compar arr0 arr1 larger integ win remain posit 0 smaller integ move end array game end integ win k consecut round return integ win game guarante winner game exampl 1 input arr 2135467 k 2 output 5 explan let see round game round arr winner wincount 1 2135467 2 1 2 2354671 3 1 3 3546712 5 1 4 5467123 5 2 see 4 round play 5 winner win 2 consecut game exampl 2 input arr 321 k 10 output 3 explan 3 win first 10 round consecut constraint 2 arrlength 105 1 arri 106 arr contain distinct integ 1 k 109 findthewinnerofanarraygam
alic bob take turn play game alic start first initi n stone pile player turn player make move consist remov nonzero squar number stone pile also player make move hesh lose game given posit integ n return true alic win game otherwis return fals assum player play optim exampl 1 input n 1 output true explan alic remov 1 stone win game bob doesnt move exampl 2 input n 2 output fals explan alic remov 1 stone bob remov last one win game 2 1 0 exampl 3 input n 4 output true explan n alreadi perfect squar alic win one move remov 4 stone 4 0 constraint 1 n 105 stonegameiv
given 0index integ array num contain distinct number integ start integ goal integ x initi set start want perform oper x convert goal perform follow oper repeatedli number x 0 x 1000 index array 0 numslength set x follow x numsi x numsi x numsi bitwisexor note use numsi number time order oper set x rang 0 x 1000 valid oper done afterward return minimum number oper need convert x start goal 1 possibl exampl 1 input num 2412 start 2 goal 12 output 2 explan go 2 → 14 → 12 follow 2 oper 2 12 14 14 2 12 exampl 2 input num 357 start 0 goal 4 output 2 explan go 0 → 3 → 4 follow 2 oper 0 3 3 3 7 4 note last oper set x rang 0 x 1000 valid exampl 3 input num 2816 start 0 goal 1 output 1 explan way convert 0 1 constraint 1 numslength 1000 109 numsi goal 109 0 start 1000 start goal integ num distinct minimumoperationstoconvertnumb
given string consist uppercas english letter appli oper string one oper remov occurr one substr ab cd return minimum possibl length result string obtain note string concaten remov substr could produc new ab cd substr exampl 1 input abfcacdb output 2 explan follow oper remov substr abfcacdb fcacdb remov substr fcacdb fcab remov substr fcab fc result length string 2 shown minimum length obtain exampl 2 input acbbd output 5 explan oper string length remain constraint 1 slength 100 consist uppercas english letter minimumstringlengthafterremovingsubstr
given text file filetxt print 10th line file exampl assum filetxt follow content line 1 line 2 line 3 line 4 line 5 line 6 line 7 line 8 line 9 line 10 script output tenth line line 10 note 1 file contain less 10 line output 2 there least three differ solut tri explor possibl tenthlin
given integ n return array an length n 1 0 n ansi number 1s binari represent exampl 1 input n 2 output 011 explan 0 0 1 1 2 10 exampl 2 input n 5 output 011212 explan 0 0 1 1 2 10 3 11 4 100 5 101 constraint 0 n 105 follow easi come solut runtim log n linear time possibl singl pass without use builtin function ie like builtinpopcount c countingbit
given 0index binari string target length n anoth binari string length n initi set zero want make equal target one oper pick index 0 n flip bit inclus rang n 1 flip mean chang 0 1 1 0 return minimum number oper need make equal target exampl 1 input target 10111 output 3 explan initi 00000 choos index 2 00000 00111 choos index 0 00111 11000 choos index 1 11000 10111 need least 3 flip oper form target exampl 2 input target 101 output 3 explan initi 000 choos index 0 000 111 choos index 1 111 100 choos index 2 100 101 need least 3 flip oper form target exampl 3 input target 00000 output 0 explan need oper sinc initi alreadi equal target constraint n targetlength 1 n 105 targeti either 0 1 minimumsuffixflip
given string express number oper return possibl result comput differ possibl way group number oper may return answer order test case gener output valu fit 32bit integ number differ result exceed 104 exampl 1 input express 211 output 02 explan 211 0 211 2 exampl 2 input express 2345 output 3414101010 explan 2345 34 2345 14 2345 10 2345 10 2345 10 constraint 1 expressionlength 20 express consist digit oper integ valu input express rang 0 99 differentwaystoaddparenthes
given two integ array nums1 nums2 length advantag nums1 respect nums2 number indic nums1i nums2i return permut nums1 maxim advantag respect nums2 exampl 1 input nums1 271115 nums2 110411 output 211715 exampl 2 input nums1 1224832 nums2 13253211 output 2432812 constraint 1 nums1length 105 nums2length nums1length 0 nums1i nums2i 109 advantageshuffl
sql schema tabl triangl column name type x int int z int x z primari key column tabl row tabl contain length three line segment write sql queri report everi three line segment whether form triangl return result tabl order queri result format follow exampl exampl 1 input triangl tabl x z 13 15 30 10 20 15 output x z triangl 13 15 30 10 20 15 ye trianglejudg
undirect graph n node number 0 n 1 inclus given 0index integ array valu valuesi valu ith node also given 0index 2d integ array edg edgesj uj vj timej indic undirect edg node uj vj take timej second travel two node final given integ maxtim valid path graph path start node 0 end node 0 take maxtim second complet may visit node multipl time qualiti valid path sum valu uniqu node visit path node valu ad sum return maximum qualiti valid path note four edg connect node exampl 1 input valu 0321043 edg 011012150310 maxtim 49 output 75 explan one possibl path 0 1 0 3 0 total time taken 10 10 10 10 40 49 node visit 0 1 3 give maxim path qualiti 0 32 43 75 exampl 2 input valu 5101520 edg 011012100310 maxtim 30 output 25 explan one possibl path 0 3 0 total time taken 10 10 20 30 node visit 0 3 give maxim path qualiti 5 20 25 exampl 3 input valu 1234 edg 0110121123121313 maxtim 50 output 7 explan one possibl path 0 1 3 1 0 total time taken 10 13 13 10 46 50 node visit 0 1 3 give maxim path qualiti 1 2 4 7 constraint n valueslength 1 n 1000 0 valuesi 108 0 edgeslength 2000 edgesjlength 3 0 uj vj n 1 10 timej maxtim 100 pair uj vj uniqu four edg connect node graph may connect maximumpathqualityofagraph
survey consist n question question answer either 0 1 ye survey given student number 0 1 mentor number 0 1 answer student repres 2d integ array student studentsi integ array contain answer ith student 0index answer mentor repres 2d integ array mentor mentorsj integ array contain answer jth mentor 0index student assign one mentor mentor one student assign compat score studentmentor pair number answer student mentor exampl student answer 1 0 1 mentor answer 0 0 1 compat score 2 second third answer task find optim studentmentor pair maxim sum compat score given student mentor return maximum compat score sum achiev exampl 1 input student 110101001 mentor 100001110 output 8 explan assign student mentor follow way student 0 mentor 2 compat score 3 student 1 mentor 0 compat score 2 student 2 mentor 1 compat score 3 compat score sum 3 2 3 8 exampl 2 input student 000000 mentor 111111 output 0 explan compat score studentmentor pair 0 constraint studentslength mentorslength n studentsilength mentorsjlength 1 n 8 studentsik either 0 1 mentorsjk either 0 1 maximumcompatibilityscoresum
given array integ num 0index integ k score subarray j defin minnumsi numsi1 numsj j 1 good subarray subarray k j return maximum possibl score good subarray exampl 1 input num 143745 k 3 output 15 explan optim subarray 1 5 score min43745 511 3 5 15 exampl 2 input num 55454111 k 0 output 20 explan optim subarray 0 4 score min55454 401 4 5 20 constraint 1 numslength 105 1 numsi 2 104 0 k numslength maximumscoreofagoodsubarray
given x n integ matrix heightmap repres height unit cell 2d elev map return volum water trap rain exampl 1 input heightmap 143132321324233231 output 4 explan rain water trap block two small pond 1 3 unit trap total volum water trap 4 exampl 2 input heightmap 3333332223321233222333333 output 10 constraint heightmaplength n heightmapilength 1 n 200 0 heightmapij 2 104 trappingrainwaterii
given 0index 2d integ array pair pairsi starti endi arrang pair valid everi index 1 pairslength endi1 starti return valid arrang pair note input gener exist valid arrang pair exampl 1 input pair 514511994 output 119944551 explan valid arrang sinc endi1 alway equal starti end0 9 9 start1 end1 4 4 start2 end2 5 5 start3 exampl 2 input pair 133221 output 133221 explan valid arrang sinc endi1 alway equal starti end0 3 3 start1 end1 2 2 start2 arrang 211332 322113 also valid exampl 3 input pair 121321 output 122113 explan valid arrang sinc endi1 alway equal starti end0 2 2 start1 end1 1 1 start2 constraint 1 pairslength 105 pairsilength 2 0 starti endi 109 starti endi two pair exactli exist valid arrang pair validarrangementofpair
given array string name array height consist distinct posit integ array length n index namesi heightsi denot name height ith person return name sort descend order peopl height exampl 1 input name maryjohnemma height 180165170 output maryemmajohn explan mari tallest follow emma john exampl 2 input name alicebobbob height 155185150 output bobalicebob explan first bob tallest follow alic second bob constraint n nameslength heightslength 1 n 103 1 namesilength 20 1 heightsi 105 namesi consist lower upper case english letter valu height distinct sortthepeopl
given integ array num adjac integ num perform float divis exampl num 234 evalu express 234 howev add number parenthesi posit chang prioriti oper want add parenthes valu express evalu maximum return correspond express maximum valu string format note express contain redund parenthesi exampl 1 input num 1000100102 output 1000100102 explan 1000100102 1000100102 200 howev bold parenthesi 1000100102 redund sinc influenc oper prioriti return 1000100102 case 1000100102 50 1000100102 50 1000100102 05 1000100102 2 exampl 2 input num 234 output 234 explan 234 83 2667 shown tri possibl get express evalu greater 2667 constraint 1 numslength 10 2 numsi 1000 one optim divis given input optimaldivis
tictacto play two player b 3 x 3 grid rule tictacto player take turn place charact empti squar first player alway place x charact second player b alway place charact x charact alway place empti squar never fill one game end three nonempti charact fill row column diagon game also end squar nonempti move play game given 2d integ array move movesi rowi coli indic ith move play gridrowicoli return winner game exist b case game end draw return draw still movement play return pend assum move valid ie follow rule tictacto grid initi empti play first exampl 1 input move 0020112122 output explan win alway play first exampl 2 input move 001101021020 output b explan b win exampl 3 input move 001120101221010222 output draw explan game end draw sinc move make constraint 1 moveslength 9 movesilength 2 0 rowi coli 2 repeat element move move follow rule tic tac toe findwinneronatictactoegam
game undirect graph play two player mous cat altern turn graph given follow grapha list node b ab edg graph mous start node 1 goe first cat start node 2 goe second hole node 0 player turn must travel along one edg graph meet exampl mous node 1 must travel node graph1 addit allow cat travel hole node 0 game end three way ever cat occupi node mous cat win ever mous reach hole mous win ever posit repeat ie player posit previou turn player turn move game draw given graph assum player play optim return 1 mous win game 2 cat win game 0 game draw exampl 1 input graph 25304514523023 output 0 exampl 2 input graph 130302 output 1 constraint 3 graphlength 50 1 graphilength graphlength 0 graphij graphlength graphij graphi uniqu mous cat alway move catandmous
given x n binari matrix mat 1s repres soldier 0s repres civilian soldier posit front civilian 1s appear left 0s row row weaker row j one follow true number soldier row less number soldier row j row number soldier j return indic k weakest row matrix order weakest strongest exampl 1 input mat 11000 11110 10000 11000 11111 k 3 output 203 explan number soldier row row 0 2 row 1 4 row 2 1 row 3 2 row 4 5 row order weakest strongest 20314 exampl 2 input mat 1000 1111 1000 1000 k 2 output 02 explan number soldier row row 0 1 row 1 4 row 2 1 row 3 1 row order weakest strongest 0231 constraint matlength n matilength 2 n 100 1 k matrixij either 0 1 thekweakestrowsinamatrix
bidirect graph n vertic vertex label 0 n 1 edg graph repres given 2d integ array edg edgesi ui vi denot edg vertex ui vertex vi everi vertex pair connect one edg vertex edg return length shortest cycl graph cycl exist return 1 cycl path start end node edg path use exampl 1 input n 7 edg 01122034455663 output 3 explan cycl smallest length 0 1 2 0 exampl 2 input n 4 edg 0102 output 1 explan cycl graph constraint 2 n 1000 1 edgeslength 1000 edgesilength 2 0 ui vi n ui vi repeat edg shortestcycleinagraph
given row x col matrix grid repres field cherri gridij repres number cherri collect j cell two robot collect cherri robot 1 locat topleft corner 0 0 robot 2 locat topright corner 0 col 1 return maximum number cherri collect use robot follow rule cell j robot move cell 1 j 1 1 j 1 j 1 robot pass cell pick cherri cell becom empti cell robot stay cell one take cherri robot move outsid grid moment robot reach bottom row grid exampl 1 input grid 311251155211 output 24 explan path robot 1 2 describ color green blue respect cherri taken robot 1 3 2 5 2 12 cherri taken robot 2 1 5 5 1 12 total cherri 12 12 24 exampl 2 input grid 10000012000030209000003054001023006 output 28 explan path robot 1 2 describ color green blue respect cherri taken robot 1 1 9 5 2 17 cherri taken robot 2 1 3 4 3 11 total cherri 17 11 28 constraint row gridlength col gridilength 2 row col 70 0 gridij 100 cherrypickupii
given two 0index array nums1 nums2 length n permut 0 1 n 1 good triplet set 3 distinct valu present increas order posit nums1 nums2 word consid pos1v index valu v nums1 pos2v index valu v nums2 good triplet set x z 0 x z n 1 pos1x pos1i pos1z pos2x pos2i pos2z return total number good triplet exampl 1 input nums1 2013 nums2 0123 output 1 explan 4 triplet xyz pos1x pos1i pos1z 201 203 213 013 triplet triplet 013 satisfi pos2x pos2i pos2z henc 1 good triplet exampl 2 input nums1 40132 nums2 41023 output 4 explan 4 good triplet 403 402 413 412 constraint n nums1length nums2length 3 n 105 0 nums1i nums2i n 1 nums1 nums2 permut 0 1 n 1 countgoodtripletsinanarray
given 0index string express form num1num2 num1 num2 repres posit integ add pair parenthes express addit parenthes express valid mathemat express evalu smallest possibl valu left parenthesi must ad left right parenthesi must ad right return express ad pair parenthes express evalu smallest possibl valu multipl answer yield result return input gener origin valu express valu express ad pair parenthes meet requir fit within sign 32bit integ exampl 1 input express 24738 output 24738 explan express evalu 2 47 38 2 85 170 note 24738 invalid right parenthesi must right shown 170 smallest possibl valu exampl 2 input express 1234 output 1234 explan express evalu 1 2 3 4 1 5 4 20 exampl 3 input express 999999 output 999999 explan express evalu 999 999 1998 constraint 3 expressionlength 10 express consist digit 1 9 express start end digit express contain exactli one origin valu express valu express ad pair parenthes meet requir fit within sign 32bit integ minimizeresultbyaddingparenthesestoexpress
given two string string gener random shuffl string add one letter random posit return letter ad exampl 1 input abcd abcd output e explan e letter ad exampl 2 input output constraint 0 slength 1000 tlength slength 1 consist lowercas english letter findthediffer
given set distinct posit integ num return largest subset answer everi pair answeri answerj element subset satisfi answeri answerj 0 answerj answeri 0 multipl solut return exampl 1 input num 123 output 12 explan 13 also accept exampl 2 input num 1248 output 1248 constraint 1 numslength 1000 1 numsi 2 109 integ num uniqu largestdivisiblesubset
2d grid size n x n cell grid lamp initi turn given 2d array lamp posit lamp lampsi rowi coli indic lamp gridrowicoli turn even lamp list turn lamp turn illumin cell cell row column diagon also given anoth 2d array queri queriesj rowj colj jth queri determin whether gridrowjcolj illumin answer jth queri turn lamp gridrowjcolj 8 adjac lamp exist lamp adjac cell share either side corner gridrowjcolj return array integ an ansj 1 cell jth queri illumin 0 lamp exampl 1 input n 5 lamp 0044 queri 1110 output 10 explan initi grid lamp turn pictur see grid turn lamp grid00 turn lamp grid44 0th queri ask lamp grid11 illumin blue squar illumin set ans0 1 turn lamp red squar 1st queri ask lamp grid10 illumin blue squar illumin set ans1 0 turn lamp red rectangl exampl 2 input n 5 lamp 0044 queri 1111 output 11 exampl 3 input n 5 lamp 0004 queri 040114 output 110 constraint 1 n 109 0 lampslength 20000 0 querieslength 20000 lampsilength 2 0 rowi coli n queriesjlength 2 0 rowj colj n gridillumin
given 0index integ array player playersi repres abil ith player also given 0index integ array trainer trainersj repres train capac jth trainer ith player match jth trainer player abil less equal trainer train capac addit ith player match one trainer jth trainer match one player return maximum number match player trainer satisfi condit exampl 1 input player 479 trainer 8258 output 2 explan one way form two match follow players0 match trainers0 sinc 4 8 players1 match trainers3 sinc 7 8 proven 2 maximum number match form exampl 2 input player 111 trainer 10 output 1 explan trainer match 3 player player match one trainer maximum answer 1 constraint 1 playerslength trainerslength 105 1 playersi trainersj 109 maximummatchingofplayerswithtrain
play solitair game three pile stone size b c respect turn choos two differ nonempti pile take one stone add 1 point score game stop fewer two nonempti pile mean avail move given three integ b c return maximum score get exampl 1 input 2 b 4 c 6 output 6 explan start state 2 4 6 one optim set move take 1st 3rd pile state 1 4 5 take 1st 3rd pile state 0 4 4 take 2nd 3rd pile state 0 3 3 take 2nd 3rd pile state 0 2 2 take 2nd 3rd pile state 0 1 1 take 2nd 3rd pile state 0 0 0 fewer two nonempti pile game end total 6 point exampl 2 input 4 b 4 c 6 output 7 explan start state 4 4 6 one optim set move take 1st 2nd pile state 3 3 6 take 1st 3rd pile state 2 3 5 take 1st 3rd pile state 1 3 4 take 1st 3rd pile state 0 3 3 take 2nd 3rd pile state 0 2 2 take 2nd 3rd pile state 0 1 1 take 2nd 3rd pile state 0 0 0 fewer two nonempti pile game end total 7 point exampl 3 input 1 b 8 c 8 output 8 explan one optim set move take 2nd 3rd pile 8 turn empti fewer two nonempti pile game end constraint 1 b c 105 maximumscorefromremovingston
string good repeat charact given string return number good substr length three note multipl occurr substr everi occurr count substr contigu sequenc charact string exampl 1 input xyzzaz output 1 explan 4 substr size 3 xyz yzz zza zaz good substr length 3 xyz exampl 2 input aababcabc output 4 explan 7 substr size 3 aab aba bab abc bca cab abc good substr abc bca cab abc constraint 1 slength 100 consist lowercas english letter substringsofsizethreewithdistinctcharact
binari tree root 0 consist n node node label 0 n 1 given 0index integ array parent repres tree parentsi parent node sinc node 0 root parents0 1 node score find score node consid node edg connect remov tree would becom one nonempti subtre size subtre number node score node product size subtre return number node highest score exampl 1 input parent 12020 output 3 explan score node 0 3 1 3 score node 1 4 4 score node 2 1 1 2 2 score node 3 4 4 score node 4 4 4 highest score 4 three node node 1 node 3 node 4 highest score exampl 2 input parent 120 output 2 explan score node 0 2 2 score node 1 2 2 score node 2 1 1 1 highest score 2 two node node 0 node 1 highest score constraint n parentslength 2 n 105 parents0 1 0 parentsi n 1 0 parent repres valid binari tree countnodeswiththehighestscor
given 0index integ array map repres map rule shuffl decim system mappingi j mean digit map digit j system map valu integ new integ obtain replac occurr digit integ mappingi 0 9 also given anoth integ array num return array num sort nondecreas order base map valu element note element map valu appear rel order input element num sort base map valu replac exampl 1 input map 8940213576 num 99133838 output 33838991 explan map number 991 follow 1 mapping9 6 occurr digit 9 becom 6 2 mapping1 9 occurr digit 1 becom 9 therefor map valu 991 669 338 map 007 7 remov lead zero 38 map 07 also 7 remov lead zero sinc 338 38 share map valu remain rel order 338 come 38 thu sort array 33838991 exampl 2 input map 0123456789 num 789456123 output 123456789 explan 789 map 789 456 map 456 123 map 123 thu sort array 123456789 constraint mappinglength 10 0 mappingi 9 valu mappingi uniqu 1 numslength 3 104 0 numsi 109 sortthejumblednumb
given string array pair indic string pair pairsi b indic 2 indices0index string swap charact pair indic given pair number time return lexicograph smallest string chang use swap exampl 1 input dcab pair 0312 output bacd explain swap s0 s3 bcad swap s1 s2 bacd exampl 2 input dcab pair 031202 output abcd explain swap s0 s3 bcad swap s0 s2 acbd swap s1 s2 abcd exampl 3 input cba pair 0112 output abc explain swap s0 s1 bca swap s1 s2 bac swap s0 s1 abc constraint 1 slength 105 0 pairslength 105 0 pairsi0 pairsi1 slength contain lower case english letter smalleststringwithswap
given two 0index integ permut b length n prefix common array b array c ci equal count number present index b return prefix common array b sequenc n integ call permut contain integ 1 n exactli exampl 1 input 1324 b 3124 output 0234 explan 0 number common c0 0 1 1 3 common b c1 2 2 1 2 3 common b c2 3 3 1 2 3 4 common b c3 4 exampl 2 input 231 b 312 output 013 explan 0 number common c0 0 1 3 common b c1 1 2 1 2 3 common b c2 3 constraint 1 alength blength n 50 1 ai bi n guarante b permut n integ findtheprefixcommonarrayoftwoarray
given x n matrix grid sort nonincreas order rowwis columnwis return number neg number grid exampl 1 input grid 4321321111121123 output 8 explan 8 neg number matrix exampl 2 input grid 3210 output 0 constraint gridlength n gridilength 1 n 100 100 gridij 100 follow could find solut countnegativenumbersinasortedmatrix
given valid ipv4 ip address return defang version ip address defang ip address replac everi period exampl 1 input address 1111 output 1111 exampl 2 input address 255100500 output 255100500 constraint given address valid ipv4 address defanginganipaddress
bu n stop number 0 n 1 form circl know distanc pair neighbor stop distancei distanc stop number 1 n bu goe along direct ie clockwis counterclockwis return shortest distanc given start destin stop exampl 1 input distanc 1234 start 0 destin 1 output 1 explan distanc 0 1 1 9 minimum 1 exampl 2 input distanc 1234 start 0 destin 2 output 3 explan distanc 0 2 3 7 minimum 3 exampl 3 input distanc 1234 start 0 destin 3 output 4 explan distanc 0 3 6 4 minimum 4 constraint 1 n 104 distancelength n 0 start destin n 0 distancei 104 distancebetweenbusstop
substr contigu nonempti sequenc charact within string vowel substr substr consist vowel e u five vowel present given string word return number vowel substr word exampl 1 input word aeiouu output 2 explan vowel substr word follow underlin aeiouu aeiouu exampl 2 input word unicornarihan output 0 explan 5 vowel present vowel substr exampl 3 input word cuaieuouac output 7 explan vowel substr word follow underlin cuaieuouac cuaieuouac cuaieuouac cuaieuouac cuaieuouac cuaieuouac cuaieuouac constraint 1 wordlength 100 word consist lowercas english letter countvowelsubstringsofastr
given string consid duplic substr contigu substr occur 2 time occurr may overlap return duplic substr longest possibl length duplic substr answer exampl 1 input banana output ana exampl 2 input abcd output constraint 2 slength 3 104 consist lowercas english letter longestduplicatesubstr
sql schema tabl deliveri column name type deliveryid int customerid int orderd date customerprefdeliveryd date deliveryid primari key tabl tabl hold inform food deliveri custom make order date specifi prefer deliveri date order date custom prefer deliveri date order date order call immedi otherwis call schedul first order custom order earliest order date custom made guarante custom precis one first order write sql queri find percentag immedi order first order custom round 2 decim place queri result format follow exampl exampl 1 input deliveri tabl deliveryid customerid orderd customerprefdeliveryd 1 1 20190801 20190802 2 2 20190802 20190802 3 1 20190811 20190812 4 3 20190824 20190824 5 3 20190821 20190822 6 2 20190811 20190813 7 4 20190809 20190809 output immediatepercentag 5000 explan custom id 1 first order deliveri id 1 schedul custom id 2 first order deliveri id 2 immedi custom id 3 first order deliveri id 5 schedul custom id 4 first order deliveri id 7 immedi henc half custom immedi first order immediatefooddeliveryii
n hous evenli line street hous beauti paint given 0index integ array color length n colorsi repres color ith hous return maximum distanc two hous differ color distanc ith jth hous absi j absx absolut valu x exampl 1 input color 1116111 output 3 explan imag color 1 blue color 6 red furthest two hous differ color hous 0 hous 3 hous 0 color 1 hous 3 color 6 distanc abs0 3 3 note hous 3 6 also produc optim answer exampl 2 input color 18383 output 4 explan imag color 1 blue color 8 yellow color 3 green furthest two hous differ color hous 0 hous 4 hous 0 color 1 hous 4 color 3 distanc abs0 4 4 exampl 3 input color 01 output 1 explan furthest two hous differ color hous 0 hous 1 hous 0 color 0 hous 1 color 1 distanc abs0 1 1 constraint n colorslength 2 n 100 0 colorsi 100 test data gener least two hous differ color twofurthesthouseswithdifferentcolor
given string contain parenthes letter remov minimum number invalid parenthes make input string valid return list uniqu string valid minimum number remov may return answer order exampl 1 input output exampl 2 input output aa exampl 3 input output constraint 1 slength 25 consist lowercas english letter parenthes 20 parenthes removeinvalidparenthes
given two nonempti link list repres two nonneg integ signific digit come first node contain singl digit add two number return sum link list may assum two number contain lead zero except number 0 exampl 1 input l1 7243 l2 564 output 7807 exampl 2 input l1 243 l2 564 output 807 exampl 3 input l1 0 l2 0 output 0 constraint number node link list rang 1 100 0 nodev 9 guarante list repres number lead zero follow could solv without revers input list addtwonumbersii
given array n string str length string arrang one line make grid exampl str abc bce cae arrang follow abc bce cae want delet column sort lexicograph exampl 0index column 0 b c 2 c e e sort column 1 b c would delet column 1 return number column delet exampl 1 input str cbadafghi output 1 explan grid look follow cba daf ghi column 0 2 sort column 1 need delet 1 column exampl 2 input str ab output 0 explan grid look follow b column 0 column sort delet column exampl 3 input str zyxwvutsr output 3 explan grid look follow zyx wvu tsr 3 column sort delet 3 constraint n strslength 1 n 100 1 strsilength 1000 strsi consist lowercas english letter deletecolumnstomakesort
given posit integ arrivaltim denot arriv time train hour anoth posit integ delayedtim denot amount delay hour return time train arriv station note time problem 24hour format exampl 1 input arrivaltim 15 delayedtim 5 output 20 explan arriv time train 1500 hour delay 5 hour reach 155 20 2000 hour exampl 2 input arrivaltim 13 delayedtim 11 output 0 explan arriv time train 1300 hour delay 11 hour reach 131124 denot 0000 24 hour format return 0 constraint 1 arrivaltim 24 1 delayedtim 24 calculatedelayedarrivaltim
given two string text1 text2 return length longest common subsequ common subsequ return 0 subsequ string new string gener origin string charact none delet without chang rel order remain charact exampl ace subsequ abcd common subsequ two string subsequ common string exampl 1 input text1 abcd text2 ace output 3 explan longest common subsequ ace length 3 exampl 2 input text1 abc text2 abc output 3 explan longest common subsequ abc length 3 exampl 3 input text1 abc text2 def output 0 explan common subsequ result 0 constraint 1 text1length text2length 1000 text1 text2 consist lowercas english charact longestcommonsubsequ
program languag four oper one variabl x x x increment valu variabl x 1 x x decrement valu variabl x 1 initi valu x 0 given array string oper contain list oper return final valu x perform oper exampl 1 input oper xxx output 1 explan oper perform follow initi x 0 x x decrement 1 x 0 1 1 x x increment 1 x 1 1 0 x x increment 1 x 0 1 1 exampl 2 input oper xxx output 3 explan oper perform follow initi x 0 x x increment 1 x 0 1 1 x x increment 1 x 1 1 2 x x increment 1 x 2 1 3 exampl 3 input oper xxxx output 0 explan oper perform follow initi x 0 x x increment 1 x 0 1 1 x x increment 1 x 1 1 2 x x decrement 1 x 2 1 1 x x decrement 1 x 1 1 0 constraint 1 operationslength 100 operationsi either x x x x finalvalueofvariableafterperformingoper
suppos leetcod start ipo soon order sell good price share ventur capit leetcod would like work project increas capit ipo sinc limit resourc finish k distinct project ipo help leetcod design best way maxim total capit finish k distinct project given n project ith project pure profit profitsi minimum capit capitali need start initi w capit finish project obtain pure profit profit ad total capit pick list k distinct project given project maxim final capit return final maxim capit answer guarante fit 32bit sign integ exampl 1 input k 2 w 0 profit 123 capit 011 output 4 explan sinc initi capit 0 start project index 0 finish obtain profit 1 capit becom 1 capit 1 either start project index 1 project index 2 sinc choos 2 project need finish project index 2 get maximum capit therefor output final maxim capit 0 1 3 4 exampl 2 input k 3 w 0 profit 123 capit 012 output 6 constraint 1 k 105 0 w 109 n profitslength n capitallength 1 n 105 0 profitsi 104 0 capitali 109 ipo
given integ array num return true exist tripl indic j k j k numsi numsj numsk indic exist return fals exampl 1 input num 12345 output true explan triplet j k valid exampl 2 input num 54321 output fals explan triplet exist exampl 3 input num 215046 output true explan triplet 3 4 5 valid nums3 0 nums4 4 nums5 6 constraint 1 numslength 5 105 231 numsi 231 1 follow could implement solut run time complex o1 space complex increasingtripletsubsequ
n peopl split unknown number group person label uniqu id 0 n 1 given integ array groupsiz groupsizesi size group person exampl groupsizes1 3 person 1 must group size 3 return list group person group size groupsizesi person appear exactli one group everi person must group multipl answer return guarante least one valid solut given input exampl 1 input groupsiz 3333313 output 5012346 explan first group 5 size 1 groupsizes5 1 second group 012 size 3 groupsizes0 groupsizes1 groupsizes2 3 third group 346 size 3 groupsizes3 groupsizes4 groupsizes6 3 possibl solut 2165043 5062431 exampl 2 input groupsiz 213332 output 105234 constraint groupsizeslength n 1 n 500 1 groupsizesi n groupthepeoplegiventhegroupsizetheybelongto
given string contain digit 09 addit symbol multipl symbol repres valid math express singl digit number eg 352 express given n elementari school student student instruct get answer express follow order oper comput multipl read left right comput addit read left right given integ array answer length n submit answer student particular order ask grade answer follow rule answer equal correct answer express student reward 5 point otherwis answer could interpret student appli oper wrong order correct arithmet student reward 2 point otherwis student reward 0 point return sum point student exampl 1 input 7312 answer 201342 output 7 explan illustr correct answer express 13 therefor one student reward 5 point 201342 student might appli oper wrong order 7312 20 therefor one student reward 2 point 201342 point student 250 sum point 2507 exampl 2 input 352 answer 1301013131616 output 19 explan correct answer express 13 therefor three student reward 5 point 1301013131616 student might appli oper wrong order 352 16 therefor two student reward 2 point 1301013131616 point student 5005522 sum point 500552219 exampl 3 input 601 answer 1296486 output 10 explan correct answer express 6 student incorrectli done 601 answer would also 6 rule grade student still reward 5 point got correct answer 2 point point student 005005 sum point 10 constraint 3 slength 31 repres valid express contain digit 09 integ operand express inclus rang 0 9 1 count oper math express 15 test data gener correct answer express rang 0 1000 n answerslength 1 n 104 0 answersi 1000 thescoreofstudentssolvingmathexpress
given string array word string wordsi compris lowercas english letter return number string word prefix prefix string substr occur begin string substr contigu sequenc charact within string exampl 1 input word abcabbcabc abc output 3 explan string word prefix abc ab abc thu number string word prefix 3 exampl 2 input word aa aa output 2 explan string prefix note string occur multipl time word count time constraint 1 wordslength 1000 1 wordsilength slength 10 wordsi consist lowercas english letter countprefixesofagivenstr
water dispens dispens cold warm hot water everi second either fill 2 cup differ type water 1 cup type water given 0index integ array amount length 3 amount0 amount1 amount2 denot number cold warm hot water cup need fill respect return minimum number second need fill cup exampl 1 input amount 142 output 4 explan one way fill cup second 1 fill cold cup warm cup second 2 fill warm cup hot cup second 3 fill warm cup hot cup second 4 fill warm cup proven 4 minimum number second need exampl 2 input amount 544 output 7 explan one way fill cup second 1 fill cold cup hot cup second 2 fill cold cup warm cup second 3 fill cold cup warm cup second 4 fill warm cup hot cup second 5 fill cold cup hot cup second 6 fill cold cup warm cup second 7 fill hot cup exampl 3 input amount 500 output 5 explan everi second fill cold cup constraint amountlength 3 0 amounti 100 minimumamountoftimetofillcup
x n grid 0 0 topleft cell 1 n 1 bottomright cell given integ array startpo startpo startrow startcol indic initi robot cell startrow startcol also given integ array homepo homepo homerow homecol indic home cell homerow homecol robot need go home move one cell four direct left right move outsid boundari everi move incur cost given two 0index integ array rowcost length colcost length n robot move cell whose row r move cost rowcostsr robot move left right cell whose column c move cost colcostsc return minimum total cost robot return home exampl 1 input startpo 1 0 homepo 2 3 rowcost 5 4 3 colcost 8 2 6 7 output 18 explan one optim path start 1 0 goe 2 0 move cost rowcosts2 3 goe right 2 1 move cost colcosts1 2 goe right 2 2 move cost colcosts2 6 goe right 2 3 move cost colcosts3 7 total cost 3 2 6 7 18 exampl 2 input startpo 0 0 homepo 0 0 rowcost 5 colcost 26 output 0 explan robot alreadi home sinc move occur total cost 0 constraint rowcostslength n colcostslength 1 n 105 0 rowcostsr colcostsc 104 startposlength 2 homeposlength 2 0 startrow homerow 0 startcol homecol n minimumcosthomecomingofarobotinagrid
given array integ arr integ target find two nonoverlap subarray arr sum equal target multipl answer find answer sum length two subarray minimum return minimum sum length two requir subarray return 1 find two subarray exampl 1 input arr 32243 target 3 output 2 explan two subarray sum 3 3 3 sum length 2 exampl 2 input arr 7347 target 7 output 2 explan although three nonoverlap subarray sum 7 7 34 7 choos first third subarray sum length 2 exampl 3 input arr 4326234 target 6 output 1 explan one subarray sum 6 constraint 1 arrlength 105 1 arri 1000 1 target 108 findtwononoverlappingsubarrayseachwithtargetsum
given array point xy plane point pointsi xi yi return minimum area rectangl form point side parallel x axe rectangl return 0 exampl 1 input point 1113313322 output 4 exampl 2 input point 111331334143 output 2 constraint 1 pointslength 500 pointsilength 2 0 xi yi 4 104 given point uniqu minimumarearectangl
given binari tree node valu digit 1 9 path binari tree said pseudopalindrom least one permut node valu path palindrom return number pseudopalindrom path go root node leaf node exampl 1 input root 23131null1 output 2 explan figur repres given binari tree three path go root node leaf node red path 233 green path 211 path 231 among path red path green path pseudopalindrom path sinc red path 233 rearrang 323 palindrom green path 211 rearrang 121 palindrom exampl 2 input root 21113nullnullnullnullnull1 output 1 explan figur repres given binari tree three path go root node leaf node green path 211 path 2131 path 21 among path green path pseudopalindrom sinc 211 rearrang 121 palindrom exampl 3 input root 9 output 1 constraint number node tree rang 1 105 1 nodev 9 pseudopalindromicpathsinabinarytre
note companion problem system design problem design tinyurl tinyurl url shorten servic enter url httpsleetcodecomproblemsdesigntinyurl return short url httptinyurlcom4e9iak design class encod url decod tini url restrict encodedecod algorithm work need ensur url encod tini url tini url decod origin url implement solut class solut initi object system string encodestr longurl return tini url given longurl string decodestr shorturl return origin long url given shorturl guarante given shorturl encod object exampl 1 input url httpsleetcodecomproblemsdesigntinyurl output httpsleetcodecomproblemsdesigntinyurl explan solut obj new solut string tini objencodeurl return encod tini url string an objdecodetini return origin url decod constraint 1 urllength 104 url gurante valid url encodeanddecodetinyurl
n soldier stand line soldier assign uniqu rate valu form team 3 soldier amongst follow rule choos 3 soldier index j k rate ratingi ratingj ratingk team valid ratingi ratingj ratingk ratingi ratingj ratingk 0 j k n return number team form given condit soldier part multipl team exampl 1 input rate 25341 output 3 explan form three team given condit 234 541 531 exampl 2 input rate 213 output 0 explan cant form team given condit exampl 3 input rate 1234 output 4 constraint n ratinglength 3 n 1000 1 ratingi 105 integ rate uniqu countnumberofteam
given array interv intervalsi starti endi merg overlap interv return array nonoverlap interv cover interv input exampl 1 input interv 13268101518 output 168101518 explan sinc interv 13 26 overlap merg 16 exampl 2 input interv 1445 output 15 explan interv 14 45 consid overlap constraint 1 intervalslength 104 intervalsilength 2 0 starti endi 104 mergeinterv
given integ array num integ k find three nonoverlap subarray length k maximum sum return return result list indic repres start posit interv 0index multipl answer return lexicograph smallest one exampl 1 input num 12126751 k 2 output 035 explan subarray 1 2 2 6 7 5 correspond start indic 0 3 5 could also taken 2 1 answer 1 3 5 would lexicograph larger exampl 2 input num 121212121 k 2 output 024 constraint 1 numslength 2 104 1 numsi 216 1 k floornumslength 3 maximumsumof3nonoverlappingsubarray
given string text want use charact text form mani instanc word balloon possibl use charact text return maximum number instanc form exampl 1 input text nlaebolko output 1 exampl 2 input text loonbalxballpoon output 2 exampl 3 input text leetcod output 0 constraint 1 textlength 104 text consist lower case english letter maximumnumberofballoon
given 0index integ array num repres score student exam teacher would like form one nonempti group student maxim strength strength group student indic i0 i1 i2 ik defin numsi0 numsi1 numsi2 numsik return maximum strength group teacher creat exampl 1 input num 315259 output 1350 explan one way form group maxim strength group student indic 02345 strength 3 5 2 5 9 1350 show optim exampl 2 input num 454 output 20 explan group student indic 0 1 ’ result strength 20 achiev greater strength constraint 1 numslength 13 9 numsi 9 maximumstrengthofagroup
given 0index integ array num consist 3 n element allow remov subsequ element size exactli n num remain 2 n element divid two equal part first n element belong first part sum sumfirst next n element belong second part sum sumsecond differ sum two part denot sumfirst sumsecond exampl sumfirst 3 sumsecond 2 differ 1 similarli sumfirst 2 sumsecond 3 differ 1 return minimum differ possibl sum two part remov n element exampl 1 input num 312 output 1 explan num 3 element n 1 thu remov 1 element num divid array two equal part remov nums0 3 array 12 differ sum two part 1 2 1 remov nums1 1 array 32 differ sum two part 3 2 1 remov nums2 2 array 31 differ sum two part 3 1 2 minimum differ sum two part min112 1 exampl 2 input num 795813 output 1 explan n 2 must remov 2 element divid remain array two part contain two element remov nums2 5 nums3 8 result array 7913 differ sum 79 13 12 obtain minimum differ remov nums1 9 nums4 1 result array becom 7583 differ sum two part 75 83 1 shown possibl obtain differ smaller 1 constraint numslength 3 n 1 n 105 1 numsi 105 minimumdifferenceinsumsafterremovalofel
sometim long run task may wish cancel complet help goal write function cancel accept gener object return array two valu cancel function promis may assum gener function yield promis function respons pass valu resolv promis back gener promis reject function throw error back gener cancel callback call gener done function throw error back gener error string cancel error object error caught return promis resolv next valu yield return otherwis promis reject thrown error code execut gener done promis function return resolv valu gener return howev gener throw error return promis reject error exampl code would use function task const val yield new promiseresolv resolve2 2 yield new promiseresolv settimeoutresolv 100 return val 1 calcul shouldnt done const cancel promis cancellabletask settimeoutcancel 50 promisecatchconsolelog log cancel t50m instead cancel call call t100m promis would resolv 5 exampl 1 input generatorfunct function return 42 cancelledat 100 output resolv 42 explan const gener generatorfunct const cancel promis cancellablegener settimeoutcancel 100 promisethenconsolelog resolv 42 t0m gener immedi yield 42 finish return promis immedi resolv 42 note cancel finish gener noth exampl 2 input generatorfunct function const msg yield new promiser reshello throw error msg cancelledat null output reject error hello explan promis yield function handl wait resolv pass resolv valu back gener error thrown effect caus promis reject thrown error exampl 3 input generatorfunct function yield new promiser settimeoutr 200 return success cancelledat 100 output reject cancel explan function wait yield promis resolv cancel call caus error messag sent back gener sinc error uncaught return promis reject error exampl 4 input generatorfunct function let result 0 yield new promiser settimeoutr 100 result yield new promiser res1 yield new promiser settimeoutr 100 result yield new promiser res1 return result cancelledat null output resolv 2 explan 4 promis yield two promis valu ad result 200m gener finish valu 2 valu resolv return promis exampl 5 input generatorfunct function let result 0 tri yield new promiser settimeoutr 100 result yield new promiser res1 yield new promiser settimeoutr 100 result yield new promiser res1 catch return result return result cancelledat 150 output resolv 1 explan first two yield promis resolv caus result increment howev t150m gener cancel error sent gener caught result return final resolv return promis exampl 6 input generatorfunct function tri yield new promiseresolv reject rejectpromis reject catch let yield new promiseresolv resolve2 let b yield new promiseresolv resolve2 return b cancelledat null output resolv 4 explan first yield promis immedi reject error caught gener hasnt cancel execut continu usual end resolv 2 2 4 constraint cancelledat null 0 cancelledat 1000 generatorfunct return gener object designcancellablefunct
supermarket frequent mani custom product sold supermarket repres two parallel integ array product price ith product id productsi price pricesi custom pay bill repres two parallel integ array product amount jth product purchas id productj amountj much product bought subtot calcul sum amountj price jth product supermarket decid sale everi nth custom pay groceri given percentag discount discount amount given discount given discount percent subtot formal subtot bill would actual pay bill 100 discount 100 implement cashier class cashierint n int discount int product int price initi object n discount product price doubl getbillint product int amount return final total bill discount appli answer within 105 actual valu accept exampl 1 input cashiergetbillgetbillgetbillgetbillgetbillgetbillgetbil 350123456710020030040030020010012123710101234567111111141073101075316421010109997235532 output null500040000800040000400007350025000 explan cashier cashier new cashier3501234567100200300400300200100 cashiergetbill1212 return 5000 1st custom discount bill 1 100 2 200 500 cashiergetbill371010 return 40000 2nd custom discount bill 10 300 10 100 4000 cashiergetbill12345671111111 return 8000 3rd custom 50 discount origin bill 1600 actual bill 1600 100 50 100 800 cashiergetbill410 return 40000 4th custom discount cashiergetbill731010 return 40000 5th custom discount cashiergetbill75316421010109997 return 73500 6th custom 50 discount origin bill 14700 actual bill 14700 100 50 100 7350 cashiergetbill235532 return 25000 7th custom discount constraint 1 n 104 0 discount 100 1 productslength 200 priceslength productslength 1 productsi 200 1 pricesi 1000 element product uniqu 1 productlength productslength amountlength productlength productj exist product 1 amountj 1000 element product uniqu 1000 call made getbil answer within 105 actual valu accept applydiscounteverynord
given two string length s1 s2 string basestr say s1i s2i equival charact exampl s1 abc s2 cde c b c e equival charact follow usual rule equival relat reflex symmetri b impli b transit b b c impli c exampl given equival inform s1 abc s2 cde acd aab equival string basestr eed aab lexicograph smallest equival string basestr return lexicograph smallest equival string basestr use equival inform s1 s2 exampl 1 input s1 parker s2 morri basestr parser output makkek explan base equival inform s1 s2 group charact mp ao kr ei charact group equival sort lexicograph order answer makkek exampl 2 input s1 hello s2 world basestr hold output hdld explan base equival inform s1 s2 group charact hw deo lr second letter basestr chang answer hdld exampl 3 input s1 leetcod s2 program basestr sourcecod output aauaaaaada explan group equival charact s1 s2 aoersc lp gt dm thu letter basestr except u transform answer aauaaaaada constraint 1 s1length s2length basestr 1000 s1length s2length s1 s2 basestr consist lowercas english letter lexicographicallysmallestequivalentstr
sql schema pandan schema tabl salesperson column name type salesid int name varchar salari int commissionr int hired date sql salesid primari key column tabl row tabl indic name id salesperson alongsid salari commiss rate hire date tabl compani column name type comid int name varchar citi varchar sql comid primari key column tabl row tabl indic name id compani citi compani locat tabl order column name type orderid int orderd date comid int salesid int amount int sql orderid primari key column tabl comid foreign key join key panda comid compani tabl salesid foreign key join key panda salesid salesperson tabl row tabl contain inform one order includ id compani id salesperson date order amount paid find name salesperson order relat compani name red return result tabl order result format follow exampl exampl 1 input salesperson tabl salesid name salari commissionr hired 1 john 100000 6 412006 2 ami 12000 5 512010 3 mark 65000 12 12252008 4 pam 25000 25 112005 5 alex 5000 10 232007 compani tabl comid name citi 1 red boston 2 orang new york 3 yellow boston 4 green austin order tabl orderid orderd comid salesid amount 1 112014 3 4 10000 2 212014 4 5 5000 3 312014 1 1 50000 4 412014 1 4 25000 output name ami mark alex explan accord order 3 4 order tabl easi tell salesperson john pam sale compani red report name tabl salesperson salesperson
given 0index 2d integ array grid size x n cell one two valu 0 repres empti cell 1 repres obstacl may remov move left right empti cell return minimum number obstacl remov move upper left corner 0 0 lower right corner 1 n 1 exampl 1 input grid 011110110 output 2 explan remov obstacl 0 1 0 2 creat path 0 0 2 2 shown need remov least 2 obstacl return 2 note may way remov 2 obstacl creat path exampl 2 input grid 010000101000010 output 0 explan move 0 0 2 4 without remov obstacl return 0 constraint gridlength n gridilength 1 n 105 2 n 105 gridij either 0 1 grid00 gridm 1n 1 0 minimumobstacleremovaltoreachcorn
conveyor belt packag must ship one port anoth within day day ith packag conveyor belt weight weightsi day load ship packag conveyor belt order given weight may load weight maximum weight capac ship return least weight capac ship result packag conveyor belt ship within day day exampl 1 input weight 12345678910 day 5 output 15 explan ship capac 15 minimum ship packag 5 day like 1st day 1 2 3 4 5 2nd day 6 7 3rd day 8 4th day 9 5th day 10 note cargo must ship order given use ship capac 14 split packag part like 2 3 4 5 1 6 7 8 9 10 allow exampl 2 input weight 322414 day 3 output 6 explan ship capac 6 minimum ship packag 3 day like 1st day 3 2 2nd day 2 4 3rd day 1 4 exampl 3 input weight 12311 day 4 output 3 explan 1st day 1 2nd day 2 3rd day 3 4th day 1 1 constraint 1 day weightslength 5 104 1 weightsi 500 capacitytoshippackageswithindday
given x n binari matrix grid move consist choos row column toggl valu row column ie chang 0s 1s 1s 0s everi row matrix interpret binari number score matrix sum number return highest possibl score make number move includ zero move exampl 1 input grid 001110101100 output 39 explan 0b1111 0b1001 0b1111 15 9 15 39 exampl 2 input grid 0 output 1 constraint gridlength n gridilength 1 n 20 gridij either 0 1 scoreafterflippingmatrix
given root binari tree determin complet binari tree complet binari tree everi level except possibl last complet fill node last level far left possibl 1 2h node inclus last level h exampl 1 input root 123456 output true explan everi level last full ie level nodevalu 1 2 3 node last level 4 5 6 far left possibl exampl 2 input root 12345null7 output fals explan node valu 7 isnt far left possibl constraint number node tree rang 1 100 1 nodev 1000 checkcompletenessofabinarytre
given 0index binari string repres type build along street si 0 denot ith build offic si 1 denot ith build restaur citi offici would like select 3 build random inspect howev ensur varieti two consecut build select build type exampl given 001101 select 1st 3rd 5th build would form 011 allow due two consecut build type return number valid way select 3 build exampl 1 input 001101 output 6 explan follow set indic select valid 024 001101 form 010 034 001101 form 010 124 001101 form 010 134 001101 form 010 245 001101 form 101 345 001101 form 101 select valid thu 6 total way exampl 2 input 11100 output 0 explan shown valid select constraint 3 slength 105 si either 0 1 numberofwaystoselectbuild
given integ array num return frequent even element tie return smallest one element return 1 exampl 1 input num 0122441 output 2 explan even element 0 2 4 2 4 appear return smallest one 2 exampl 2 input num 444924 output 4 explan 4 even element appear exampl 3 input num 294721411337257 output 1 explan even element constraint 1 numslength 2000 0 numsi 105 mostfrequentevenel
convex nside polygon vertex integ valu given integ array valu valuesi valu ith vertex ie clockwis order triangul polygon n 2 triangl triangl valu triangl product valu vertic total score triangul sum valu n 2 triangl triangul return smallest possibl total score achiev triangul polygon exampl 1 input valu 123 output 6 explan polygon alreadi triangul score triangl 6 exampl 2 input valu 3745 output 144 explan two triangul possibl score 375 457 245 345 347 144 minimum score 144 exampl 3 input valu 131415 output 13 explan minimum score triangul score 113 114 115 111 13 constraint n valueslength 3 n 50 1 valuesi 100 minimumscoretriangulationofpolygon
truck two fuel tank given two integ maintank repres fuel present main tank liter additionaltank repres fuel present addit tank liter truck mileag 10 km per liter whenev 5 liter fuel get use main tank addit tank least 1 liter fuel 1 liter fuel transfer addit tank main tank return maximum distanc travel note inject addit tank continu happen suddenli immedi everi 5 liter consum exampl 1 input maintank 5 additionaltank 10 output 60 explan spend 5 litr fuel fuel remain 5 5 1 1 litr distanc travel 50km spend anoth 1 litr fuel fuel get inject main tank main tank becom empti total distanc travel 60km exampl 2 input maintank 1 additionaltank 2 output 10 explan spend 1 litr fuel main tank becom empti total distanc travel 10km constraint 1 maintank additionaltank 100 totaldistancetravel
given string want partit string mani part possibl letter appear one part note partit done concaten part order result string return list integ repres size part exampl 1 input ababcbacadefegdehijhklij output 978 explan partit ababcbaca defegd hijhklij partit letter appear one part partit like ababcbacadefegd hijhklij incorrect split less part exampl 2 input eccbbbbdec output 10 constraint 1 slength 500 consist lowercas english letter partitionlabel
given 0index integ array num length n num contain valid split index follow true sum first 1 element greater equal sum last n 1 element least one element right 0 n 1 return number valid split num exampl 1 input num 10487 output 2 explan three way split num two nonempti part split num index 0 first part 10 sum 10 second part 487 sum 3 sinc 10 3 0 valid split split num index 1 first part 104 sum 14 second part 87 sum 1 sinc 14 1 1 valid split split num index 2 first part 1048 sum 6 second part 7 sum 7 sinc 6 7 2 valid split thu number valid split num 2 exampl 2 input num 2310 output 2 explan two valid split num split num index 1 first part 23 sum 5 second part 10 sum 1 sinc 5 1 1 valid split split num index 2 first part 231 sum 6 second part 0 sum 0 sinc 6 0 2 valid split constraint 2 numslength 105 105 numsi 105 numberofwaystosplitarray
your given string jewel repres type stone jewel stone repres stone charact stone type stone want know mani stone also jewel letter case sensit consid differ type stone exampl 1 input jewel aa stone aaabbbb output 3 exampl 2 input jewel z stone zz output 0 constraint 1 jewelslength stoneslength 50 jewel stone consist english letter charact jewel uniqu jewelsandston
given 0index x n integ matrix grid width column maximum length integ exampl grid 10 3 12 width column 3 sinc 10 length 3 return integ array an size n ansi width ith column length integ x len digit equal len x nonneg len 1 otherwis exampl 1 input grid 122333 output 3 explan 0th column 333 length 3 exampl 2 input grid 151315712562 output 312 explan 0th column 15 length 3 1st column integ length 1 2nd column 12 2 length 2 constraint gridlength n gridilength 1 n 100 109 gridrc 109 findthewidthofcolumnsofagrid
given binari search tree bst find lowest common ancestor lca node two given node bst accord definit lca wikipedia “ lowest common ancestor defin two node p q lowest node p q descend allow node descend ” exampl 1 input root 6280479nullnull35 p 2 q 8 output 6 explan lca node 2 8 6 exampl 2 input root 6280479nullnull35 p 2 q 4 output 2 explan lca node 2 4 2 sinc node descend accord lca definit exampl 3 input root 21 p 2 q 1 output 2 constraint number node tree rang 2 105 109 nodev 109 nodev uniqu p q p q exist bst lowestcommonancestorofabinarysearchtre
n robot given two 0index integ array chargetim runningcost length n ith robot cost chargetimesi unit charg cost runningcostsi unit run also given integ budget total cost run k chosen robot equal maxchargetim k sumrunningcost maxchargetim largest charg cost among k robot sumrunningcost sum run cost among k robot return maximum number consecut robot run total cost exceed budget exampl 1 input chargetim 36134 runningcost 21345 budget 25 output 3 explan possibl run individu consecut pair robot within budget obtain answer 3 consid first 3 robot total cost max361 3 sum213 6 3 6 24 less 25 shown possibl run 3 consecut robot within budget return 3 exampl 2 input chargetim 111219 runningcost 1087 budget 19 output 0 explan robot run exceed budget return 0 constraint chargetimeslength runningcostslength n 1 n 5 104 1 chargetimesi runningcostsi 105 1 budget 1015 maximumnumberofrobotswithinbudget
sql schema pandan schema tabl person column name type id int email varchar sql id primari key column tabl row tabl contain email email contain uppercas letter delet duplic email keep one uniqu email smallest id sql user pleas note suppos write delet statement select one panda user pleas note suppos modifi person place run script answer shown person tabl driver first compil run piec code show person tabl final order person tabl matter result format follow exampl exampl 1 input person tabl id email 1 johnexamplecom 2 bobexamplecom 3 johnexamplecom output id email 1 johnexamplecom 2 bobexamplecom explan johnexamplecom repeat two time keep row smallest id 1 deleteduplicateemail
given function fn return memoiz version function memoiz function function never call twice input instead return cach valu assum 3 possibl input function sum fib factori sum accept two integ b return b fib accept singl integ n return 1 n 1 fibn 1 fibn 2 otherwis factori accept singl integ n return 1 n 1 factorialn 1 n otherwis exampl 1 input sum callcallgetcallcountcallgetcallcount 222212 output 44132 explan const sum b b const memoizedsum memoizesum memoizedsum2 2 return 4 sum call 2 2 seen memoizedsum2 2 return 4 howev sum call input seen total call count 1 memoizedsum1 2 return 3 sum call 1 2 seen total call count 2 exampl 2 input factori callcallcallgetcallcountcallgetcallcount 2323 output 262262 explan const factori n n 1 1 n factorialn 1 const memofactori memoizefactori memofactorial2 return 2 memofactorial3 return 6 memofactorial2 return 2 howev factori call 2 seen total call count 2 memofactorial3 return 6 howev factori call 3 seen total call count 2 exampl 3 input fib callgetcallcount 5 output 81 explan fib5 8 total call count 1 constraint 0 b 105 1 n 10 105 function call 105 attempt access callcount input function sum fib factori memoiz
given posit integ n exist 0index array call power compos minimum number power 2 sum n array sort nondecreas order one way form array also given 0index 2d integ array queri queriesi lefti righti queriesi repres queri find product powersj lefti j righti return array answer equal length queri answersi answer ith queri sinc answer ith queri may larg answersi return modulo 109 7 exampl 1 input n 15 queri 012203 output 2464 explan n 15 power 1248 shown power smaller size answer 1st queri powers0 powers1 1 2 2 answer 2nd queri powers2 4 answer 3rd queri powers0 powers1 powers2 powers3 1 2 4 8 64 answer modulo 109 7 yield answer 2464 return exampl 2 input n 2 queri 00 output 2 explan n 2 power 2 answer queri powers0 2 answer modulo 109 7 2 return constraint 1 n 109 1 querieslength 105 0 starti endi powerslength rangeproductqueriesofpow
given 0index integ array num numsi repres score ith student also given integ k pick score k student array differ highest lowest k score minim return minimum possibl differ exampl 1 input num 90 k 1 output 0 explan one way pick score one student 90 differ highest lowest score 90 90 0 minimum possibl differ 0 exampl 2 input num 9417 k 2 output 2 explan six way pick score two student 9417 differ highest lowest score 9 4 5 9417 differ highest lowest score 9 1 8 9417 differ highest lowest score 9 7 2 9417 differ highest lowest score 4 1 3 9417 differ highest lowest score 7 4 3 9417 differ highest lowest score 7 1 6 minimum possibl differ 2 constraint 1 k numslength 1000 0 numsi 105 minimumdifferencebetweenhighestandlowestofkscor
given weight undirect connect graph n vertic number 0 n 1 array edg edgesi ai bi weighti repres bidirect weight edg node ai bi minimum span tree mst subset graph edg connect vertic without cycl minimum possibl total edg weight find critic pseudocrit edg given graph minimum span tree mst mst edg whose delet graph would caus mst weight increas call critic edg hand pseudocrit edg appear mst note return indic edg order exampl 1 input n 5 edg 011121232032043343146 output 012345 explan figur describ graph follow figur show possibl mst notic two edg 0 1 appear mst therefor critic edg return first list output edg 2 3 4 5 part mst therefor consid pseudocrit edg add second list output exampl 2 input n 4 edg 011121231031 output 0123 explan observ sinc 4 edg equal weight choos 3 edg given 4 yield mst therefor 4 edg pseudocrit constraint 2 n 100 1 edgeslength min200 n n 1 2 edgesilength 3 0 ai bi n 1 weighti 1000 pair ai bi distinct findcriticalandpseudocriticaledgesinminimumspanningtre
runlength encod string compress method work replac consecut ident charact repeat 2 time concaten charact number mark count charact length run exampl compress string aabccc replac aa a2 replac ccc c3 thu compress string becom a2bc3 notic problem ad 1 singl charact given string integ k need delet k charact runlength encod version minimum length find minimum length runlength encod version delet k charact exampl 1 input aaabcccd k 2 output 4 explan compress without delet anyth give us a3bc3d length 6 delet charact c would decreas length compress string 5 instanc delet 2 abcccd compress abc3d therefor optim way delet b compress version a3c3 length 4 exampl 2 input aabbaa k 2 output 2 explan delet b charact result compress string would a4 length 2 exampl 3 input aaaaaaaaaaa k 0 output 3 explan sinc k zero delet anyth compress string a11 length 3 constraint 1 slength 100 0 k slength contain lowercas english letter stringcompressionii
given integ array num two integ mink maxk fixedbound subarray num subarray satisfi follow condit minimum valu subarray equal mink maximum valu subarray equal maxk return number fixedbound subarray subarray contigu part array exampl 1 input num 135275 mink 1 maxk 5 output 2 explan fixedbound subarray 135 1352 exampl 2 input num 1111 mink 1 maxk 1 output 10 explan everi subarray num fixedbound subarray 10 possibl subarray constraint 2 numslength 105 1 numsi mink maxk 106 countsubarrayswithfixedbound
sql schema tabl follow column name type userid int followerid int userid followerid primari key tabl tabl contain id user follow social media app follow follow user write sql queri user return number follow return result tabl order userid ascend order queri result format follow exampl exampl 1 input follow tabl userid followerid 0 1 1 0 2 0 2 1 output userid followerscount 0 1 1 1 2 2 explan follow 0 1 follow 1 0 follow 2 01 findfollowerscount
given integ array num integ k return number pair j j numsi numsj k valu x defin x x 0 x x 0 exampl 1 input num 1221 k 1 output 4 explan pair absolut differ 1 1221 1221 1221 1221 exampl 2 input num 13 k 3 output 0 explan pair absolut differ 3 exampl 3 input num 32154 k 2 output 3 explan pair absolut differ 2 32154 32154 32154 constraint 1 numslength 200 1 numsi 100 1 k 99 countnumberofpairswithabsolutedifferencek
five silent philosoph sit round tabl bowl spaghetti fork place pair adjac philosoph philosoph must altern think eat howev philosoph eat spaghetti left right fork fork held one philosoph philosoph use fork use anoth philosoph individu philosoph finish eat need put fork fork becom avail other philosoph take fork right one left becom avail start eat get fork eat limit remain amount spaghetti stomach space infinit suppli infinit demand assum design disciplin behaviour concurr algorithm philosoph starv ie forev continu altern eat think assum philosoph know other may want eat think problem statement imag taken wikipediaorg philosoph id number 0 4 clockwis order implement function void wantstoeatphilosoph pickleftfork pickrightfork eat putleftfork putrightfork philosoph id philosoph want eat pickleftfork pickrightfork function call pick correspond fork philosoph eat function call let philosoph eat pick fork putleftfork putrightfork function call put correspond fork philosoph philosoph assum think long ask eat function call number five thread repres philosoph simultan use one object class simul process function may call philosoph even last call end exampl 1 input n 1 output 421411011221211203212222403412021422321311003012022121111303312322103112122 explan n number time philosoph call function output array describ call made function control fork eat function format outputi b c three integ id philosoph b specifi fork 1 left 2 right c specifi oper 1 pick 2 put 3 eat constraint 1 n 60 thediningphilosoph
given 0index integ array cost costsi cost hire ith worker also given two integ k candid want hire exactli k worker accord follow rule run k session hire exactli one worker session hire session choos worker lowest cost either first candid worker last candid worker break tie smallest index exampl cost 327712 candid 2 first hire session choos 4th worker lowest cost 327712 second hire session choos 1st worker lowest cost 4th worker smallest index 32772 pleas note index may chang process fewer candid worker remain choos worker lowest cost among break tie smallest index worker chosen return total cost hire exactli k worker exampl 1 input cost 17121027211208 k 3 candid 4 output 11 explan hire 3 worker total total cost initi 0 first hire round choos worker 17121027211208 lowest cost 2 break tie smallest index 3 total cost 0 2 2 second hire round choos worker 1712107211208 lowest cost 2 index 4 total cost 2 2 4 third hire round choos worker 171210711208 lowest cost 7 index 3 total cost 4 7 11 notic worker index 3 common first last four worker total hire cost 11 exampl 2 input cost 1241 k 3 candid 3 output 4 explan hire 3 worker total total cost initi 0 first hire round choos worker 1241 lowest cost 1 break tie smallest index 0 total cost 0 1 1 notic worker index 1 2 common first last 3 worker second hire round choos worker 241 lowest cost 1 index 2 total cost 1 1 2 third hire round less three candid choos worker remain worker 24 lowest cost 2 index 0 total cost 2 2 4 total hire cost 4 constraint 1 costslength 105 1 costsi 105 1 k candid costslength totalcosttohirekwork
given nonneg integ num return true num express sum nonneg integ revers fals otherwis exampl 1 input num 443 output true explan 172 271 443 return true exampl 2 input num 63 output fals explan 63 express sum nonneg integ revers return fals exampl 3 input num 181 output true explan 140 041 181 return true note number revers may lead zero constraint 0 num 105 sumofnumberanditsrevers
suppos n integ label 1 n permut n integ perm 1index consid beauti arrang everi 1 n either follow true permi divis divis permi given integ n return number beauti arrang construct exampl 1 input n 2 output 2 explan first beauti arrang 12 perm1 1 divis 1 perm2 2 divis 2 second beauti arrang 21 perm1 2 divis 1 2 divis perm2 1 exampl 2 input n 1 output 1 constraint 1 n 15 beautifularrang
given array arr chunk size size return chunk array chunk array contain origin element arr consist subarray length size length last subarray may less size arrlength evenli divis size may assum array output jsonpars word valid json pleas solv without use lodash chunk function exampl 1 input arr 12345 size 1 output 12345 explan arr split subarray 1 element exampl 2 input arr 19632 size 3 output 19632 explan arr split subarray 3 element howev two element left 2nd subarray exampl 3 input arr 85326 size 6 output 85326 explan size greater arrlength thu element first subarray exampl 4 input arr size 1 output explan element chunk empti array return constraint arr valid json array 2 jsonstringifyarrlength 105 1 size arrlength 1 chunkarray
given 2d integ array log logsi birthi deathi indic birth death year ith person popul year x number peopl aliv year ith person count year xs popul x inclus rang birthi deathi 1 note person count year die return earliest year maximum popul exampl 1 input log 1993199920002010 output 1993 explan maximum popul 1 1993 earliest year popul exampl 2 input log 195019611960197119701981 output 1960 explan maximum popul 2 happen year 1960 1970 earlier year 1960 constraint 1 logslength 100 1950 birthi deathi 2050 maximumpopulationyear
given head link list return node cycl begin cycl return null cycl link list node list reach continu follow next pointer intern po use denot index node tail next pointer connect 0index 1 cycl note po pass paramet modifi link list exampl 1 input head 3204 po 1 output tail connect node index 1 explan cycl link list tail connect second node exampl 2 input head 12 po 0 output tail connect node index 0 explan cycl link list tail connect first node exampl 3 input head 1 po 1 output cycl explan cycl link list constraint number node list rang 0 104 105 nodev 105 po 1 valid index linkedlist follow solv use o1 ie constant memori linkedlistcycleii
given root binari tree uniqu valu valu two differ node tree x return true node correspond valu x tree cousin fals otherwis two node binari tree cousin depth differ parent note binari tree root node depth 0 children depth k node depth k 1 exampl 1 input root 1234 x 4 3 output fals exampl 2 input root 123null4null5 x 5 4 output true exampl 3 input root 123null4 x 2 3 output fals constraint number node tree rang 2 100 1 nodev 100 node uniqu valu x x exist tree cousinsinbinarytre
given direct graph n node number 0 n 1 node one outgo edg graph repres given 0index array edg size n indic direct edg node node edgesi outgo edg node edgesi 1 return length longest cycl graph cycl exist return 1 cycl path start end node exampl 1 input edg 33423 output 3 explan longest cycl graph cycl 2 4 3 2 length cycl 3 3 return exampl 2 input edg 2131 output 1 explan cycl graph constraint n edgeslength 2 n 105 1 edgesi n edgesi longestcycleinagraph
given root binari search tree rearrang tree inord leftmost node tree root tree everi node left child one right child exampl 1 input root 53624null81nullnullnull79 output 1null2null3null4null5null6null7null8null9 exampl 2 input root 517 output 1null5null7 constraint number node given tree rang 1 100 0 nodev 1000 increasingordersearchtre
given integ n number 1 n group accord sum digit return number group largest size exampl 1 input n 13 output 4 explan 9 group total group accord sum digit number 1 13 110 211 312 413 5 6 7 8 9 4 group largest size exampl 2 input n 2 output 2 explan 2 group 1 2 size 1 constraint 1 n 104 countlargestgroup
undirect graph n node number 0 n 1 given 0index integ array score length n scoresi denot score node also given 2d integ array edg edgesi ai bi denot exist undirect edg connect node ai bi node sequenc valid meet follow condit edg connect everi pair adjac node sequenc node appear sequenc score node sequenc defin sum score node sequenc return maximum score valid node sequenc length 4 sequenc exist return 1 exampl 1 input score 52984 edg 011223021324 output 24 explan figur show graph chosen node sequenc 0123 score node sequenc 5 2 9 8 24 shown node sequenc score 24 note sequenc 3120 1023 also valid score 24 sequenc 0324 valid sinc edg connect node 0 3 exampl 2 input score 920641112 edg 03532413 output 1 explan figur show graph valid node sequenc length 4 return 1 constraint n scoreslength 4 n 5 104 1 scoresi 108 0 edgeslength 5 104 edgesilength 2 0 ai bi n 1 ai bi duplic edg maximumscoreofanodesequ
given refer node connect undirect graph return deep copi clone graph node graph contain valu int list listnod neighbor class node public int val public listnod neighbor test case format simplic node valu node index 1index exampl first node val 1 second node val 2 graph repres test case use adjac list adjac list collect unord list use repres finit graph list describ set neighbor node graph given node alway first node val 1 must return copi given node refer clone graph exampl 1 input adjlist 24132413 output 24132413 explan 4 node graph 1st node val 1s neighbor 2nd node val 2 4th node val 4 2nd node val 2s neighbor 1st node val 1 3rd node val 3 3rd node val 3s neighbor 2nd node val 2 4th node val 4 4th node val 4s neighbor 1st node val 1 3rd node val 3 exampl 2 input adjlist output explan note input contain one empti list graph consist one node val 1 neighbor exampl 3 input adjlist output explan empti graph node constraint number node graph rang 0 100 1 nodev 100 nodev uniqu node repeat edg selfloop graph graph connect node visit start given node clonegraph
given root binari tree return array largest valu row tree 0index exampl 1 input root 13253null9 output 139 exampl 2 input root 123 output 13 constraint number node tree rang 0 104 231 nodev 231 1 findlargestvalueineachtreerow
given integ array price pricesi price given stock ith day integ k find maximum profit achiev may complet k transact ie may buy k time sell k time note may engag multipl transact simultan ie must sell stock buy exampl 1 input k 2 price 241 output 2 explan buy day 1 price 2 sell day 2 price 4 profit 42 2 exampl 2 input k 2 price 326503 output 7 explan buy day 2 price 2 sell day 3 price 6 profit 62 4 buy day 5 price 0 sell day 6 price 3 profit 30 3 constraint 1 k 100 1 priceslength 1000 0 pricesi 1000 besttimetobuyandsellstockiv
problem interact problem may recal array arr mountain array arrlength 3 exist 0 arrlength 1 arr0 arr1 arri 1 arri arri arri 1 arrarrlength 1 given mountain array mountainarr return minimum index mountainarrgetindex target index exist return 1 access mountain array directli may access array use mountainarray interfac mountainarraygetk return element array index k 0index mountainarraylength return length array submiss make 100 call mountainarrayget judg wrong answer also solut attempt circumv judg result disqualif exampl 1 input array 1234531 target 3 output 2 explan 3 exist array index2 index5 return minimum index 2 exampl 2 input array 012421 target 3 output 1 explan 3 exist array return 1 constraint 3 mountainarrlength 104 0 target 109 0 mountainarrgetindex 109 findinmountainarray
implement bstiter class repres iter inord travers binari search tree bst bstiteratortreenod root initi object bstiter class root bst given part constructor pointer initi nonexist number smaller element bst boolean hasnext return true exist number travers right pointer otherwis return fals int next move pointer right return number pointer notic initi pointer nonexist smallest number first call next return smallest element bst may assum next call alway valid least next number inord travers next call exampl 1 input bstiter next next hasnext next hasnext next hasnext next hasnext 7 3 15 null null 9 20 output null 3 7 true 9 true 15 true 20 fals explan bstiter bstiter new bstiterator7 3 15 null null 9 20 bstiteratornext return 3 bstiteratornext return 7 bstiteratorhasnext return true bstiteratornext return 9 bstiteratorhasnext return true bstiteratornext return 15 bstiteratorhasnext return true bstiteratornext return 20 bstiteratorhasnext return fals constraint number node tree rang 1 105 0 nodev 106 105 call made hasnext next follow could implement next hasnext run averag o1 time use oh memori h height tree binarysearchtreeiter
given array event eventsi startdayi enddayi everi event start startdayi end enddayi attend event day starttimei endtimei attend one event time return maximum number event attend exampl 1 input event 122334 output 3 explan attend three event one way attend shown attend first event day 1 attend second event day 2 attend third event day 3 exampl 2 input event 12233412 output 4 constraint 1 eventslength 105 eventsilength 2 1 startdayi enddayi 105 maximumnumberofeventsthatcanbeattend
given integ array num choos exactli one index 0index remov element notic index element may chang remov exampl num 61741 choos remov index 1 result num 6741 choos remov index 2 result num 6141 choos remov index 4 result num 6174 array fair sum oddindex valu equal sum evenindex valu return number indic could choos remov num fair exampl 1 input num 2164 output 1 explan remov index 0 164 even sum 1 4 5 odd sum 6 fair remov index 1 264 even sum 2 4 6 odd sum 6 fair remov index 2 214 even sum 2 4 6 odd sum 1 fair remov index 3 216 even sum 2 6 8 odd sum 1 fair 1 index remov make num fair exampl 2 input num 111 output 3 explan remov index remain array fair exampl 3 input num 123 output 0 explan make fair array remov index constraint 1 numslength 105 1 numsi 104 waystomakeafairarray
given integ n return number trail zero n note n n n 1 n 2 3 2 1 exampl 1 input n 3 output 0 explan 3 6 trail zero exampl 2 input n 5 output 1 explan 5 120 one trail zero exampl 3 input n 0 output 0 constraint 0 n 104 follow could write solut work logarithm time complex factorialtrailingzero
herci want save money first car put money leetcod bank everi day start put 1 monday first day everi day tuesday sunday put 1 day everi subsequ monday put 1 previou monday given n return total amount money leetcod bank end nth day exampl 1 input n 4 output 10 explan 4th day total 1 2 3 4 10 exampl 2 input n 10 output 37 explan 10th day total 1 2 3 4 5 6 7 2 3 4 37 notic 2nd monday herci put 2 exampl 3 input n 20 output 96 explan 20th day total 1 2 3 4 5 6 7 2 3 4 5 6 7 8 3 4 5 6 7 8 96 constraint 1 n 1000 calculatemoneyinleetcodebank
given two string array word1 word2 return true two array repres string fals otherwis string repres array array element concaten order form string exampl 1 input word1 ab c word2 bc output true explan word1 repres string ab c abc word2 repres string bc abc string return true exampl 2 input word1 cb word2 ab c output fals exampl 3 input word1 abc defg word2 abcddefg output true constraint 1 word1length word2length 103 1 word1ilength word2ilength 103 1 sumword1ilength sumword2ilength 103 word1i word2i consist lowercas letter checkiftwostringarraysareequival
altern sum 0index array defin sum element even indic minu sum element odd indic exampl altern sum 4253 4 5 2 3 4 given array num return maximum altern sum subsequ num reindex element subsequ subsequ array new array gener origin array delet element possibl none without chang remain element rel order exampl 274 subsequ 4237214 underlin element 242 exampl 1 input num 4253 output 7 explan optim choos subsequ 425 altern sum 4 5 2 7 exampl 2 input num 5678 output 8 explan optim choos subsequ 8 altern sum 8 exampl 3 input num 621245 output 10 explan optim choos subsequ 615 altern sum 6 5 1 10 constraint 1 numslength 105 1 numsi 105 maximumalternatingsubsequencesum
n server number 0 n 1 connect undirect servertoserv connect form network connectionsi ai bi repres connect server ai bi server reach server directli indirectli network critic connect connect remov make server unabl reach server return critic connect network order exampl 1 input n 4 connect 01122013 output 13 explan 31 also accept exampl 2 input n 2 connect 01 output 01 constraint 2 n 105 n 1 connectionslength 105 0 ai bi n 1 ai bi repeat connect criticalconnectionsinanetwork
given 0index string also given 0index string querycharact length k 0index array integ indic queryindic length k use describ k queri ith queri updat charact index queryindicesi charact querycharactersi return array length length k lengthsi length longest substr consist one repeat charact ith queri perform exampl 1 input babacc querycharact bcb queryindic 133 output 334 explan 1st queri updat bbbacc longest substr consist one repeat charact bbb length 3 2nd queri updat bbbccc longest substr consist one repeat charact bbb ccc length 3 3rd queri updat bbbbcc longest substr consist one repeat charact bbbb length 4 thu return 334 exampl 2 input abyzz querycharact aa queryindic 21 output 23 explan 1st queri updat abazz longest substr consist one repeat charact zz length 2 2nd queri updat aaazz longest substr consist one repeat charact aaa length 3 thu return 23 constraint 1 slength 105 consist lowercas english letter k querycharacterslength queryindiceslength 1 k 105 querycharact consist lowercas english letter 0 queryindicesi slength longestsubstringofonerepeatingcharact
n friend play game friend sit circl number 1 n clockwis order formal move clockwis ith friend bring i1th friend 1 n move clockwis nth friend bring 1st friend rule game follow start 1st friend count next k friend clockwis direct includ friend start count wrap around circl may count friend last friend count leav circl lose game still one friend circl go back step 2 start friend immedi clockwis friend lost repeat els last friend circl win game given number friend n integ k return winner game exampl 1 input n 5 k 2 output 3 explan step game 1 start friend 1 2 count 2 friend clockwis friend 1 2 3 friend 2 leav circl next start friend 3 4 count 2 friend clockwis friend 3 4 5 friend 4 leav circl next start friend 5 6 count 2 friend clockwis friend 5 1 7 friend 1 leav circl next start friend 3 8 count 2 friend clockwis friend 3 5 9 friend 5 leav circl friend 3 left winner exampl 2 input n 6 k 5 output 1 explan friend leav order 5 4 6 2 3 winner friend 1 constraint 1 k n 500 follow could solv problem linear time constant space findthewinnerofthecirculargam
given three integ x bound return list power integ valu less equal bound integ power repres xi yj integ 0 j 0 may return answer order answer valu occur exampl 1 input x 2 3 bound 10 output 23457910 explan 2 20 30 3 21 30 4 20 31 5 21 31 7 22 31 9 23 30 10 20 32 exampl 2 input x 3 5 bound 15 output 24681014 constraint 1 x 100 0 bound 106 powerfulinteg
given root binari tree n node node tree nodev coin n coin total throughout whole tree one move may choos two adjac node move one coin one node anoth move may parent child child parent return minimum number move requir make everi node exactli one coin exampl 1 input root 300 output 2 explan root tree move one coin left child one coin right child exampl 2 input root 030 output 3 explan left child root move two coin root take two move move one coin root tree right child constraint number node tree n 1 n 100 0 nodev n sum nodev n distributecoinsinbinarytre
given tree n node number 0 n 1 form parent array parent parenti parent ith node root tree node 0 find kth ancestor given node kth ancestor tree node kth node path node root node implement treeancestor class treeancestorint n int parent initi object number node tree parent array int getkthancestorint node int k return kth ancestor given node node ancestor return 1 exampl 1 input treeancestor getkthancestor getkthancestor getkthancestor 7 1 0 0 1 1 2 2 3 1 5 2 6 3 output null 1 0 1 explan treeancestor treeancestor new treeancestor7 1 0 0 1 1 2 2 treeancestorgetkthancestor3 1 return 1 parent 3 treeancestorgetkthancestor5 2 return 0 grandpar 5 treeancestorgetkthancestor6 3 return 1 ancestor constraint 1 k n 5 104 parentlength n parent0 1 0 parenti n 0 n 0 node n 5 104 queri kthancestorofatreenod
given binari string return number substr charact 1s sinc answer may larg return modulo 109 7 exampl 1 input 0110111 output 9 explan 9 substr total 1s charact 1 5 time 11 3 time 111 1 time exampl 2 input 101 output 2 explan substr 1 shown 2 time exampl 3 input 111111 output 21 explan substr contain 1s charact constraint 1 slength 105 si either 0 1 numberofsubstringswithonly1
serial convert data structur object sequenc bit store file memori buffer transmit across network connect link reconstruct later anoth comput environ design algorithm serial deseri binari search tree restrict serializationdeseri algorithm work need ensur binari search tree serial string string deseri origin tree structur encod string compact possibl exampl 1 input root 213 output 213 exampl 2 input root output constraint number node tree rang 0 104 0 nodev 104 input tree guarante binari search tree serializeanddeserializebst
given array num integ move consist choos element decreas 1 array zigzag array either everi evenindex element greater adjac element ie a0 a1 a2 a3 a4 everi oddindex element greater adjac element ie a0 a1 a2 a3 a4 return minimum number move transform given array num zigzag array exampl 1 input num 123 output 2 explan decreas 2 0 3 1 exampl 2 input num 96162 output 4 constraint 1 numslength 1000 1 numsi 1000 decreaseelementstomakearrayzigzag
given integ array num posit integ k choos subsequ array sum element togeth defin ksum array kth largest subsequ sum obtain necessarili distinct return ksum array subsequ array deriv anoth array delet element without chang order remain element note empti subsequ consid sum 0 exampl 1 input num 242 k 5 output 2 explan possibl subsequ sum obtain follow sort decreas order 6 4 4 2 2 0 0 2 5sum array 2 exampl 2 input num 12341012 k 16 output 10 explan 16sum array 10 constraint n numslength 1 n 105 109 numsi 109 1 k min2000 2n findtheksumofanarray
given posit integ n gener n x n matrix fill element 1 n2 spiral order exampl 1 input n 3 output 123894765 exampl 2 input n 1 output 1 constraint 1 n 20 spiralmatrixii
design implement circular doubleend queue dequ implement mycirculardequ class mycirculardequeint k initi dequ maximum size k boolean insertfront add item front dequ return true oper success fals otherwis boolean insertlast add item rear dequ return true oper success fals otherwis boolean deletefront delet item front dequ return true oper success fals otherwis boolean deletelast delet item rear dequ return true oper success fals otherwis int getfront return front item dequ return 1 dequ empti int getrear return last item dequ return 1 dequ empti boolean isempti return true dequ empti fals otherwis boolean isful return true dequ full fals otherwis exampl 1 input mycirculardequ insertlast insertlast insertfront insertfront getrear isful deletelast insertfront getfront 3 1 2 3 4 4 output null true true true fals 2 true true true 4 explan mycirculardequ mycirculardequ new mycirculardeque3 mycirculardequeinsertlast1 return true mycirculardequeinsertlast2 return true mycirculardequeinsertfront3 return true mycirculardequeinsertfront4 return fals queue full mycirculardequegetrear return 2 mycirculardequeisful return true mycirculardequedeletelast return true mycirculardequeinsertfront4 return true mycirculardequegetfront return 4 constraint 1 k 1000 0 valu 1000 2000 call made insertfront insertlast deletefront deletelast getfront getrear isempti isful designcirculardequ
given string consist n charact either x move defin select three consecut charact convert note move appli charact stay return minimum number move requir charact convert exampl 1 input xxx output 1 explan xxx ooo select 3 charact convert one move exampl 2 input xxox output 2 explan xxox ooox oooo select first 3 charact first move convert select last 3 charact convert final string contain os exampl 3 input oooo output 0 explan xs convert constraint 3 slength 1000 si either x minimummovestoconvertstr
given two string s1 s2 equal length string swap oper choos two indic string necessarili differ swap charact indic return true possibl make string equal perform one string swap exactli one string otherwis return fals exampl 1 input s1 bank s2 kanb output true explan exampl swap first charact last charact s2 make bank exampl 2 input s1 attack s2 defend output fals explan imposs make equal one string swap exampl 3 input s1 kelb s2 kelb output true explan two string alreadi equal string swap oper requir constraint 1 s1length s2length 100 s1length s2length s1 s2 consist lowercas english letter checkifonestringswapcanmakestringsequ
project list requir skill reqskil list peopl ith person peoplei contain list skill person consid suffici team set peopl everi requir skill reqskil least one person team skill repres team index person exampl team 0 1 3 repres peopl skill people0 people1 people3 return suffici team smallest possibl size repres index person may return answer order guarante answer exist exampl 1 input reqskil javanodejsreactj peopl javanodejsnodejsreactj output 02 exampl 2 input reqskil algorithmsmathjavareactjscsharpaw peopl algorithmsmathjavaalgorithmsmathreactjsjavacsharpawsreactjscsharpcsharpmathawsjava output 12 constraint 1 reqskillslength 16 1 reqskillsilength 16 reqskillsi consist lowercas english letter string reqskil uniqu 1 peoplelength 60 0 peopleilength 16 1 peopleijlength 16 peopleij consist lowercas english letter string peoplei uniqu everi skill peoplei skill reqskil guarante suffici team exist smallestsufficientteam
given root binari tree node tree distinct valu delet node valu todelet left forest disjoint union tree return root tree remain forest may return result order exampl 1 input root 1234567 todelet 35 output 12null467 exampl 2 input root 124null3 todelet 3 output 124 constraint number node given tree 1000 node distinct valu 1 1000 todeletelength 1000 todelet contain distinct valu 1 1000 deletenodesandreturnforest
given head link list contain seri integ separ 0s begin end link list nodev 0 everi two consecut 0s merg node lie singl node whose valu sum merg node modifi list contain 0s return head modifi link list exampl 1 input head 03104520 output 411 explan figur repres given link list modifi list contain sum node mark green 3 1 4 sum node mark red 4 5 2 11 exampl 2 input head 01030220 output 134 explan figur repres given link list modifi list contain sum node mark green 1 1 sum node mark red 3 3 sum node mark yellow 2 2 4 constraint number node list rang 3 2 105 0 nodev 1000 two consecut node nodev 0 begin end link list nodev 0 mergenodesinbetweenzero
given integ array num return sum divisor integ array exactli four divisor integ array return 0 exampl 1 input num 2147 output 32 explan 21 4 divisor 1 3 7 21 4 3 divisor 1 2 4 7 2 divisor 1 7 answer sum divisor 21 exampl 2 input num 2121 output 64 exampl 3 input num 12345 output 0 constraint 1 numslength 104 1 numsi 105 fourdivisor
alphabet board start posit 0 0 correspond charact board00 board abcd fghij klmno pqrst uvwxi z shown diagram may make follow move u move posit one row posit exist board move posit one row posit exist board l move posit left one column posit exist board r move posit right one column posit exist board add charact boardrc current posit r c answer posit exist board posit letter return sequenc move make answer equal target minimum number move may return path exampl 1 input target leet output ddruurrrddd exampl 2 input target code output rrddrruulr constraint 1 targetlength 100 target consist english lowercas letter alphabetboardpath
given array equallength string word assum length string n string wordsi convert differ integ array differencei length n 1 differenceij wordsij1 wordsij 0 j n 2 note differ two letter differ posit alphabet ie posit 0 b 1 z 25 exampl string acb differ integ array 2 0 1 2 2 1 string word differ integ array except one find string return string word differ differ integ array exampl 1 input word adcwzyabc output abc explan differ integ array adc 3 0 2 3 3 1 differ integ array wzi 25 22 24 25 3 1 differ integ array abc 1 0 2 1 1 1 odd array 1 1 return correspond string abc exampl 2 input word aaabobcccddd output bob explan integ array 0 0 except bob correspond 13 13 constraint 3 wordslength 100 n wordsilength 2 n 20 wordsi consist lowercas english letter oddstringdiffer
sql schema pandan schema tabl order column name type ordernumb int customernumb int sql ordernumb primari key tabl tabl contain inform order id custom id find customernumb custom place largest number order test case gener exactli one custom place order custom result format follow exampl exampl 1 input order tabl ordernumb customernumb 1 1 2 2 3 3 4 3 output customernumb 3 explan custom number 3 two order greater either custom 1 2 one order result customernumb 3 follow one custom largest number order find customernumb case customerplacingthelargestnumberoford
given integ array num return number arithmet subsequ num sequenc number call arithmet consist least three element differ two consecut element exampl 1 3 5 7 9 7 7 7 7 3 1 5 9 arithmet sequenc exampl 1 1 2 5 7 arithmet sequenc subsequ array sequenc form remov element possibl none array exampl 2510 subsequ 121241510 test case gener answer fit 32bit integ exampl 1 input num 246810 output 7 explan arithmet subsequ slice 246 468 6810 2468 46810 246810 2610 exampl 2 input num 77777 output 16 explan subsequ array arithmet constraint 1 numslength 1000 231 numsi 231 1 arithmeticslicesiisubsequ
given root binari tree instal camera tree node camera node monitor parent immedi children return minimum number camera need monitor node tree exampl 1 input root 00null00 output 1 explan one camera enough monitor node place shown exampl 2 input root 00null0null0nullnull0 output 2 explan least two camera need monitor node tree imag show one valid configur camera placement constraint number node tree rang 1 1000 nodev 0 binarytreecamera
split integ array good array split three nonempti contigu subarray name left mid right respect left right sum element left less equal sum element mid sum element mid less equal sum element right given num array nonneg integ return number good way split num number may larg return modulo 109 7 exampl 1 input num 111 output 1 explan good way split num 1 1 1 exampl 2 input num 122250 output 3 explan three good way split num 1 2 2250 1 22 250 12 22 50 exampl 3 input num 321 output 0 explan good way split num constraint 3 numslength 105 0 numsi 104 waystosplitarrayintothreesubarray
given binari string binari subsequ binari consid good empti lead zero except 0 find number uniqu good subsequ binari exampl binari 001 good subsequ 0 0 1 uniqu good subsequ 0 1 note subsequ 00 01 001 good lead zero return number uniqu good subsequ binari sinc answer may larg return modulo 109 7 subsequ sequenc deriv anoth sequenc delet element without chang order remain element exampl 1 input binari 001 output 2 explan good subsequ binari 0 0 1 uniqu good subsequ 0 1 exampl 2 input binari 11 output 2 explan good subsequ binari 1 1 11 uniqu good subsequ 1 11 exampl 3 input binari 101 output 5 explan good subsequ binari 1 0 1 10 11 101 uniqu good subsequ 0 1 10 11 101 constraint 1 binarylength 105 binari consist 0s 1s numberofuniquegoodsubsequ
given root two binari tree p q write function check two binari tree consid structur ident node valu exampl 1 input p 123 q 123 output true exampl 2 input p 12 q 1null2 output fals exampl 3 input p 121 q 112 output fals constraint number node tree rang 0 100 104 nodev 104 sametre
problem tree undirect graph connect cycl given graph start tree n node label 1 n one addit edg ad ad edg two differ vertic chosen 1 n edg alreadi exist graph repres array edg length n edgesi ai bi indic edg node ai bi graph return edg remov result graph tree n node multipl answer return answer occur last input exampl 1 input edg 121323 output 23 exampl 2 input edg 1223341415 output 14 constraint n edgeslength 3 n 1000 edgesilength 2 1 ai bi edgeslength ai bi repeat edg given graph connect redundantconnect
given 0index array arr consist n posit integ posit integ k array arr call kincreas arrik arri hold everi index k n1 exampl arr 4 1 5 2 6 2 kincreas k 2 arr0 arr2 4 5 arr1 arr3 1 2 arr2 arr4 5 6 arr3 arr5 2 2 howev arr kincreas k 1 arr0 arr1 k 3 arr0 arr3 one oper choos index chang arri posit integ return minimum number oper requir make array kincreas given k exampl 1 input arr 54321 k 1 output 4 explan k 1 result array nondecreas kincreas array form 56789 11111 22344 requir 4 oper suboptim chang array exampl 678910 would take 5 oper shown make array kincreas less 4 oper exampl 2 input arr 415262 k 2 output 0 explan exampl one problem descript everi index 2 5 arri2 arri sinc given array alreadi kincreas need perform oper exampl 3 input arr 415262 k 3 output 2 explan indic 3 5 one satisfi arri3 arri 3 5 one way make array kincreas chang arr3 4 arr5 5 array 415465 note way make array kincreas none requir less 2 oper constraint 1 arrlength 105 1 arri k arrlength minimumoperationstomakethearraykincreas
given integ array arr return mean remain integ remov smallest 5 largest 5 element answer within 105 actual answer consid accept exampl 1 input arr 12222222222222222223 output 200000 explan eras minimum maximum valu array element equal 2 mean 2 exampl 2 input arr 627512031025055087680 output 400000 exampl 3 input arr 607075783407816811248195438510866106108234 output 477778 constraint 20 arrlength 1000 arrlength multipl 20 0 arri 105 meanofarrayafterremovingsomeel
given head link list delet middl node return head modifi link list middl node link list size n ⌊n 2⌋th node start use 0base index ⌊x⌋ denot largest integ less equal x n 1 2 3 4 5 middl node 0 1 1 2 2 respect exampl 1 input head 1347126 output 134126 explan figur repres given link list indic node written sinc n 7 node 3 valu 7 middl node mark red return new list remov node exampl 2 input head 1234 output 124 explan figur repres given link list n 4 node 2 valu 3 middl node mark red exampl 3 input head 21 output 2 explan figur repres given link list n 2 node 1 valu 1 middl node mark red node 0 valu 2 node remain remov node 1 constraint number node list rang 1 105 1 nodev 105 deletethemiddlenodeofalinkedlist
trie pronounc tri prefix tree tree data structur use effici store retriev key dataset string variou applic data structur autocomplet spellcheck implement trie class trie initi trie object void insertstr word insert string word trie boolean searchstr word return true string word trie ie insert fals otherwis boolean startswithstr prefix return true previous insert string word prefix prefix fals otherwis exampl 1 input trie insert search search startswith insert search appl appl app app app app output null null true fals true null true explan trie trie new trie trieinsertappl triesearchappl return true triesearchapp return fals triestartswithapp return true trieinsertapp triesearchapp return true constraint 1 wordlength prefixlength 2000 word prefix consist lowercas english letter 3 104 call total made insert search startswith implementtrieprefixtre
given input string revers order word word defin sequenc nonspac charact word separ least one space return string word revers order concaten singl space note may contain lead trail space multipl space two word return string singl space separ word includ extra space exampl 1 input sky blue output blue sky exampl 2 input hello world output world hello explan revers string contain lead trail space exampl 3 input good exampl output exampl good explan need reduc multipl space two word singl space revers string constraint 1 slength 104 contain english letter uppercas lowercas digit space least one word followup string data type mutabl languag solv inplac o1 extra space reversewordsinastr
valid parenthes string either empti b b valid parenthes string repres string concaten exampl valid parenthes string valid parenthes string primit nonempti exist way split b b nonempti valid parenthes string given valid parenthes string consid primit decomposit p1 p2 pk pi primit valid parenthes string return remov outermost parenthes everi primit string primit decomposit exampl 1 input output explan input string primit decomposit remov outer parenthes part exampl 2 input output explan input string primit decomposit remov outer parenthes part exampl 3 input output explan input string primit decomposit remov outer parenthes part constraint 1 slength 105 si either valid parenthes string removeoutermostparenthes
given string contain star one oper choos star remov closest nonstar charact left well remov star return string star remov note input gener oper alway possibl shown result string alway uniqu exampl 1 input leetcod output leco explan perform remov left right closest charact 1st star leetcod becom leecod closest charact 2nd star e leecod becom lecod closest charact 3rd star lecod becom leco star return leco exampl 2 input eras output explan entir string remov return empti string constraint 1 slength 105 consist lowercas english letter star oper perform removingstarsfromastr
given two 0index integ array num multipli size n respect n begin score 0 want perform exactli oper ith oper 0index choos one integ x either start end array num add multipliersi x score note multipliers0 correspond first oper multipliers1 second oper remov x num return maximum score perform oper exampl 1 input num 123 multipli 321 output 14 explan optim solut follow choos end 123 ad 3 3 9 score choos end 12 ad 2 2 4 score choos end 1 ad 1 1 1 score total score 9 4 1 14 exampl 2 input num 533271 multipli 105346 output 102 explan optim solut follow choos start 533271 ad 5 10 50 score choos start 33271 ad 3 5 15 score choos start 3271 ad 3 3 9 score choos end 271 ad 1 4 4 score choos end 27 ad 7 6 42 score total score 50 15 9 4 42 102 constraint n numslength multiplierslength 1 300 n 105 1000 numsi multipliersi 1000 maximumscorefromperformingmultiplicationoper
sql schema tabl signup column name type userid int timestamp datetim userid primari key tabl row contain inform signup time user id userid tabl confirm column name type userid int timestamp datetim action enum userid timestamp primari key tabl userid foreign key refer signup tabl action enum type confirm timeout row tabl indic user id userid request confirm messag timestamp confirm messag either confirm confirm expir without confirm timeout confirm rate user number confirm messag divid total number request confirm messag confirm rate user request confirm messag 0 round confirm rate two decim place write sql queri find confirm rate user return result tabl order queri result format follow exampl exampl 1 input signup tabl userid timestamp 3 20200321 101613 7 20200104 135759 2 20200729 230944 6 20201209 103937 confirm tabl userid timestamp action 3 20210106 033046 timeout 3 20210714 140000 timeout 7 20210612 115729 confirm 7 20210613 125828 confirm 7 20210614 135927 confirm 2 20210122 000000 confirm 2 20210228 235959 timeout output userid confirmationr 6 000 3 000 7 100 2 050 explan user 6 request confirm messag confirm rate 0 user 3 made 2 request time confirm rate 0 user 7 made 3 request confirm confirm rate 1 user 2 made 2 request one confirm time confirm rate 1 2 05 confirmationr
program suppos print array integ program forgot print whitespac array print string digit know integ array rang 1 k lead zero array given string integ k return number possibl array print use mention program sinc answer may larg return modulo 109 7 exampl 1 input 1000 k 10000 output 1 explan possibl array 1000 exampl 2 input 1000 k 10 output 0 explan array print way integ 1 10 exampl 3 input 1317 k 2000 output 8 explan possibl array 13171317131713171317131713171317 constraint 1 slength 105 consist digit contain lead zero 1 k 109 restorethearray
given 0index permut n integ num permut call semiord first number equal 1 last number equal n perform oper mani time want make num semiord permut pick two adjac element num swap return minimum number oper make num semiord permut permut sequenc integ 1 n length n contain number exactli exampl 1 input num 2143 output 2 explan make permut semiord use sequenc oper 1 swap 0 j 1 permut becom 1243 2 swap 2 j 3 permut becom 1234 prove sequenc less two oper make num semiord permut exampl 2 input num 2413 output 3 explan make permut semiord use sequenc oper 1 swap 1 j 2 permut becom 2143 2 swap 0 j 1 permut becom 1243 3 swap 2 j 3 permut becom 1234 prove sequenc less three oper make num semiord permut exampl 3 input num 13425 output 0 explan permut alreadi semiord permut constraint 2 numslength n 50 1 numsi 50 num permut semiorderedpermut
given matrix target return number nonempti submatric sum target submatrix x1 y1 x2 y2 set cell matrixxi x1 x x2 y1 y2 two submatric x1 y1 x2 y2 x1 y1 x2 y2 differ coordin differ exampl x1 x1 exampl 1 input matrix 010111010 target 0 output 4 explan four 1x1 submatric contain 0 exampl 2 input matrix 1111 target 0 output 5 explan two 1x2 submatric plu two 2x1 submatric plu 2x2 submatrix exampl 3 input matrix 904 target 0 output 0 constraint 1 matrixlength 100 1 matrix0length 100 1000 matrixi 1000 108 target 108 numberofsubmatricesthatsumtotarget
singlethread cpu execut program contain n function function uniqu id 0 n1 function call store call stack function call start id push onto stack function call end id pop stack function whose id top stack current function execut time function start end write log id whether start end timestamp given list log logsi repres ith log messag format string functionidstart endtimestamp exampl 0start3 mean function call function id 0 start begin timestamp 3 1end2 mean function call function id 1 end end timestamp 2 note function call multipl time possibl recurs function exclus time sum execut time function call program exampl function call twice one call execut 2 time unit anoth call execut 1 time unit exclus time 2 1 3 return exclus time function array valu ith index repres exclus time function id exampl 1 input n 2 log 0start01start21end50end6 output 34 explan function 0 start begin time 0 execut 2 unit time reach end time 1 function 1 start begin time 2 execut 4 unit time end end time 5 function 0 resum execut begin time 6 execut 1 unit time function 0 spend 2 1 3 unit total time execut function 1 spend 4 unit total time execut exampl 2 input n 1 log 0start00start20end50start60end60end7 output 8 explan function 0 start begin time 0 execut 2 unit time recurs call function 0 recurs call start begin time 2 execut 4 unit time function 0 initi call resum execut immedi call function 0 2nd recurs call start begin time 6 execut 1 unit time function 0 initi call resum execut begin time 7 execut 1 unit time function 0 spend 2 4 1 1 8 unit total time execut exampl 3 input n 2 log 0start00start20end51start61end60end7 output 71 explan function 0 start begin time 0 execut 2 unit time recurs call function 0 recurs call start begin time 2 execut 4 unit time function 0 initi call resum execut immedi call function 1 function 1 start begin time 6 execut 1 unit time end end time 6 function 0 resum execut begin time 6 execut 2 unit time function 0 spend 2 4 1 7 unit total time execut function 1 spend 1 unit total time execut constraint 1 n 100 1 logslength 500 0 functionid n 0 timestamp 109 two start event happen timestamp two end event happen timestamp function end log start log exclusivetimeoffunct
given root binari search tree array queri size n consist posit integ find 2d array answer size n answeri mini maxi mini largest valu tree smaller equal queriesi valu exist add 1 instead maxi smallest valu tree greater equal queriesi valu exist add 1 instead return array answer exampl 1 input root 621314915nullnullnullnullnullnull14 queri 2516 output 2246151 explan answer queri follow way largest number smaller equal 2 tree 2 smallest number greater equal 2 still 2 answer first queri 22 largest number smaller equal 5 tree 4 smallest number greater equal 5 6 answer second queri 46 largest number smaller equal 16 tree 15 smallest number greater equal 16 exist answer third queri 151 exampl 2 input root 4null9 queri 3 output 14 explan largest number smaller equal 3 tree exist smallest number greater equal 3 4 answer queri 14 constraint number node tree rang 2 105 1 nodev 106 n querieslength 1 n 105 1 queriesi 106 closestnodesqueriesinabinarysearchtre
given integ array num integ k return length shortest nonempti subarray num sum least k subarray return 1 subarray contigu part array exampl 1 input num 1 k 1 output 1 exampl 2 input num 12 k 4 output 1 exampl 3 input num 212 k 3 output 3 constraint 1 numslength 105 105 numsi 105 1 k 109 shortestsubarraywithsumatleastk
given two integ array sourc target length n also given array allowedswap allowedswapsi ai bi indic allow swap element index ai index bi 0index array sourc note swap element specif pair indic multipl time order ham distanc two array length sourc target number posit element differ formal number indic 0 n1 sourcei targeti 0index return minimum ham distanc sourc target perform amount swap oper array sourc exampl 1 input sourc 1234 target 2145 allowedswap 0123 output 1 explan sourc transform follow way swap indic 0 1 sourc 2134 swap indic 2 3 sourc 2143 ham distanc sourc target 1 differ 1 posit index 3 exampl 2 input sourc 1234 target 1324 allowedswap output 2 explan allow swap ham distanc sourc target 2 differ 2 posit index 1 index 2 exampl 3 input sourc 51243 target 15423 allowedswap 04421314 output 0 constraint n sourcelength targetlength 1 n 105 1 sourcei targeti 105 0 allowedswapslength 105 allowedswapsilength 2 0 ai bi n 1 ai bi minimizehammingdistanceafterswapoper
given 0index integ array num rearrang element num order includ given order let prefix array contain prefix sum num rearrang word prefixi sum element 0 num rearrang score num number posit integ array prefix return maximum score achiev exampl 1 input num 2101333 output 6 explan rearrang array num 2311303 prefix 2565221 score 6 shown 6 maximum score obtain exampl 2 input num 230 output 0 explan rearrang array result score 0 constraint 1 numslength 105 106 numsi 106 rearrangearraytomaximizeprefixscor
given n nonneg integ repres elev map width bar 1 comput much water trap rain exampl 1 input height 010210132121 output 6 explan elev map black section repres array 010210132121 case 6 unit rain water blue section trap exampl 2 input height 420325 output 9 constraint n heightlength 1 n 2 104 0 heighti 105 trappingrainwat
given x n integ array grid robot initi locat topleft corner ie grid00 robot tri move bottomright corner ie gridm 1n 1 robot move either right point time obstacl space mark 1 0 respect grid path robot take includ squar obstacl return number possibl uniqu path robot take reach bottomright corner testcas gener answer less equal 2 109 exampl 1 input obstaclegrid 000010000 output 2 explan one obstacl middl 3x3 grid two way reach bottomright corner 1 right right 2 right right exampl 2 input obstaclegrid 0100 output 1 constraint obstaclegridlength n obstaclegridilength 1 n 100 obstaclegridij 0 1 uniquepathsii
given integ n return true power two otherwis return fals integ n power two exist integ x n 2x exampl 1 input n 1 output true explan 20 1 exampl 2 input n 16 output true explan 24 16 exampl 3 input n 3 output fals constraint 231 n 231 1 follow could solv without loopsrecurs poweroftwo
given string messag posit integ limit must split messag one part base limit result part suffix ab b replac total number part replac index part start 1 go b addit length result part includ suffix equal limit except last part whose length limit result part form suffix remov concaten order equal messag also result contain part possibl return part messag would split array string imposs split messag requir return empti array exampl 1 input messag realli awesom messag limit 9 output thi114 i214 r314eal414li 514a v614ery714 aw814eso914me1014 m1114es1214sa1314ge1414 explan first 9 part take 3 charact begin messag next 5 part take 2 charact finish split messag exampl part includ last length 9 shown possibl split messag less 14 part exampl 2 input messag short messag limit 15 output short mess12age22 explan given constraint string split two part first part compris first 10 charact length 15 next part compris last 3 charact length 8 constraint 1 messagelength 104 messag consist lowercas english letter 1 limit 104 splitmessagebasedonlimit
given string integ k revers first k charact everi 2k charact count start string fewer k charact left revers less 2k greater equal k charact revers first k charact leav origin exampl 1 input abcdefg k 2 output bacdfeg exampl 2 input abcd k 2 output bacd constraint 1 slength 104 consist lowercas english letter 1 k 104 reversestringii
suppos given follow code class foobar public void foo int 0 n printfoo public void bar int 0 n printbar instanc foobar pass two differ thread thread call foo thread b call bar modifi given program output foobar n time exampl 1 input n 1 output foobar explan two thread fire asynchron one call foo call bar foobar output 1 time exampl 2 input n 2 output foobarfoobar explan foobar output 2 time constraint 1 n 1000 printfoobaraltern
binari tree defin flip oper follow choos node swap left right child subtre binari tree x flip equival binari tree make x equal number flip oper given root two binari tree root1 root2 return true two tree flip equival fals otherwis exampl 1 input root1 123456nullnullnull78 root2 132null645nullnullnullnull87 output true explan flip node valu 1 3 5 exampl 2 input root1 root2 output true exampl 3 input root1 root2 1 output fals constraint number node tree rang 0 100 tree uniqu node valu rang 0 99 flipequivalentbinarytre
group n member list variou crime could commit ith crime gener profiti requir groupi member particip member particip one crime member cant particip anoth crime let call profit scheme subset crime gener least minprofit profit total number member particip subset crime n return number scheme chosen sinc answer may larg return modulo 109 7 exampl 1 input n 5 minprofit 3 group 22 profit 23 output 2 explan make profit least 3 group could either commit crime 0 1 crime 1 total 2 scheme exampl 2 input n 10 minprofit 5 group 235 profit 678 output 7 explan make profit least 5 group could commit crime long commit one 7 possibl scheme 0 1 2 01 02 12 012 constraint 1 n 100 0 minprofit 100 1 grouplength 100 1 groupi 100 profitlength grouplength 0 profiti 100 profitableschem
swelter summer day boy want buy ice cream bar store n ice cream bar given array cost length n costsi price ith ice cream bar coin boy initi coin coin spend want buy mani ice cream bar possibl note boy buy ice cream bar order return maximum number ice cream bar boy buy coin coin must solv problem count sort exampl 1 input cost 13241 coin 7 output 4 explan boy buy ice cream bar indic 0124 total price 1 3 2 1 7 exampl 2 input cost 1068778 coin 5 output 0 explan boy afford ice cream bar exampl 3 input cost 163125 coin 20 output 6 explan boy buy ice cream bar total price 1 6 3 1 2 5 18 constraint costslength n 1 n 105 1 costsi 105 1 coin 108 maximumicecreambar
n peopl 40 type hat label 1 40 given 2d integ array hat hatsi list hat prefer ith person return number way n peopl wear differ hat sinc answer may larg return modulo 109 7 exampl 1 input hat 34455 output 1 explan one way choos hat given condit first person choos hat 3 second person choos hat 4 last one hat 5 exampl 2 input hat 35135 output 4 explan 4 way choos hat 35 53 13 15 exampl 3 input hat 1234123412341234 output 24 explan person choos hat label 1 4 number permut 1234 24 constraint n hatslength 1 n 10 1 hatsilength 40 1 hatsij 40 hatsi contain list uniqu integ numberofwaystoweardifferenthatstoeachoth
given root binari search tree lowest highest boundari low high trim tree element lie low high trim tree chang rel structur element remain tree ie node descend remain descend proven uniqu answer return root trim binari search tree note root may chang depend given bound exampl 1 input root 102 low 1 high 2 output 1null2 exampl 2 input root 304null2nullnull1 low 1 high 3 output 32null1 constraint number node tree rang 1 104 0 nodev 104 valu node tree uniqu root guarante valid binari search tree 0 low high 104 trimabinarysearchtre
alic 0index array arr consist n posit integ chose arbitrari posit integ k creat two new 0index integ array lower higher follow manner loweri arri k everi index 0 n higheri arri k everi index 0 n unfortun alic lost three array howev rememb integ present array lower higher array integ belong help alic recov origin array given array num consist 2n integ exactli n integ present lower remain higher return origin array arr case answer uniqu return valid array note test case gener exist least one valid array arr exampl 1 input num 21064812 output 3711 explan arr 3711 k 1 get lower 2610 higher 4812 combin lower higher give us 26104812 permut num anoth valid possibl arr 579 k 3 case lower 246 higher 81012 exampl 2 input num 1133 output 22 explan arr 22 k 1 get lower 11 higher 33 combin lower higher give us 1133 equal num note arr 13 case possibl way obtain 1133 k 0 invalid sinc k must posit exampl 3 input num 5435 output 220 explan possibl combin arr 220 k 215 use get lower 5 higher 435 constraint 2 n numslength 1 n 1000 1 numsi 109 test case gener exist least one valid array arr recovertheoriginalarray
design data structur initi list differ word provid string determin chang exactli one charact string match word data structur implement magicdictionari class magicdictionari initi object void builddictstr dictionari set data structur array distinct string dictionari bool searchstr searchword return true chang exactli one charact searchword match string data structur otherwis return fals exampl 1 input magicdictionari builddict search search search search hello leetcod hello hhllo hell leetcod output null null fals true fals fals explan magicdictionari magicdictionari new magicdictionari magicdictionarybuilddicthello leetcod magicdictionarysearchhello return fals magicdictionarysearchhhllo chang second h e match hello return true magicdictionarysearchhel return fals magicdictionarysearchleetcod return fals constraint 1 dictionarylength 100 1 dictionaryilength 100 dictionaryi consist lowercas english letter string dictionari distinct 1 searchwordlength 100 searchword consist lowercas english letter builddict call search 100 call made search implementmagicdictionari
viru spread rapidli task quarantin infect area instal wall world model x n binari grid isinfect isinfectedij 0 repres uninfect cell isinfectedij 1 repres cell contamin viru wall one wall instal two 4direct adjac cell share boundari everi night viru spread neighbor cell four direct unless block wall resourc limit day instal wall around one region ie affect area continu block infect cell threaten uninfect cell follow night never tie return number wall use quarantin infect region world becom fulli infect return number wall use exampl 1 input isinfect 01000001010000010000000100000000 output 10 explan 2 contamin region first day add 5 wall quarantin viral region left board viru spread second day add 5 wall quarantin viral region right viru fulli contain exampl 2 input isinfect 111101111 output 4 explan even though one cell save 4 wall built notic wall built share boundari two differ cell exampl 3 input isinfect 111000000101011111111000000 output 13 explan region left build two new wall constraint isinfectedlength n isinfectedilength 1 n 50 isinfectedij either 0 1 alway contigu viral region throughout describ process infect strictli uncontamin squar next round containviru
given 0index integ array num return number distinct quadruplet b c numsa numsb numsc numsd b c exampl 1 input num 1236 output 1 explan quadruplet satisfi requir 0 1 2 3 1 2 3 6 exampl 2 input num 33645 output 0 explan quadruplet 33645 exampl 3 input num 11135 output 4 explan 4 quadruplet satisfi requir 0 1 2 3 1 1 1 3 0 1 3 4 1 1 3 5 0 2 3 4 1 1 3 5 1 2 3 4 1 1 3 5 constraint 4 numslength 50 1 numsi 100 countspecialquadruplet
given two string goal return true swap two letter result equal goal otherwis return fals swap letter defin take two indic j 0index j swap charact si sj exampl swap indic 0 2 abcd result cbad exampl 1 input ab goal ba output true explan swap s0 s1 b get ba equal goal exampl 2 input ab goal ab output fals explan letter swap s0 s1 b result ba goal exampl 3 input aa goal aa output true explan swap s0 s1 get aa equal goal constraint 1 slength goallength 2 104 goal consist lowercas letter buddystr
sql schema pandan schema tabl actordirector column name type actorid int directorid int timestamp int sql timestamp primari key column tabl find pair actorid directorid actor cooper director least three time return result tabl order result format follow exampl exampl 1 input actordirector tabl actorid directorid timestamp 1 1 0 1 1 1 1 1 2 1 2 3 1 2 4 2 1 5 2 1 6 output actorid directorid 1 1 explan pair 1 1 cooper exactli 3 time actorsanddirectorswhocooperatedatleastthreetim
special typewrit lowercas english letter z arrang circl pointer charact type pointer point charact pointer initi point charact second may perform one follow oper move pointer one charact counterclockwis clockwis type charact pointer current given string word return minimum number second type charact word exampl 1 input word abc output 5 explan charact print follow type charact 1 second sinc pointer initi move pointer clockwis b 1 second type charact b 1 second move pointer clockwis c 1 second type charact c 1 second exampl 2 input word bza output 7 explan charact print follow move pointer clockwis b 1 second type charact b 1 second move pointer counterclockwis z 2 second type charact z 1 second move pointer clockwis 1 second type charact 1 second exampl 3 input word zjpc output 34 explan charact print follow move pointer counterclockwis z 1 second type charact z 1 second move pointer clockwis j 10 second type charact j 1 second move pointer clockwis p 6 second type charact p 1 second move pointer counterclockwis c 13 second type charact c 1 second constraint 1 wordlength 100 word consist lowercas english letter minimumtimetotypewordusingspecialtypewrit
given 2d integ array num return element num diagon order shown imag exampl 1 input num 123456789 output 142753869 exampl 2 input num 12345678910111213141516 output 16287394121051311141516 constraint 1 numslength 105 1 numsilength 105 1 sumnumsilength 105 1 numsij 105 diagonaltraverseii
given string repres valid express implement basic calcul evalu return result evalu note allow use builtin function evalu string mathemat express eval exampl 1 input 1 1 output 2 exampl 2 input 21 2 output 3 exampl 3 input 1452368 output 23 constraint 1 slength 3 105 consist digit repres valid express use unari oper ie 1 2 3 invalid could use unari oper ie 1 2 3 valid two consecut oper input everi number run calcul fit sign 32bit integ basiccalcul
8 prison cell row cell either occupi vacant day whether cell occupi vacant chang accord follow rule cell two adjac neighbor occupi vacant cell becom occupi otherwis becom vacant note prison row first last cell row cant two adjac neighbor given integ array cell cellsi 1 ith cell occupi cellsi 0 ith cell vacant given integ n return state prison n day ie n chang describ exampl 1 input cell 01011001 n 7 output 00110000 explan follow tabl summar state prison day day 0 0 1 0 1 1 0 0 1 day 1 0 1 1 0 0 0 0 0 day 2 0 0 0 0 1 1 1 0 day 3 0 1 1 0 0 1 0 0 day 4 0 0 0 0 0 1 0 0 day 5 0 1 1 1 0 1 0 0 day 6 0 0 1 0 1 1 0 0 day 7 0 0 1 1 0 0 0 0 exampl 2 input cell 10010010 n 1000000000 output 00111110 constraint cellslength 8 cellsi either 0 1 1 n 109 prisoncellsafternday
given root binari tree return sum valu node evenvalu grandpar node evenvalu grandpar return 0 grandpar node parent parent exist exampl 1 input root 67827139null14nullnullnull5 output 18 explan red node node evenvalu grandpar blue node evenvalu grandpar exampl 2 input root 1 output 0 constraint number node tree rang 1 104 1 nodev 100 sumofnodeswithevenvaluedgrandpar
teacher write test n truefals question denot true f denot fals want confus student maxim number consecut question answer multipl true multipl fals row given string answerkey answerkeyi origin answer ith question addit given integ k maximum number time may perform follow oper chang answer key question f ie set answerkeyi f return maximum number consecut ts fs answer key perform oper k time exampl 1 input answerkey ttff k 2 output 4 explan replac fs ts make answerkey tttt four consecut ts exampl 2 input answerkey tfft k 1 output 3 explan replac first f make answerkey ffft altern replac second f make answerkey tfff case three consecut fs exampl 3 input answerkey ttfttftt k 1 output 5 explan replac first f make answerkey tttttftt altern replac second f make answerkey ttfttttt case five consecut ts constraint n answerkeylength 1 n 5 104 answerkeyi either f 1 k n maximizetheconfusionofanexam
given string consist word space return length last word string word maxim substr consist nonspac charact exampl 1 input hello world output 5 explan last word world length 5 exampl 2 input fli moon output 4 explan last word moon length 4 exampl 3 input luffi still joyboy output 6 explan last word joyboy length 6 constraint 1 slength 104 consist english letter space least one word lengthoflastword
given four integ sx sy tx ty return true possibl convert point sx sy point tx ty oper fals otherwis allow oper point x convert either x x x exampl 1 input sx 1 sy 1 tx 3 ty 5 output true explan one seri move transform start point target 1 1 1 2 1 2 3 2 3 2 3 5 exampl 2 input sx 1 sy 1 tx 2 ty 2 output fals exampl 3 input sx 1 sy 1 tx 1 ty 1 output true constraint 1 sx sy tx ty 109 reachingpoint
given two numer string num1 num2 two integ maxsum minsum denot integ x good num1 x num2 minsum digitsumx maxsum return number good integ sinc answer may larg return modulo 109 7 note digitsumx denot sum digit x exampl 1 input num1 1 num2 12 minsum 1 maxsum 8 output 11 explan 11 integ whose sum digit lie 1 8 123456781011 12 thu return 11 exampl 2 input num1 1 num2 5 minsum 1 maxsum 5 output 5 explan 5 integ whose sum digit lie 1 5 1234 5 thu return 5 constraint 1 num1 num2 1022 1 minsum maxsum 400 countofinteg
given string return number homogen substr sinc answer may larg return modulo 109 7 string homogen charact string substr contigu sequenc charact within string exampl 1 input abbcccaa output 13 explan homogen substr list appear 3 time aa appear 1 time b appear 2 time bb appear 1 time c appear 3 time cc appear 2 time ccc appear 1 time 3 1 2 1 3 2 1 13 exampl 2 input xy output 2 explan homogen substr x exampl 3 input zzzzz output 15 constraint 1 slength 105 consist lowercas letter countnumberofhomogenoussubstr
given string dictionari string worddict return true segment spacesepar sequenc one dictionari word note word dictionari may reus multipl time segment exampl 1 input leetcod worddict leetcod output true explan return true leetcod segment leet code exampl 2 input applepenappl worddict applepen output true explan return true applepenappl segment appl pen appl note allow reus dictionari word exampl 3 input catsandog worddict catsdogsandandcat output fals constraint 1 slength 300 1 worddictlength 1000 1 worddictilength 20 worddicti consist lowercas english letter string worddict uniqu wordbreak
given two ident egg access build n floor label 1 n know exist floor f 0 f n egg drop floor higher f break egg drop floor f break move may take unbroken egg drop floor x 1 x n egg break longer use howev egg break may reus futur move return minimum number move need determin certainti valu f exampl 1 input n 2 output 2 explan drop first egg floor 1 second egg floor 2 first egg break know f 0 second egg break first egg didnt know f 1 otherwis egg surviv know f 2 exampl 2 input n 100 output 14 explan one optim strategi drop 1st egg floor 9 break know f 0 8 drop 2nd egg start floor 1 go one time find f within 8 drop total drop 1 8 9 1st egg break drop 1st egg floor 22 break know f 9 21 drop 2nd egg start floor 10 go one time find f within 12 drop total drop 2 12 14 1st egg break follow similar process drop 1st egg floor 34 45 55 64 72 79 85 90 94 97 99 100 regardless outcom take 14 drop determin f constraint 1 n 1000 eggdropwith2eggsandnfloor
given binari array num integ k kbit flip choos subarray length k num simultan chang everi 0 subarray 1 everi 1 subarray 0 return minimum number kbit flip requir 0 array possibl return 1 subarray contigu part array exampl 1 input num 010 k 1 output 2 explan flip nums0 flip nums2 exampl 2 input num 110 k 2 output 1 explan matter flip subarray size 2 make array becom 111 exampl 3 input num 00010110 k 3 output 3 explan flip nums0nums1nums2 num becom 11110110 flip nums4nums5nums6 num becom 11111000 flip nums5nums6nums7 num becom 11111111 constraint 1 numslength 105 1 k numslength minimumnumberofkconsecutivebitflip
write program solv sudoku puzzl fill empti cell sudoku solut must satisfi follow rule digit 19 must occur exactli row digit 19 must occur exactli column digit 19 must occur exactli 9 3x3 subbox grid charact indic empti cell exampl 1 input board 537619598686348317266284195879 output 534678912672195348198342567859761423426853791713924856961537284287419635345286179 explan input board shown valid solut shown constraint boardlength 9 boardilength 9 boardij digit guarante input board one solut sudokusolv
enter competit given two posit integ initialenergi initialexperi denot initi energi initi experi respect also given two 0index integ array energi experi length n face n oppon order energi experi ith oppon denot energyi experiencei respect face oppon need strictli greater experi energi defeat move next oppon avail defeat ith oppon increas experi experiencei decreas energi energyi start competit train number hour hour train either choos increas initi experi one increas initi energi one return minimum number train hour requir defeat n oppon exampl 1 input initialenergi 5 initialexperi 3 energi 1432 experi 2631 output 8 explan increas energi 11 6 hour train experi 5 2 hour train face oppon follow order energi experi 0th oppon win energi becom 11 1 10 experi becom 5 2 7 energi experi 1st oppon win energi becom 10 4 6 experi becom 7 6 13 energi experi 2nd oppon win energi becom 6 3 3 experi becom 13 3 16 energi experi 3rd oppon win energi becom 3 2 1 experi becom 16 1 17 total 6 2 8 hour train competit return 8 proven smaller answer exist exampl 2 input initialenergi 2 initialexperi 4 energi 1 experi 3 output 0 explan need addit energi experi win competit return 0 constraint n energylength experiencelength 1 n 100 1 initialenergi initialexperi energyi experiencei 100 minimumhoursoftrainingtowinacompetit
given integ mass repres origin mass planet given integ array asteroid asteroidsi mass ith asteroid arrang planet collid asteroid arbitrari order mass planet greater equal mass asteroid asteroid destroy planet gain mass asteroid otherwis planet destroy return true asteroid destroy otherwis return fals exampl 1 input mass 10 asteroid 3919521 output true explan one way order asteroid 9195321 planet collid asteroid mass 9 new planet mass 10 9 19 planet collid asteroid mass 19 new planet mass 19 19 38 planet collid asteroid mass 5 new planet mass 38 5 43 planet collid asteroid mass 3 new planet mass 43 3 46 planet collid asteroid mass 21 new planet mass 46 21 67 asteroid destroy exampl 2 input mass 5 asteroid 49234 output fals explan planet ever gain enough mass destroy asteroid mass 23 planet destroy asteroid mass 5 4 9 4 22 less 23 collis would destroy last asteroid constraint 1 mass 105 1 asteroidslength 105 1 asteroidsi 105 destroyingasteroid
sql schema tabl depart column name type id int revenu int month varchar id month primari key tabl tabl inform revenu depart per month month valu janfebmaraprmayjunjulaugsepoctnovdec write sql queri reformat tabl depart id column revenu column month return result tabl order queri result format follow exampl exampl 1 input depart tabl id revenu month 1 8000 jan 2 9000 jan 3 10000 feb 1 7000 feb 1 6000 mar output id janrevenu febrevenu marrevenu decrevenu 1 8000 7000 6000 null 2 9000 null null null 3 null 10000 null null explan revenu apr dec null note result tabl 13 column 1 depart id 12 month reformatdepartmentt
given integ n task count mani string length n form follow rule charact lower case vowel e u vowel may follow e vowel e may follow vowel may follow anoth vowel may follow u vowel u may follow sinc answer may larg return modulo 109 7 exampl 1 input n 1 output 5 explan possibl string e u exampl 2 input n 2 output 10 explan possibl string ae ea ei ia ie io iu oi ou ua exampl 3 input n 5 output 68 constraint 1 n 2 104 countvowelspermut
given root binari tree zigzag path binari tree defin follow choos node binari tree direct right left current direct right move right child current node otherwis move left child chang direct right left left right repeat second third step cant move tree zigzag length defin number node visit 1 singl node length 0 return longest zigzag path contain tree exampl 1 input root 1null111nullnull11null1nullnullnull1 output 3 explan longest zigzag path blue node right left right exampl 2 input root 111null1nullnull11null1 output 4 explan longest zigzag path blue node left right left right exampl 3 input root 1 output 0 constraint number node tree rang 1 5 104 1 nodev 100 longestzigzagpathinabinarytre
given two string s1 s2 size check permut string s1 break permut string s2 viceversa word s2 break s1 viceversa string x break string size n xi yi alphabet order 0 n1 exampl 1 input s1 abc s2 xya output true explan ayx permut s2xya break string abc permut s1abc exampl 2 input s1 abe s2 acd output fals explan permut s1abe abe aeb bae bea eab eba permut s2acd acd adc cad cda dac dca howev permut s1 break permut s2 viceversa exampl 3 input s1 leetcode s2 interview output true constraint s1length n s2length n 1 n 105 string consist lowercas english letter checkifastringcanbreakanotherstr
undirect tree n node label 0 n 1 given 0index integ array num length n numsi repres valu ith node also given 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree allow delet edg split tree multipl connect compon let valu compon sum numsi node compon return maximum number edg delet everi connect compon tree valu exampl 1 input num 62226 edg 01121334 output 2 explan figur show delet edg 01 34 creat compon node 0 123 4 sum valu compon equal 6 proven better delet exist answer 2 exampl 2 input num 2 edg output 0 explan edg delet constraint 1 n 2 104 numslength n 1 numsi 50 edgeslength n 1 edgesilength 2 0 edgesi0 edgesi1 n 1 edg repres valid tree createcomponentswithsamevalu
string s1 s2 ksimilar nonneg integ k swap posit two letter s1 exactli k time result string equal s2 given two anagram s1 s2 return smallest k s1 s2 ksimilar exampl 1 input s1 ab s2 ba output 1 explan two string 1similar use one swap chang s1 s2 ab ba exampl 2 input s1 abc s2 bca output 2 explan two string 2similar use two swap chang s1 s2 abc bac bca constraint 1 s1length 20 s2length s1length s1 s2 contain lowercas letter set b c e f s2 anagram s1 ksimilarstr
given integ array even length arr return true possibl reorder arr arr2 1 2 arr2 everi 0 lenarr 2 fals otherwis exampl 1 input arr 3136 output fals exampl 2 input arr 2126 output fals exampl 3 input arr 4224 output true explan take two group 24 24 form 2424 2424 constraint 2 arrlength 3 104 arrlength even 105 arri 105 arrayofdoubledpair
given integ n undirect graph n node number 0 n 1 given 2d integ array edg edgesi ai bi denot exist undirect edg connect node ai bi return number pair differ node unreach exampl 1 input n 3 edg 010212 output 0 explan pair node unreach therefor return 0 exampl 2 input n 7 edg 0205241654 output 14 explan 14 pair node unreach 0103061213141523263435364656 therefor return 14 constraint 1 n 105 0 edgeslength 2 105 edgesilength 2 0 ai bi n ai bi repeat edg countunreachablepairsofnodesinanundirectedgraph
defin lcp matrix 0index string word n lowercas english letter n x n grid lcpij equal length longest common prefix substr wordin1 wordjn1 given n x n matrix lcp return alphabet smallest string word correspond lcp string return empti string string lexicograph smaller string b length first posit b differ string letter appear earlier alphabet correspond letter b exampl aabd lexicograph smaller aaca first posit differ third letter b come c exampl 1 input lcp 4020030120200101 output abab explan lcp correspond 4 letter string two altern letter lexicograph smallest abab exampl 2 input lcp 4321332122211111 output aaaa explan lcp correspond 4 letter string singl distinct letter lexicograph smallest aaaa exampl 3 input lcp 4321332122211113 output explan lcp33 equal 3 sinc word33 consist singl letter thu answer exist constraint 1 n lcplength lcpilength 1000 0 lcpij n findthestringwithlcp
given list airlin ticket ticketsi fromi toi repres departur arriv airport one flight reconstruct itinerari order return ticket belong man depart jfk thu itinerari must begin jfk multipl valid itinerari return itinerari smallest lexic order read singl string exampl itinerari jfk lga smaller lexic order jfk lgb may assum ticket form least one valid itinerari must use ticket exampl 1 input ticket muclhrjfkmucsfosjclhrsfo output jfkmuclhrsfosjc exampl 2 input ticket jfksfojfkatlsfoatlatljfkatlsfo output jfkatljfksfoatlsfo explan anoth possibl reconstruct jfksfoatljfkatlsfo larger lexic order constraint 1 ticketslength 300 ticketsilength 2 fromilength 3 toilength 3 fromi toi consist uppercas english letter fromi toi reconstructitinerari
given integ n roll fair 6side dice n time determin total number distinct sequenc roll possibl follow condit satisfi greatest common divisor adjac valu sequenc equal 1 least gap 2 roll equal valu roll formal valu ith roll equal valu jth roll absi j 2 return total number distinct sequenc possibl sinc answer may larg return modulo 109 7 two sequenc consid distinct least one element differ exampl 1 input n 4 output 184 explan possibl sequenc 1 2 3 4 6 1 2 3 1 2 3 1 etc invalid sequenc 1 2 1 3 1 2 3 6 1 2 1 3 invalid sinc first third roll equal valu abs1 3 2 j 1index 1 2 3 6 invalid sinc greatest common divisor 3 6 3 total 184 distinct sequenc possibl return 184 exampl 2 input n 2 output 22 explan possibl sequenc 1 2 2 1 3 2 invalid sequenc 3 6 2 4 sinc greatest common divisor equal 1 total 22 distinct sequenc possibl return 22 constraint 1 n 104 numberofdistinctrollsequ
school class student class final exam given 2d integ array class classesi passi totali know beforehand ith class totali total student passi number student pass exam also given integ extrastud anoth extrastud brilliant student guarante pass exam class assign want assign extrastud student class way maxim averag pass ratio across class pass ratio class equal number student class pass exam divid total number student class averag pass ratio sum pass ratio class divid number class return maximum possibl averag pass ratio assign extrastud student answer within 105 actual answer accept exampl 1 input class 123522 extrastud 2 output 078333 explan assign two extra student first class averag pass ratio equal 34 35 22 3 078333 exampl 2 input class 243945210 extrastud 4 output 053485 constraint 1 classeslength 105 classesilength 2 1 passi totali 105 1 extrastud 105 maximumaveragepassratio
given integ array num integ k append k uniqu posit integ appear num num result total sum minimum return sum k integ append num exampl 1 input num 14251025 k 2 output 5 explan two uniqu posit integ appear num append 2 3 result sum num 1 4 25 10 25 2 3 70 minimum sum two integ append 2 3 5 return 5 exampl 2 input num 56 k 6 output 25 explan six uniqu posit integ appear num append 1 2 3 4 7 8 result sum num 5 6 1 2 3 4 7 8 36 minimum sum six integ append 1 2 3 4 7 8 25 return 25 constraint 1 numslength 105 1 numsi 109 1 k 108 appendkintegerswithminimalsum
given string consist lowercas english letter duplic remov consist choos two adjac equal letter remov repeatedli make duplic remov longer return final string duplic remov made proven answer uniqu exampl 1 input abbaca output ca explan exampl abbaca could remov bb sinc letter adjac equal possibl move result move string aaca aa possibl final string ca exampl 2 input azxxzi output ay constraint 1 slength 105 consist lowercas english letter removealladjacentduplicatesinstr
given integ array num return number tripl tripl tripl indic j k 0 numslength 0 j numslength 0 k numslength numsi numsj numsk 0 repres bitwiseand oper exampl 1 input num 213 output 12 explan could choos follow j k tripl i0 j0 k1 2 2 1 i0 j1 k0 2 1 2 i0 j1 k1 2 1 1 i0 j1 k2 2 1 3 i0 j2 k1 2 3 1 i1 j0 k0 1 2 2 i1 j0 k1 1 2 1 i1 j0 k2 1 2 3 i1 j1 k0 1 1 2 i1 j2 k0 1 3 2 i2 j0 k1 3 2 1 i2 j1 k0 3 1 2 exampl 2 input num 000 output 27 constraint 1 numslength 1000 0 numsi 216 tripleswithbitwiseandequaltozero
given array arr posit integ sort strictli increas order integ k return kth posit integ miss array exampl 1 input arr 234711 k 5 output 9 explan miss posit integ 15689101213 5th miss posit integ 9 exampl 2 input arr 1234 k 2 output 6 explan miss posit integ 567 2nd miss posit integ 6 constraint 1 arrlength 1000 1 arri 1000 1 k 1000 arri arrj 1 j arrlength follow could solv problem less complex kthmissingpositivenumb
given 0index array posit integ candiescount candiescounti repres number candi ith type also given 2d array queri queriesi favoritetypei favoritedayi dailycapi play game follow rule start eat candi day 0 eat candi type unless eaten candi type 1 must eat least one candi per day eaten candi construct boolean array answer answerlength querieslength answeri true eat candi type favoritetypei day favoritedayi without eat dailycapi candi day fals otherwis note eat differ type candi day provid follow rule 2 return construct array answer exampl 1 input candiescount 74538 queri 0224242131000000000 output truefalsetru explan 1 eat 2 candi type 0 day 0 2 candi type 0 day 1 eat candi type 0 day 2 2 eat 4 candi day eat 4 candi everi day eat 4 candi type 0 day 0 4 candi type 0 type 1 day 1 day 2 eat 4 candi type 1 type 2 eat candi type 4 day 2 3 eat 1 candi day eat candi type 2 day 13 exampl 2 input candiescount 52641 queri 3124103310100410030131 output falsetruetruefalsefals constraint 1 candiescountlength 105 1 candiescounti 105 1 querieslength 105 queriesilength 3 0 favoritetypei candiescountlength 0 favoritedayi 109 1 dailycapi 109 canyoueatyourfavoritecandyonyourfavoriteday
given n x n grid contain valu 0 1 0 repres water 1 repres land find water cell distanc nearest land cell maxim return distanc land water exist grid return 1 distanc use problem manhattan distanc distanc two cell x0 y0 x1 y1 x0 x1 y0 y1 exampl 1 input grid 101000101 output 2 explan cell 1 1 far possibl land distanc 2 exampl 2 input grid 100000000 output 4 explan cell 2 2 far possibl land distanc 4 constraint n gridlength n gridilength 1 n 100 gridij 0 1 asfarfromlandasposs
given integ array num integ k return k frequent element may return answer order exampl 1 input num 111223 k 2 output 12 exampl 2 input num 1 k 1 output 1 constraint 1 numslength 105 104 numsi 104 k rang 1 number uniqu element array guarante answer uniqu follow algorithm time complex must better log n n array size topkfrequentel
exist undirect unroot tree n node index 0 n 1 given integ n 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree also given array coin size n coinsi either 0 1 1 indic presenc coin vertex initi choos start vertex tree perform follow oper number time collect coin distanc 2 current vertex move adjac vertex tree find minimum number edg need go collect coin go back initi vertex note pass edg sever time need count answer sever time exampl 1 input coin 100001 edg 0112233445 output 2 explan start vertex 2 collect coin vertex 0 move vertex 3 collect coin vertex 5 move back vertex 2 exampl 2 input coin 00011001 edg 01021314255657 output 2 explan start vertex 0 collect coin vertic 4 3 move vertex 2 collect coin vertex 7 move back vertex 0 constraint n coinslength 1 n 3 104 0 coinsi 1 edgeslength n 1 edgesilength 2 0 ai bi n ai bi edg repres valid tree collectcoinsinatre
given binari array num integ k return true 1s least k place away otherwis return fals exampl 1 input num 10001001 k 2 output true explan 1s least 2 place away exampl 2 input num 100101 k 2 output fals explan second 1 third 1 one apart constraint 1 numslength 105 0 k numslength numsi 0 1 checkifall1sareatleastlengthkplacesaway
given string return true possibl split string three nonempti palindrom substr otherwis return fals string said palindrom string revers exampl 1 input abcbdd output true explan abcbdd bcb dd three substr palindrom exampl 2 input bcbddxi output fals explan split 3 palindrom constraint 3 slength 2000 consist lowercas english letter palindromepartitioningiv
given integ array num even length n integ limit one move replac integ num anoth integ 1 limit inclus array num complementari indic 0index numsi numsn 1 equal number exampl array 1234 complementari indic numsi numsn 1 5 return minimum number move requir make num complementari exampl 1 input num 1243 limit 4 output 1 explan 1 move chang num 1223 underlin element chang nums0 nums3 1 3 4 nums1 nums2 2 2 4 nums2 nums1 2 2 4 nums3 nums0 3 1 4 therefor numsi numsn1i 4 everi num complementari exampl 2 input num 1221 limit 2 output 2 explan 2 move chang num 2222 chang number 3 sinc 3 limit exampl 3 input num 1212 limit 2 output 0 explan num alreadi complementari constraint n numslength 2 n 105 1 numsi limit 105 n even minimummovestomakearraycomplementari
given root binari tree uniqu valu integ start minut 0 infect start node valu start minut node becom infect node current uninfect node adjac infect node return number minut need entir tree infect exampl 1 input root 153null410692 start 3 output 4 explan follow node infect minut 0 node 3 minut 1 node 1 10 6 minut 2 node 5 minut 3 node 4 minut 4 node 9 2 take 4 minut whole tree infect return 4 exampl 2 input root 1 start 1 output 0 explan minut 0 node tree infect return 0 constraint number node tree rang 1 105 1 nodev 105 node uniqu valu node valu start exist tree amountoftimeforbinarytreetobeinfect
given two integ array inord postord inord inord travers binari tree postord postord travers tree construct return binari tree exampl 1 input inord 9315207 postord 9157203 output 3920nullnull157 exampl 2 input inord 1 postord 1 output 1 constraint 1 inorderlength 3000 postorderlength inorderlength 3000 inorderi postorderi 3000 inord postord consist uniqu valu valu postord also appear inord inord guarante inord travers tree postord guarante postord travers tree constructbinarytreefrominorderandpostordertravers
given two string ransomnot magazin return true ransomnot construct use letter magazin fals otherwis letter magazin use ransomnot exampl 1 input ransomnot magazin b output fals exampl 2 input ransomnot aa magazin ab output fals exampl 3 input ransomnot aa magazin aab output true constraint 1 ransomnotelength magazinelength 105 ransomnot magazin consist lowercas english letter ransomnot
friend type name keyboard sometim type charact c key might get long press charact type 1 time examin type charact keyboard return true possibl friend name charact possibl none long press exampl 1 input name alex type aaleex output true explan e alex long press exampl 2 input name saeed type ssaaedd output fals explan e must press twice type output constraint 1 namelength typedlength 1000 name type consist lowercas english letter longpressednam
given callabl function fx hidden formula valu z revers engin formula return posit integ pair x fxi z may return pair order exact formula hidden function monoton increas ie fx fx 1 fx fx 1 function interfac defin like interfac customfunct public return posit integ fx two posit integ x base formula int fint x int judg solut follow judg list 9 hidden implement customfunct along way gener answer key valid pair specif z judg receiv two input functionid determin implement test code target z judg call findsolut compar result answer key result match answer key solut accept exampl 1 input functionid 1 z 5 output 14233241 explan hidden formula functionid 1 fx x follow posit integ valu x make fx equal 5 x1 y4 f1 4 1 4 5 x2 y3 f2 3 2 3 5 x3 y2 f3 2 3 2 5 x4 y1 f4 1 4 1 5 exampl 2 input functionid 2 z 5 output 1551 explan hidden formula functionid 2 fx x follow posit integ valu x make fx equal 5 x1 y5 f1 5 1 5 5 x5 y1 f5 1 5 1 5 constraint 1 functionid 9 1 z 100 guarante solut fx z rang 1 x 1000 also guarante fx fit 32 bit sign integ 1 x 1000 findpositiveintegersolutionforagivenequ
given string lowercas english letter 2d integ array shift shiftsi starti endi directioni everi shift charact index starti index endi inclus forward directioni 1 shift charact backward directioni 0 shift charact forward mean replac next letter alphabet wrap around z becom similarli shift charact backward mean replac previou letter alphabet wrap around becom z return final string shift appli exampl 1 input abc shift 010121021 output ace explan firstli shift charact index 0 index 1 backward zac secondli shift charact index 1 index 2 forward zbd final shift charact index 0 index 2 forward ace exampl 2 input dztz shift 000111 output catz explan firstli shift charact index 0 index 0 backward cztz final shift charact index 1 index 1 forward catz constraint 1 slength shiftslength 5 104 shiftsilength 3 0 starti endi slength 0 directioni 1 consist lowercas english letter shiftinglettersii
given integ array num integ k return number subarray num greatest common divisor subarray element k subarray contigu nonempti sequenc element within array greatest common divisor array largest integ evenli divid array element exampl 1 input num 931263 k 3 output 4 explan subarray num 3 greatest common divisor subarray element 931263 931263 931263 931263 exampl 2 input num 4 k 7 output 0 explan subarray num 7 greatest common divisor subarray element constraint 1 numslength 1000 1 numsi k 109 numberofsubarrayswithgcdequaltok
sentenc list token separ singl space lead trail space everi token either posit number consist digit 09 lead zero word consist lowercas english letter exampl puppi 2 eye 4 leg sentenc seven token 2 4 number token puppi word given string repres sentenc need check number strictli increas left right ie last number number strictli smaller number right return true fals otherwis exampl 1 input 1 box 3 blue 4 red 6 green 12 yellow marbl output true explan number 1 3 4 6 12 strictli increas left right 1 3 4 6 12 exampl 2 input hello world 5 x 5 output fals explan number 5 5 strictli increas exampl 3 input sunset 7 51 pm overnight low low 50 60 output fals explan number 7 51 50 60 strictli increas constraint 3 slength 200 consist lowercas english letter space digit 0 9 inclus number token 2 100 inclus token separ singl space least two number number posit number less 100 lead zero contain lead trail space checkifnumbersareascendinginasent
hiker prepar upcom hike given height 2d array size row x column heightsrowcol repres height cell row col situat topleft cell 0 0 hope travel bottomright cell rows1 columns1 ie 0index move left right wish find rout requir minimum effort rout effort maximum absolut differ height two consecut cell rout return minimum effort requir travel topleft cell bottomright cell exampl 1 input height 122382535 output 2 explan rout 13535 maximum absolut differ 2 consecut cell better rout 12225 maximum absolut differ 3 exampl 2 input height 123384535 output 1 explan rout 12345 maximum absolut differ 1 consecut cell better rout 13535 exampl 3 input height 1211112121121211212111121 output 0 explan rout requir effort constraint row heightslength column heightsilength 1 row column 100 1 heightsij 106 pathwithminimumeffort
given string even length split string two halv equal length let first half b second half two string alik number vowel e u e u notic contain uppercas lowercas letter return true b alik otherwis return fals exampl 1 input book output true explan bo b ok 1 vowel b 1 vowel therefor alik exampl 2 input textbook output fals explan text b book 1 vowel wherea b 2 therefor alik notic vowel count twice constraint 2 slength 1000 slength even consist uppercas lowercas letter determineifstringhalvesarealik
two special charact first charact repres one bit 0 second charact repres two bit 10 11 given binari array bit end 0 return true last charact must onebit charact exampl 1 input bit 100 output true explan way decod twobit charact onebit charact last charact onebit charact exampl 2 input bit 1110 output fals explan way decod twobit charact twobit charact last charact onebit charact constraint 1 bitslength 1000 bitsi either 0 1 1bitand2bitcharact
given string repres attend record student charact signifi whether student absent late present day record contain follow three charact absent l late p present student elig attend award meet follow criteria student absent strictli fewer 2 day total student never late l 3 consecut day return true student elig attend award fals otherwis exampl 1 input ppallp output true explan student fewer 2 absenc never late 3 consecut day exampl 2 input ppalll output fals explan student late 3 consecut day last 3 day elig award constraint 1 slength 1000 si either l p studentattendancerecordi
given integ array rank charact array suit 5 card ith card rank ranksi suit suitsi follow type poker hand make best worst flush five card suit three kind three card rank pair two card rank high card singl card return string repres best type poker hand make given card note return valu casesensit exampl 1 input rank 132319 suit aaaaa output flush explan hand card consist 5 card suit flush exampl 2 input rank 44244 suit daabc output three kind explan hand first second fourth card consist 3 card rank three kind note could also make pair hand three kind better hand also note card could use make three kind hand exampl 3 input rank 10102129 suit abcad output pair explan hand first second card consist 2 card rank pair note make flush three kind constraint rankslength suitslength 5 1 ranksi 13 suitsi two card rank suit bestpokerhand
sql schema pandan schema tabl score column name type id int score decim sql id primari key tabl row tabl contain score game score float point valu two decim place find rank score rank calcul accord follow rule score rank highest lowest tie two score rank tie next rank number next consecut integ valu word hole rank return result tabl order score descend order result format follow exampl exampl 1 input score tabl id score 1 350 2 365 3 400 4 385 5 400 6 365 output score rank 400 1 400 1 385 2 365 3 365 3 350 4 rankscor
given integ matrix iswat size x n repres map land water cell iswaterij 0 cell j land cell iswaterij 1 cell j water cell must assign cell height way follow rule height cell must nonneg cell water cell height must 0 two adjac cell must absolut height differ 1 cell adjac anoth cell former directli north east south west latter ie side touch find assign height maximum height matrix maxim return integ matrix height size x n heightij cell js height multipl solut return exampl 1 input iswat 0100 output 1021 explan imag show assign height cell blue cell water cell green cell land cell exampl 2 input iswat 001100000 output 110011122 explan height 2 maximum possibl height assign height assign maximum height 2 still meet rule also accept constraint iswaterlength n iswaterilength 1 n 1000 iswaterij 0 1 least one water cell mapofhighestpeak
implement program use calendar add new event ad event caus tripl book tripl book happen three event nonempti intersect ie moment common three event event repres pair integ start end repres book halfopen interv start end rang real number x start x end implement mycalendartwo class mycalendartwo initi calendar object boolean bookint start int end return true event ad calendar success without caus tripl book otherwis return fals add event calendar exampl 1 input mycalendartwo book book book book book book 10 20 50 60 10 40 5 15 5 10 25 55 output null true true true fals true true explan mycalendartwo mycalendartwo new mycalendartwo mycalendartwobook10 20 return true event book mycalendartwobook50 60 return true event book mycalendartwobook10 40 return true event doubl book mycalendartwobook5 15 return fals event book would result tripl book mycalendartwobook5 10 return true event book use time 10 alreadi doubl book mycalendartwobook25 55 return true event book time 25 40 doubl book third event time 40 50 singl book time 50 55 doubl book second event constraint 0 start end 109 1000 call made book mycalendarii
n x n grid topleft cell 0 0 bottomright cell n 1 n 1 given integ n integ array startpo startpo startrow startcol indic robot initi cell startrow startcol also given 0index string length si ith instruct robot l move left r move right u move move robot begin execut ith instruct execut instruct one one toward end stop either condit met next instruct move robot grid instruct left execut return array answer length answeri number instruct robot execut robot begin execut ith instruct exampl 1 input n 3 startpo 01 rrddlu output 154310 explan start startpo begin execut ith instruct 0th rrddlu one instruct r execut move grid 1st rddlu five instruct execut stay grid end 1 1 2nd ddlu four instruct execut stay grid end 1 0 3rd dlu three instruct execut stay grid end 0 0 4th lu one instruct l execut move grid 5th u move would move grid exampl 2 input n 2 startpo 11 lurd output 4100 explan 0th lurd 1st urd 2nd rd 3rd exampl 3 input n 1 startpo 00 lrud output 0000 explan matter instruct robot begin execut would move grid constraint slength 1 n 500 startposlength 2 0 startrow startcol n consist l r u executionofallsuffixinstructionsstayinginagrid
given 2n ball k distinct color given integ array ball size k ballsi number ball color ball shuffl uniformli random distribut first n ball first box remain n ball box pleas read explan second exampl care pleas note two box consid differ exampl two ball color b two box distribut b consid differ distribut b pleas read explan first exampl care return probabl two box number distinct ball answer within 105 actual valu accept correct exampl 1 input ball 11 output 100000 explan 2 way divid ball equal ball color 1 box 1 ball color 2 box 2 ball color 2 box 1 ball color 1 box 2 way number distinct color box equal probabl 22 1 exampl 2 input ball 211 output 066667 explan set ball 1 1 2 3 set ball shuffl randomli may one 12 distinct shuffl equal probabl ie 112 11 23 11 32 12 13 12 31 13 12 13 21 21 13 21 31 23 11 31 12 31 21 32 11 add first two ball first box second two ball second box see 8 12 possibl random distribut number distinct color ball box probabl 812 066667 exampl 3 input ball 1212 output 060000 explan set ball 1 2 2 3 4 4 hard display 180 possibl random shuffl set easi check 108 number distinct color box probabl 108 180 06 constraint 1 ballslength 8 1 ballsi 6 sumbal even probabilityofatwoboxeshavingthesamenumberofdistinctbal
citi skylin outer contour silhouett form build citi view distanc given locat height build return skylin form build collect geometr inform build given array build buildingsi lefti righti heighti lefti x coordin left edg ith build righti x coordin right edg ith build heighti height ith build may assum build perfect rectangl ground absolut flat surfac height 0 skylin repres list key point sort xcoordin form x1y1x2y2 key point left endpoint horizont segment skylin except last point list alway ycoordin 0 use mark skylin termin rightmost build end ground leftmost rightmost build part skylin contour note must consecut horizont line equal height output skylin instanc 2 34 57 511 512 7 accept three line height 5 merg one final output 2 34 512 7 exampl 1 input build 291037155121215201019248 output 2103157121201510208240 explan figur show build input figur b show skylin form build red point figur b repres key point output list exampl 2 input build 023253 output 0350 constraint 1 buildingslength 104 0 lefti righti 231 1 1 heighti 231 1 build sort lefti nondecreas order theskylineproblem
x n matrix initi 0s also 2d array indic indicesi ri ci repres 0index locat perform increment oper matrix locat indicesi follow increment cell row ri increment cell column ci given n indic return number oddvalu cell matrix appli increment locat indic exampl 1 input 2 n 3 indic 0111 output 6 explan initi matrix 000000 appli first increment becom 121010 final matrix 131131 contain 6 odd number exampl 2 input 2 n 2 indic 1100 output 0 explan final matrix 2222 odd number final matrix constraint 1 n 50 1 indiceslength 100 0 ri 0 ci n follow could solv indiceslength time extra space cellswithoddvaluesinamatrix
n car travel differ speed direct along onelan road given array car length n carsi positioni speedi repres positioni distanc ith car begin road meter guarante positioni positioni1 speedi initi speed ith car meter per second simplic car consid point move along number line two car collid occupi posit car collid anoth car unit form singl car fleet car form fleet posit speed initi speed slowest car fleet return array answer answeri time second ith car collid next car 1 car collid next car answer within 105 actual answer accept exampl 1 input car 12214372 output 100000100000300000100000 explan exactli one second first car collid second car form car fleet speed 1 ms exactli 3 second third car collid fourth car form car fleet speed 2 ms exampl 2 input car 34546391 output 200000100000150000100000 constraint 1 carslength 105 1 positioni speedi 106 positioni positioni1 carfleetii
bitset data structur compactli store bit implement bitset class bitsetint size initi bitset size bit 0 void fixint idx updat valu bit index idx 1 valu alreadi 1 chang occur void unfixint idx updat valu bit index idx 0 valu alreadi 0 chang occur void flip flip valu bit bitset word bit valu 0 valu 1 vice versa boolean check valu bit bitset 1 return true satisfi condit fals otherwis boolean one check least one bit bitset valu 1 return true satisfi condit fals otherwis int count return total number bit bitset valu 1 string tostr return current composit bitset note result string charact ith index coincid valu ith bit bitset exampl 1 input bitset fix fix flip unfix flip one unfix count tostr 5 3 1 0 0 output null null null null fals null null true null 2 01010 explan bitset bs new bitset5 bitset 00000 bsfix3 valu idx 3 updat 1 bitset 00010 bsfix1 valu idx 1 updat 1 bitset 01010 bsflip valu bit flip bitset 10101 bsall return fals valu bitset 1 bsunfix0 valu idx 0 updat 0 bitset 00101 bsflip valu bit flip bitset 11010 bsone return true least 1 index valu 1 bsunfix0 valu idx 0 updat 0 bitset 01010 bscount return 2 2 bit valu 1 bstostr return 01010 composit bitset constraint 1 size 105 0 idx size 1 105 call made total fix unfix flip one count tostr least one call made one count tostr 5 call made tostr designbitset
given string croakoffrog repres combin string croak differ frog multipl frog croak time multipl croak mix return minimum number differ frog finish croak given string valid croak mean frog print five letter c r k sequenti frog print five letter finish croak given string combin valid croak return 1 exampl 1 input croakoffrog croakcroak output 1 explan one frog yell croak twice exampl 2 input croakoffrog crcoakroak output 2 explan minimum number frog two first frog could yell crcoakroak second frog could yell later crcoakroak exampl 3 input croakoffrog croakcrook output 1 explan given string invalid combin croak differ frog constraint 1 croakoffrogslength 105 croakoffrog either c r k minimumnumberoffrogscroak
given binari string integ k return true everi binari code length k substr otherwis return fals exampl 1 input 00110110 k 2 output true explan binari code length 2 00 01 10 11 found substr indic 0 1 3 2 respect exampl 2 input 0110 k 1 output true explan binari code length 1 0 1 clear exist substr exampl 3 input 0110 k 2 output fals explan binari code 00 length 2 exist array constraint 1 slength 5 105 si either 0 1 1 k 20 checkifastringcontainsallbinarycodesofsizek
power integ x defin number step need transform x 1 use follow step x even x x 2 x odd x 3 x 1 exampl power x 3 7 3 need 7 step becom 1 3 10 5 16 8 4 2 1 given three integ lo hi k task sort integ interv lo hi power valu ascend order two integ power valu sort ascend order return kth integ rang lo hi sort power valu notic integ x lo x hi guarante x transform 1 use step power x fit 32bit sign integ exampl 1 input lo 12 hi 15 k 2 output 13 explan power 12 9 12 6 3 10 5 16 8 4 2 1 power 13 9 power 14 17 power 15 17 interv sort power valu 12131415 k 2 answer second element 13 notic 12 13 power valu sort ascend order 14 15 exampl 2 input lo 7 hi 11 k 4 output 7 explan power array correspond interv 7 8 9 10 11 16 3 19 6 14 interv sort power 8 10 11 7 9 fourth number sort array 7 constraint 1 lo hi 1000 1 k hi lo 1 sortintegersbythepowervalu
given two nonneg integ num1 num2 repres string return sum num1 num2 string must solv problem without use builtin librari handl larg integ biginteg must also convert input integ directli exampl 1 input num1 11 num2 123 output 134 exampl 2 input num1 456 num2 77 output 533 exampl 3 input num1 0 num2 0 output 0 constraint 1 num1length num2length 104 num1 num2 consist digit num1 num2 dont lead zero except zero addstr
given two number arr1 arr2 base 2 return result ad togeth number given array format array 0s 1s signific bit least signific bit exampl arr 1101 repres number 23 22 20 3 number arr array format also guarante lead zero either arr 0 arr0 1 return result ad arr1 arr2 format array 0s 1s lead zero exampl 1 input arr1 11111 arr2 101 output 10000 explan arr1 repres 11 arr2 repres 5 output repres 16 exampl 2 input arr1 0 arr2 0 output 0 exampl 3 input arr1 0 arr2 1 output 1 constraint 1 arr1length arr2length 1000 arr1i arr2i 0 1 arr1 arr2 lead zero addingtwonegabinarynumb
restaur singl chef given array custom customersi arrivali timei arrivali arriv time ith custom arriv time sort nondecreas order timei time need prepar order ith custom custom arriv give chef order chef start prepar idl custom wait till chef finish prepar order chef prepar food one custom time chef prepar food custom order given input return averag wait time custom solut within 105 actual answer consid accept exampl 1 input custom 122543 output 500000 explan 1 first custom arriv time 1 chef take order start prepar immedi time 1 finish time 3 wait time first custom 3 1 2 2 second custom arriv time 2 chef take order start prepar time 3 finish time 8 wait time second custom 8 2 6 3 third custom arriv time 4 chef take order start prepar time 8 finish time 11 wait time third custom 11 4 7 averag wait time 2 6 7 3 5 exampl 2 input custom 5254103201 output 325000 explan 1 first custom arriv time 5 chef take order start prepar immedi time 5 finish time 7 wait time first custom 7 5 2 2 second custom arriv time 5 chef take order start prepar time 7 finish time 11 wait time second custom 11 5 6 3 third custom arriv time 10 chef take order start prepar time 11 finish time 14 wait time third custom 14 10 4 4 fourth custom arriv time 20 chef take order start prepar immedi time 20 finish time 21 wait time fourth custom 21 20 1 averag wait time 2 6 4 1 4 325 constraint 1 customerslength 105 1 arrivali timei 104 arrivali arrivali1 averagewaitingtim
given array item itemsi typei colori namei describ type color name ith item also given rule repres two string rulekey rulevalu ith item said match rule one follow true rulekey type rulevalu typei rulekey color rulevalu colori rulekey name rulevalu namei return number item match given rule exampl 1 input item phonebluepixelcomputersilverlenovophonegoldiphon rulekey color rulevalu silver output 1 explan one item match given rule computersilverlenovo exampl 2 input item phonebluepixelcomputersilverphonephonegoldiphon rulekey type rulevalu phone output 2 explan two item match given rule phonebluepixel phonegoldiphon note item computersilverphon match constraint 1 itemslength 104 1 typeilength colorilength nameilength rulevaluelength 10 rulekey equal either type color name string consist lowercas letter countitemsmatchingarul
given integ array num find maximum possibl bitwis subset num return number differ nonempti subset maximum bitwis array subset array b obtain b delet possibl zero element b two subset consid differ indic element chosen differ bitwis array equal a0 a1 aalength 1 0index exampl 1 input num 31 output 2 explan maximum possibl bitwis subset 3 2 subset bitwis 3 3 31 exampl 2 input num 222 output 7 explan nonempti subset 222 bitwis 2 23 1 7 total subset exampl 3 input num 3215 output 6 explan maximum possibl bitwis subset 7 6 subset bitwis 7 35 315 325 3215 25 215 constraint 1 numslength 16 1 numsi 105 countnumberofmaximumbitwiseorsubset
n project number 0 n 1 given integ array mileston milestonesi denot number mileston ith project work project follow two rule everi week finish exactli one mileston one project must work everi week work two mileston project two consecut week mileston project finish mileston work caus violat rule stop work note may abl finish everi project mileston due constraint return maximum number week would abl work project without violat rule mention exampl 1 input mileston 123 output 6 explan one possibl scenario 1st week work mileston project 0 2nd week work mileston project 2 3rd week work mileston project 1 4th week work mileston project 2 5th week work mileston project 1 6th week work mileston project 2 total number week 6 exampl 2 input mileston 521 output 7 explan one possibl scenario 1st week work mileston project 0 2nd week work mileston project 1 3rd week work mileston project 0 4th week work mileston project 1 5th week work mileston project 0 6th week work mileston project 2 7th week work mileston project 0 total number week 7 note work last mileston project 0 8th week would violat rule thu one mileston project 0 remain unfinish constraint n milestoneslength 1 n 105 1 milestonesi 109 maximumnumberofweeksforwhichyoucanwork
given array point pointsi xi yi repres point xy plane return true point boomerang boomerang set three point distinct straight line exampl 1 input point 112332 output true exampl 2 input point 112233 output fals constraint pointslength 3 pointsilength 2 0 xi yi 100 validboomerang
strang printer follow two special properti printer print sequenc charact time turn printer print new charact start end place cover origin exist charact given string return minimum number turn printer need print exampl 1 input aaabbb output 2 explan print aaa first print bbb exampl 2 input aba output 2 explan print aaa first print b second place string cover exist charact constraint 1 slength 100 consist lowercas english letter strangeprint
given two integ array nums1 nums2 task implement data structur support queri two type add posit integ element given index array nums2 count number pair j nums1i nums2j equal given valu 0 nums1length 0 j nums2length implement findsumpair class findsumpairsint nums1 int nums2 initi findsumpair object two integ array nums1 nums2 void addint index int val add val nums2index ie appli nums2index val int countint tot return number pair j nums1i nums2j tot exampl 1 input findsumpair count add count count add add count 1 1 2 2 2 3 1 4 5 2 5 4 7 3 2 8 4 0 1 1 1 7 output null 8 null 2 1 null null 11 explan findsumpair findsumpair new findsumpairs1 1 2 2 2 3 1 4 5 2 5 4 findsumpairscount7 return 8 pair 22 32 42 24 34 44 make 2 5 pair 51 55 make 3 4 findsumpairsadd3 2 nums2 145454 findsumpairscount8 return 2 pair 52 54 make 3 5 findsumpairscount4 return 1 pair 50 make 3 1 findsumpairsadd0 1 nums2 245454 findsumpairsadd1 1 nums2 255454 findsumpairscount7 return 11 pair 21 22 24 31 32 34 41 42 44 make 2 5 pair 53 55 make 3 4 constraint 1 nums1length 1000 1 nums2length 105 1 nums1i 109 1 nums2i 105 0 index nums2length 1 val 105 1 tot 109 1000 call made add count findingpairswithacertainsum
given two 0index integ array nums1 nums2 equal length n one oper swap valu two indic nums1 cost oper sum indic find minimum total cost perform given oper number time nums1i nums2i 0 n 1 perform oper return minimum total cost nums1 nums2 satisfi condit case possibl return 1 exampl 1 input nums1 12345 nums2 12345 output 10 explan one way perform oper swap valu indic 0 3 incur cost 0 3 3 nums1 42315 swap valu indic 1 2 incur cost 1 2 3 nums1 43215 swap valu indic 0 4 incur cost 0 4 4 nums1 53214 see index nums1i nums2i cost requir 10 note way swap valu proven possibl obtain cost less 10 exampl 2 input nums1 22213 nums2 12233 output 10 explan one way perform oper swap valu indic 2 3 incur cost 2 3 5 nums1 22123 swap valu indic 1 4 incur cost 1 4 5 nums1 23122 total cost need 10 minimum possibl exampl 3 input nums1 122 nums2 122 output 1 explan shown possibl satisfi given condit irrespect number oper perform henc return 1 constraint n nums1length nums2length 1 n 105 1 nums1i nums2i n minimumtotalcosttomakearraysunequ
given two 0index array nums1 nums2 consist nonneg integ exist anoth array nums3 contain bitwis xor pair integ nums1 nums2 everi integ nums1 pair everi integ nums2 exactli return bitwis xor integ nums3 exampl 1 input nums1 213 nums2 10250 output 13 explan possibl nums3 array 8072113419163 bitwis xor number 13 return 13 exampl 2 input nums1 12 nums2 34 output 0 explan possibl pair bitwis xor nums10 nums20 nums10 nums21 nums11 nums20 nums11 nums21 thu one possibl nums3 array 2516 2 5 1 6 0 return 0 constraint 1 nums1length nums2length 105 0 nums1i nums2j 109 bitwisexorofallpair
transform sequenc word beginword word endword use dictionari wordlist sequenc word beginword s1 s2 sk everi adjac pair word differ singl letter everi si 1 k wordlist note beginword need wordlist sk endword given two word beginword endword dictionari wordlist return shortest transform sequenc beginword endword empti list sequenc exist sequenc return list word beginword s1 s2 sk exampl 1 input beginword hit endword cog wordlist hotdotdoglotlogcog output hithotdotdogcoghithotlotlogcog explan 2 shortest transform sequenc hit hot dot dog cog hit hot lot log cog exampl 2 input beginword hit endword cog wordlist hotdotdoglotlog output explan endword cog wordlist therefor valid transform sequenc constraint 1 beginwordlength 5 endwordlength beginwordlength 1 wordlistlength 500 wordlistilength beginwordlength beginword endword wordlisti consist lowercas english letter beginword endword word wordlist uniqu sum shortest transform sequenc exceed 105 wordladderii
given root binari tree node valu 0 1 roottoleaf path repres binari number start signific bit exampl path 0 1 1 0 1 could repres 01101 binari 13 leav tree consid number repres path root leaf return sum number test case gener answer fit 32bit integ exampl 1 input root 1010101 output 22 explan 100 101 110 111 4 5 6 7 22 exampl 2 input root 0 output 0 constraint number node tree rang 1 1000 nodev 0 1 sumofroottoleafbinarynumb
donut shop bake donut batch batchsiz rule must serv donut batch serv donut next batch given integ batchsiz integ array group groupsi denot group groupsi custom visit shop custom get exactli one donut group visit shop custom group must serv serv follow group group happi get fresh donut first custom group receiv donut left previou group freeli rearrang order group return maximum possibl number happi group rearrang group exampl 1 input batchsiz 3 group 123456 output 4 explan arrang group 624513 1st 2nd 4th 6th group happi exampl 2 input batchsiz 4 group 13252216 output 4 constraint 1 batchsiz 9 1 groupslength 30 1 groupsi 109 maximumnumberofgroupsgettingfreshdonut
current design dynam array given 0index integ array num numsi number element array time addit given integ k maximum number time resiz array size size array time sizet must least numst need enough space array hold element space wast time defin sizet numst total space wast sum space wast across everi time 0 numslength return minimum total space wast resiz array k time note array size start count toward number resiz oper exampl 1 input num 1020 k 0 output 10 explan size 2020 set initi size 20 total wast space 20 10 20 20 10 exampl 2 input num 102030 k 1 output 10 explan size 202030 set initi size 20 resiz 30 time 2 total wast space 20 10 20 20 30 30 10 exampl 3 input num 1020153020 k 2 output 15 explan size 1020203030 set initi size 10 resiz 20 time 1 resiz 30 time 3 total wast space 10 10 20 20 20 15 30 30 30 20 15 constraint 1 numslength 200 1 numsi 106 0 k numslength 1 minimumtotalspacewastedwithkresizingoper
given integ array num possibl duplic randomli output index given target number assum given target number must exist array implement solut class solutionint num initi object array num int pickint target pick random index num numsi target multipl valid index equal probabl return exampl 1 input solut pick pick pick 1 2 3 3 3 3 1 3 output null 4 0 2 explan solut solut new solution1 2 3 3 3 solutionpick3 return either index 2 3 4 randomli index equal probabl return solutionpick1 return 0 sinc array nums0 equal 1 solutionpick3 return either index 2 3 4 randomli index equal probabl return constraint 1 numslength 2 104 231 numsi 231 1 target integ num 104 call made pick randompickindex
given string charact letter return percentag charact equal letter round nearest whole percent exampl 1 input foobar letter output 33 explan percentag charact equal letter 2 6 100 33 round return 33 exampl 2 input jjjj letter k output 0 explan percentag charact equal letter k 0 return 0 constraint 1 slength 100 consist lowercas english letter letter lowercas english letter percentageofletterinstr
given root binari search tree integ k return kth smallest valu 1index valu node tree exampl 1 input root 314null2 k 1 output 1 exampl 2 input root 53624nullnull1 k 3 output 3 constraint number node tree n 1 k n 104 0 nodev 104 follow bst modifi often ie insert delet oper need find kth smallest frequent would optim kthsmallestelementinabst
given integ num appli follow step exactli two time pick digit x 0 x 9 pick anoth digit 0 9 digit equal x replac occurr x decim represent num new integ lead zero also new integ 0 let b result appli oper num first second time respect return max differ b exampl 1 input num 555 output 888 explan first time pick x 5 9 store new integ second time pick x 5 1 store new integ b 999 b 111 max differ 888 exampl 2 input num 9 output 8 explan first time pick x 9 9 store new integ second time pick x 9 1 store new integ b 9 b 1 max differ 8 constraint 1 num 108 maxdifferenceyoucangetfromchanginganinteg
given array integ arr lucki integ integ frequenc array equal valu return largest lucki integ array lucki integ return 1 exampl 1 input arr 2234 output 2 explan lucki number array 2 frequency2 2 exampl 2 input arr 122333 output 3 explan 1 2 3 lucki number return largest exampl 3 input arr 22233 output 1 explan lucki number array constraint 1 arrlength 500 1 arri 500 findluckyintegerinanarray
given integ array num integ x one oper either remov leftmost rightmost element array num subtract valu x note modifi array futur oper return minimum number oper reduc x exactli 0 possibl otherwis return 1 exampl 1 input num 11423 x 5 output 2 explan optim solut remov last two element reduc x zero exampl 2 input num 56789 x 4 output 1 exampl 3 input num 3220113 x 10 output 5 explan optim solut remov last three element first two element 5 oper total reduc x zero constraint 1 numslength 105 1 numsi 104 1 x 109 minimumoperationstoreducextozero
given integ array num size n consid nonempti subarray num maximum possibl bitwis word let k maximum valu bitwis subarray num subarray bitwis equal k consid return length longest subarray bitwis array bitwis number subarray contigu sequenc element within array exampl 1 input num 123322 output 2 explan maximum possibl bitwis subarray 3 longest subarray valu 33 return 2 exampl 2 input num 1234 output 1 explan maximum possibl bitwis subarray 4 longest subarray valu 4 return 1 constraint 1 numslength 105 1 numsi 106 longestsubarraywithmaximumbitwiseand
given x n matrix return true matrix toeplitz otherwis return fals matrix toeplitz everi diagon topleft bottomright element exampl 1 input matrix 123451239512 output true explan grid diagon 9 5 5 1 1 1 2 2 2 3 3 4 diagon element answer true exampl 2 input matrix 1222 output fals explan diagon 1 2 differ element constraint matrixlength n matrixilength 1 n 20 0 matrixij 99 follow matrix store disk memori limit load one row matrix memori matrix larg load partial row memori toeplitzmatrix
given two integ tomatoslic cheeseslic ingredi differ burger follow jumbo burger 4 tomato slice 1 chees slice small burger 2 tomato slice 1 chees slice return totaljumbo totalsmal number remain tomatoslic equal 0 number remain cheeseslic equal 0 possibl make remain tomatoslic cheeseslic equal 0 return exampl 1 input tomatoslic 16 cheeseslic 7 output 16 explant make one jumbo burger 6 small burger need 41 26 16 tomato 1 6 7 chees remain ingredi exampl 2 input tomatoslic 17 cheeseslic 4 output explant way use ingredi make small jumbo burger exampl 3 input tomatoslic 4 cheeseslic 17 output explant make 1 jumbo burger 16 chees remain make 2 small burger 15 chees remain constraint 0 tomatoslic cheeseslic 107 numberofburgerswithnowasteofingredi
given integ array num move even integ begin array follow odd integ return array satisfi condit exampl 1 input num 3124 output 2431 explan output 4231 2413 4213 would also accept exampl 2 input num 0 output 0 constraint 1 numslength 5000 0 numsi 5000 sortarraybypar
valu alphanumer string defin numer represent string base 10 compris digit length string otherwis given array str alphanumer string return maximum valu string str exampl 1 input str alic3bob3400000 output 5 explan alic3 consist letter digit valu length ie 5 bob consist letter valu also length ie 3 3 consist digit valu numer equival ie 3 4 also consist digit valu 4 00000 consist digit valu 0 henc maximum valu 5 alic3 exampl 2 input str 1010010001 output 1 explan string array valu 1 henc return 1 constraint 1 strslength 100 1 strsilength 9 strsi consist lowercas english letter digit maximumvalueofastringinanarray
rectangular brick wall front n row brick ith row number brick height ie one unit differ width total width row draw vertic line top bottom cross least brick line goe edg brick brick consid cross draw line along one two vertic edg wall case line obvious cross brick given 2d array wall contain inform wall return minimum number cross brick draw vertic line exampl 1 input wall 1221312132243121311 output 2 exampl 2 input wall 111 output 3 constraint n walllength 1 n 104 1 wallilength 104 1 sumwallilength 2 104 sumwal row 1 wallij 231 1 brickwal
given integ array arr split arr number chunk ie partit individu sort chunk concaten result equal sort array return largest number chunk make sort array exampl 1 input arr 54321 output 1 explan split two chunk return requir result exampl split 5 4 3 2 1 result 4 5 1 2 3 isnt sort exampl 2 input arr 21344 output 4 explan split two chunk 2 1 3 4 4 howev split 2 1 3 4 4 highest number chunk possibl constraint 1 arrlength 2000 0 arri 108 maxchunkstomakesortedii
given 0index twodimension integ array num return largest prime number lie least one diagon num case prime present diagon return 0 note integ prime greater 1 posit integ divisor 1 integ val one diagon num exist integ numsii val numsinumslength 1 val diagram one diagon 159 anoth diagon 357 exampl 1 input num 12356791011 output 11 explan number 1 3 6 9 11 number present least one diagon sinc 11 largest prime return 11 exampl 2 input num 123517791110 output 17 explan number 1 3 9 10 17 present least one diagon 17 largest prime return 17 constraint 1 numslength 300 numslength numsilength 1 numsij 4106 primeindiagon
given string revers vowel string return vowel e u appear lower upper case exampl 1 input hello output holl exampl 2 input leetcod output leotced constraint 1 slength 3 105 consist printabl ascii charact reversevowelsofastr
given string array word return array charact show string within word includ duplic may return answer order exampl 1 input word bellalabelrol output ell exampl 2 input word coollockcook output co constraint 1 wordslength 100 1 wordsilength 100 wordsi consist lowercas english letter findcommoncharact
given integ array coin repres coin differ denomin integ amount repres total amount money return fewest number coin need make amount amount money made combin coin return 1 may assum infinit number kind coin exampl 1 input coin 125 amount 11 output 3 explan 11 5 5 1 exampl 2 input coin 2 amount 3 output 1 exampl 3 input coin 1 amount 0 output 0 constraint 1 coinslength 12 1 coinsi 231 1 0 amount 104 coinchang
given root binari tree integ distanc pair two differ leaf node binari tree said good length shortest path less equal distanc return number good leaf node pair tree exampl 1 input root 123null4 distanc 3 output 1 explan leaf node tree 3 4 length shortest path 3 good pair exampl 2 input root 1234567 distanc 3 output 2 explan good pair 45 67 shortest path 2 pair 46 good length ther shortest path 4 exampl 3 input root 7146null53nullnullnullnullnull2 distanc 3 output 1 explan good pair 25 constraint number node tree rang 1 210 1 nodev 100 1 distanc 10 numberofgoodleafnodespair
given string array word return maximum valu lengthwordi lengthwordj two word share common letter two word exist return 0 exampl 1 input word abcwbazfoobarxtfnabcdef output 16 explan two word abcw xtfn exampl 2 input word aababcdcdbcdabcd output 4 explan two word ab cd exampl 3 input word aaaaaaaaaa output 0 explan pair word constraint 2 wordslength 1000 1 wordsilength 1000 wordsi consist lowercas english letter maximumproductofwordlength
find valid combin k number sum n follow condit true number 1 9 use number use return list possibl valid combin list must contain combin twice combin may return order exampl 1 input k 3 n 7 output 124 explan 1 2 4 7 valid combin exampl 2 input k 3 n 9 output 126135234 explan 1 2 6 9 1 3 5 9 2 3 4 9 valid combin exampl 3 input k 4 n 1 output explan valid combin use 4 differ number rang 19 smallest sum get 1234 10 sinc 10 1 valid combin constraint 2 k 9 1 n 60 combinationsumiii
given string consist charact b c return number substr contain least one occurr charact b c exampl 1 input abcabc output 10 explan substr contain least one occurr charact b c abc abca abcab abcabc bca bcab bcabc cab cabc abc exampl 2 input aaacb output 3 explan substr contain least one occurr charact b c aaacb aacb acb exampl 3 input abc output 1 constraint 3 slength 5 x 104 consist b c charact numberofsubstringscontainingallthreecharact
given string contain three type charact return true valid follow rule defin valid string left parenthesi must correspond right parenthesi right parenthesi must correspond left parenthesi left parenthesi must go correspond right parenthesi could treat singl right parenthesi singl left parenthesi empti string exampl 1 input output true exampl 2 input output true exampl 3 input output true constraint 1 slength 100 si validparenthesisstr
string valid parenthes string denot vp consist charact empti string written ab concaten b b vpss written vp similarli defin nest depth depth vp follow depth 0 deptha b maxdeptha depthb b vpss depth 1 deptha vp exampl vpss nest depth 0 1 2 vpss given vp seq split two disjoint subsequ b b vpss alength blength seqlength choos b maxdeptha depthb minimum possibl valu return answer array length seqlength encod choic b answeri 0 seqi part els answeri 1 note even though multipl answer may exist may return exampl 1 input seq output 011110 exampl 2 input seq output 00011011 constraint 1 seqsiz 10000 maximumnestingdepthoftwovalidparenthesesstr
given two 0index array num cost consist n posit integ follow oper number time increas decreas element array num 1 cost one oper ith element costi return minimum total cost element array num becom equal exampl 1 input num 1352 cost 23114 output 8 explan make element equal 2 follow way increas 0th element one time cost 2 decreas 1st element one time cost 3 decreas 2nd element three time cost 1 1 1 3 total cost 2 3 3 8 shown make array equal smaller cost exampl 2 input num 22222 cost 42813 output 0 explan element alreadi equal oper need constraint n numslength costlength 1 n 105 1 numsi costi 106 test case gener way output doesnt exceed 2531 minimumcosttomakearrayequ
string paypalishir written zigzag pattern given number row like may want display pattern fix font better legibl p h n p l g r read line line pahnaplsiigyir write code take string make convers given number row string convertstr int numrow exampl 1 input paypalishir numrow 3 output pahnaplsiigyir exampl 2 input paypalishir numrow 4 output pinalsigyahrpi explan p n l g h r p exampl 3 input numrow 1 output constraint 1 slength 1000 consist english letter lowercas uppercas 1 numrow 1000 zigzagconvers
given two string sub also given 2d charact array map mappingsi oldi newi indic may perform follow oper number time replac charact oldi sub newi charact sub replac return true possibl make sub substr replac zero charact accord map otherwis return fals substr contigu nonempti sequenc charact within string exampl 1 input fool3e7bar sub leet map e3t7t8 output true explan replac first e sub 3 sub 7 sub l3e7 substr return true exampl 2 input fooleetbar sub f00l map o0 output fals explan string f00l substr replac made note replac 0 exampl 3 input fool33tbar sub leetd map e3t7t8dbpb output true explan replac first second e sub 3 sub b sub l33tb substr return true constraint 1 sublength slength 5000 0 mappingslength 1000 mappingsilength 2 oldi newi sub consist uppercas lowercas english letter digit oldi newi either uppercas lowercas english letter digit matchsubstringafterreplac
given head singli link list group node odd indic togeth follow node even indic return reorder list first node consid odd second node even note rel order insid even odd group remain input must solv problem o1 extra space complex time complex exampl 1 input head 12345 output 13524 exampl 2 input head 2135647 output 2367154 constraint number node link list rang 0 104 106 nodev 106 oddevenlinkedlist
given balanc parenthes string return score string score balanc parenthes string base follow rule score 1 ab score b b balanc parenthes string score 2 balanc parenthes string exampl 1 input output 1 exampl 2 input output 2 exampl 3 input output 2 constraint 2 slength 50 consist balanc parenthes string scoreofparenthes
defin harmoni array array differ maximum valu minimum valu exactli 1 given integ array num return length longest harmoni subsequ among possibl subsequ subsequ array sequenc deriv array delet element without chang order remain element exampl 1 input num 13225237 output 5 explan longest harmoni subsequ 32223 exampl 2 input num 1234 output 2 exampl 3 input num 1111 output 0 constraint 1 numslength 2 104 109 numsi 109 longestharmonioussubsequ
write program count number day two date two date given string format yyyymmdd shown exampl exampl 1 input date1 20190629 date2 20190630 output 1 exampl 2 input date1 20200115 date2 20191231 output 15 constraint given date valid date year 1971 2100 numberofdaysbetweentwod
given array posit integ num return maximum possibl sum ascend subarray num subarray defin contigu sequenc number array subarray numsl numsl1 numsr1 numsr ascend l r numsi numsi1 note subarray size 1 ascend exampl 1 input num 10203051050 output 65 explan 51050 ascend subarray maximum sum 65 exampl 2 input num 1020304050 output 150 explan 1020304050 ascend subarray maximum sum 150 exampl 3 input num 12171513101112 output 33 explan 101112 ascend subarray maximum sum 33 constraint 1 numslength 100 1 numsi 100 maximumascendingsubarraysum
want build obstacl cours given 0index integ array obstacl length n obstaclesi describ height ith obstacl everi index 0 n 1 inclus find length longest obstacl cours obstacl choos number obstacl 0 inclus must includ ith obstacl cours must put chosen obstacl order appear obstacl everi obstacl except first taller height obstacl immedi return array an length n ansi length longest obstacl cours index describ exampl 1 input obstacl 1232 output 1233 explan longest valid obstacl cours posit 0 1 1 length 1 1 12 12 length 2 2 123 123 length 3 3 1232 122 length 3 exampl 2 input obstacl 221 output 121 explan longest valid obstacl cours posit 0 2 2 length 1 1 22 22 length 2 2 221 1 length 1 exampl 3 input obstacl 315642 output 112322 explan longest valid obstacl cours posit 0 3 3 length 1 1 31 1 length 1 2 315 35 length 2 15 also valid 3 3156 356 length 3 156 also valid 4 31564 34 length 2 14 also valid 5 315642 12 length 2 constraint n obstacleslength 1 n 105 1 obstaclesi 107 findthelongestvalidobstaclecourseateachposit
sql schema tabl requestaccept column name type requesterid int accepterid int acceptd date requesterid accepterid primari key tabl tabl contain id user sent request id user receiv request date request accept write sql queri find peopl friend friend number test case gener one person friend queri result format follow exampl exampl 1 input requestaccept tabl requesterid accepterid acceptd 1 2 20160603 1 3 20160608 2 3 20160608 3 4 20160609 output id num 3 3 explan person id 3 friend peopl 1 2 4 three friend total number other follow real world multipl peopl could number friend could find peopl case friendrequestsiiwhohasthemostfriend
given integ array num integ k modifi array follow way choos index replac numsi numsi appli process exactli k time may choos index multipl time return largest possibl sum array modifi way exampl 1 input num 423 k 1 output 5 explan choos index 1 num becom 423 exampl 2 input num 3102 k 3 output 6 explan choos indic 1 2 2 num becom 3102 exampl 3 input num 23154 k 2 output 13 explan choos indic 1 4 num becom 23154 constraint 1 numslength 104 100 numsi 100 1 k 104 maximizesumofarrayafterkneg
given string everi two consecut vertic bar group pair word 1st 2nd make pair 3rd 4th make pair forth return number exclud pair note belong exactli one pair exampl 1 input leetcod output 2 explan consid charact underlin leetcod charact first second exclud answer also charact third fourth exclud answer 2 asterisk consid therefor return 2 exampl 2 input iamprogramm output 0 explan exampl asterisk therefor return 0 exampl 3 input youarebeauti output 5 explan consid charact underlin youarebeauti 5 asterisk consid therefor return 5 constraint 1 slength 1000 consist lowercas english letter vertic bar asterisk contain even number vertic bar countasterisk
given list num integ repres list compress runlength encod consid adjac pair element freq val nums2i nums2i1 0 pair freq element valu val concaten sublist concaten sublist left right gener decompress list return decompress list exampl 1 input num 1234 output 2444 explan first pair 12 mean freq 1 val 2 gener array 2 second pair 34 mean freq 3 val 4 gener 444 end concaten 2 444 2444 exampl 2 input num 1123 output 133 constraint 2 numslength 100 numslength 2 0 1 numsi 100 decompressrunlengthencodedlist
given two sort array nums1 nums2 size n respect return median two sort array overal run time complex olog mn exampl 1 input nums1 13 nums2 2 output 200000 explan merg array 123 median 2 exampl 2 input nums1 12 nums2 34 output 250000 explan merg array 1234 median 2 3 2 25 constraint nums1length nums2length n 0 1000 0 n 1000 1 n 2000 106 nums1i nums2i 106 medianoftwosortedarray
given 0index 2d matrix grid size x n r c repres land cell gridrc 0 water cell contain gridrc fish gridrc 0 fisher start water cell r c follow oper number time catch fish cell r c move adjac water cell return maximum number fish fisher catch choos start cell optim 0 water cell exist adjac cell cell r c one cell r c 1 r c 1 r 1 c r 1 c exist exampl 1 input grid 0210400310040320 output 7 explan fisher start cell 13 collect 3 fish move cell 23 collect 4 fish exampl 2 input grid 1000000000000001 output 1 explan fisher start cell 00 33 collect singl fish constraint gridlength n gridilength 1 n 10 0 gridij 10 maximumnumberoffishinagrid
given 0index x n binari matrix grid 0index x n differ matrix diff creat follow procedur let number one ith row onesrowi let number one jth column onescolj let number zero ith row zerosrowi let number zero jth column zeroscolj diffij onesrowi onescolj zerosrowi zeroscolj return differ matrix diff exampl 1 input grid 011101001 output 004004222 explan diff00 onesrow0 onescol0 zerosrow0 zeroscol0 2 1 1 2 0 diff01 onesrow0 onescol1 zerosrow0 zeroscol1 2 1 1 2 0 diff02 onesrow0 onescol2 zerosrow0 zeroscol2 2 3 1 0 4 diff10 onesrow1 onescol0 zerosrow1 zeroscol0 2 1 1 2 0 diff11 onesrow1 onescol1 zerosrow1 zeroscol1 2 1 1 2 0 diff12 onesrow1 onescol2 zerosrow1 zeroscol2 2 3 1 0 4 diff20 onesrow2 onescol0 zerosrow2 zeroscol0 1 1 2 2 2 diff21 onesrow2 onescol1 zerosrow2 zeroscol1 1 1 2 2 2 diff22 onesrow2 onescol2 zerosrow2 zeroscol2 1 3 2 0 2 exampl 2 input grid 111111 output 555555 explan diff00 onesrow0 onescol0 zerosrow0 zeroscol0 3 2 0 0 5 diff01 onesrow0 onescol1 zerosrow0 zeroscol1 3 2 0 0 5 diff02 onesrow0 onescol2 zerosrow0 zeroscol2 3 2 0 0 5 diff10 onesrow1 onescol0 zerosrow1 zeroscol0 3 2 0 0 5 diff11 onesrow1 onescol1 zerosrow1 zeroscol1 3 2 0 0 5 diff12 onesrow1 onescol2 zerosrow1 zeroscol2 3 2 0 0 5 constraint gridlength n gridilength 1 n 105 1 n 105 gridij either 0 1 differencebetweenonesandzerosinrowandcolumn
given two integ array preorder inord preorder preorder travers binari tree inord inord travers tree construct return binari tree exampl 1 input preorder 3920157 inord 9315207 output 3920nullnull157 exampl 2 input preorder 1 inord 1 output 1 constraint 1 preorderlength 3000 inorderlength preorderlength 3000 preorderi inorderi 3000 preorder inord consist uniqu valu valu inord also appear preorder preorder guarante preorder travers tree inord guarante inord travers tree constructbinarytreefrompreorderandinordertravers
given string contain outoford english represent digit 09 return digit ascend order exampl 1 input owoztneo output 012 exampl 2 input fviefuro output 45 constraint 1 slength 105 si one charact egfihonsrutwvxz guarante valid reconstructoriginaldigitsfromenglish
alien languag surprisingli also use english lowercas letter possibl differ order order alphabet permut lowercas letter given sequenc word written alien languag order alphabet return true given word sort lexicograph alien languag exampl 1 input word helloleetcod order hlabcdefgijkmnopqrstuvwxyz output true explan h come l languag sequenc sort exampl 2 input word wordworldrow order worldabcefghijkmnpqstuvxyz output fals explan come l languag words0 words1 henc sequenc unsort exampl 3 input word appleapp order abcdefghijklmnopqrstuvwxyz output fals explan first three charact app match second string shorter size accord lexicograph rule appl app l ∅ ∅ defin blank charact less charact info constraint 1 wordslength 100 1 wordsilength 20 orderlength 26 charact wordsi order english lowercas letter verifyinganaliendictionari
given 0index array num size n consist nonneg integ need appli n 1 oper array ith oper 0index appli follow ith element num numsi numsi 1 multipli numsi 2 set numsi 1 0 otherwis skip oper perform oper shift 0s end array exampl array 102001 shift 0s end 121000 return result array note oper appli sequenti exampl 1 input num 122110 output 142000 explan follow oper 0 nums0 nums1 equal skip oper 1 nums1 nums2 equal multipli nums1 2 chang nums2 0 array becom 140110 2 nums2 nums3 equal skip oper 3 nums3 nums4 equal multipli nums3 2 chang nums4 0 array becom 140200 4 nums4 nums5 equal multipli nums4 2 chang nums5 0 array becom 140200 shift 0s end give array 142000 exampl 2 input num 01 output 10 explan oper appli shift 0 end constraint 2 numslength 2000 0 numsi 1000 applyoperationstoanarray
given posit integ n return number integ rang 0 n whose binari represent contain consecut one exampl 1 input n 5 output 5 explan nonneg integ 5 correspond binari represent 0 0 1 1 2 10 3 11 4 100 5 101 among integ 3 disobey rule two consecut one 5 satisfi rule exampl 2 input n 1 output 2 exampl 3 input n 2 output 3 constraint 1 n 109 nonnegativeintegerswithoutconsecutiveon
given integ n return number posit integ rang 1 n least one repeat digit exampl 1 input n 20 output 1 explan posit number 20 least 1 repeat digit 11 exampl 2 input n 100 output 10 explan posit number 100 atleast 1 repeat digit 11 22 33 44 55 66 77 88 99 100 exampl 3 input n 1000 output 262 constraint 1 n 109 numberswithrepeateddigit
given 0index array string word 2d array integ queri queri queriesi li ri ask us find number string present rang li ri inclus word start end vowel return array an size querieslength ansi answer ith queri note vowel letter e u exampl 1 input word ababcbeceaa queri 021411 output 230 explan string start end vowel aba ece aa e answer queri 02 2 string aba ece queri 14 3 string ece aa e queri 11 0 return 230 exampl 2 input word aei queri 020122 output 321 explan everi string satisfi condit return 321 constraint 1 wordslength 105 1 wordsilength 40 wordsi consist lowercas english letter sumwordsilength 3 105 1 querieslength 105 0 li ri wordslength countvowelstringsinrang
given array asynchron function function return new promis promis function array accept argument return promis promis resolv promis return function resolv success resolv valu promis array resolv valu promis order function promis reject promis return function reject promis also reject reason first reject pleas solv without use builtin promiseal function exampl 1 input function new promiseresolv settimeout resolve5 200 output 200 resolv 5 explan promiseallfunctionsthenconsolelog 5 singl function resolv 200m valu 5 exampl 2 input function new promiseresolv settimeout resolve1 200 new promiseresolv reject settimeout rejecterror 100 output 100 reject error explan sinc one promis reject return promis also reject error time exampl 3 input function new promiseresolv settimeout resolve4 50 new promiseresolv settimeout resolve10 150 new promiseresolv settimeout resolve16 100 output 150 resolv 4 10 16 explan promis resolv valu return promis resolv last promis resolv constraint function array function return promis 1 functionslength 10 executeasynchronousfunctionsinparallel
alic manag compani rent floor build offic space alic decid floor special floor use relax given two integ bottom top denot alic rent floor bottom top inclus also given integ array special speciali denot special floor alic design relax return maximum number consecut floor without special floor exampl 1 input bottom 2 top 9 special 46 output 3 explan follow rang inclus consecut floor without special floor 2 3 total amount 2 floor 5 5 total amount 1 floor 7 9 total amount 3 floor therefor return maximum number 3 floor exampl 2 input bottom 6 top 8 special 768 output 0 explan everi floor rent special floor return 0 constraint 1 speciallength 105 1 bottom speciali top 109 valu special uniqu maximumconsecutivefloorswithoutspecialfloor
given integ array num follow properti numslength 2 n num contain n 1 uniqu element exactli one element num repeat n time return element repeat n time exampl 1 input num 1233 output 3 exampl 2 input num 212532 output 2 exampl 3 input num 51525354 output 5 constraint 2 n 5000 numslength 2 n 0 numsi 104 num contain n 1 uniqu element one repeat exactli n time nrepeatedelementinsize2narray
inventori differ color ball custom want order ball color custom weirdli valu color ball color ball valu number ball color current inventori exampl 6 yellow ball custom would pay 6 first yellow ball transact 5 yellow ball left next yellow ball valu 5 ie valu ball decreas sell custom given integ array inventori inventoryi repres number ball ith color initi also given integ order repres total number ball custom want sell ball order return maximum total valu attain sell order color ball answer may larg return modulo 109 7 exampl 1 input inventori 25 order 4 output 14 explan sell 1st color 1 time 2 2nd color 3 time 5 4 3 maximum total valu 2 5 4 3 14 exampl 2 input inventori 35 order 6 output 19 explan sell 1st color 2 time 3 2 2nd color 4 time 5 4 3 2 maximum total valu 3 2 5 4 3 2 19 constraint 1 inventorylength 105 1 inventoryi 109 1 order minsuminventoryi 109 selldiminishingvaluedcoloredbal
string call good two differ charact frequenc given string return minimum number charact need delet make good frequenc charact string number time appear string exampl string aab frequenc 2 frequenc b 1 exampl 1 input aab output 0 explan alreadi good exampl 2 input aaabbbcc output 2 explan delet two bs result good string aaabcc anoth way delet one b one c result good string aaabbc exampl 3 input ceabaacb output 2 explan delet cs result good string eabaab note care charact still string end ie frequenc 0 ignor constraint 1 slength 105 contain lowercas english letter minimumdeletionstomakecharacterfrequenciesuniqu
exist infinit larg twodimension grid uncolor unit cell given posit integ n indic must follow routin n minut first minut color arbitrari unit cell blue everi minut thereaft color blue everi uncolor cell touch blue cell pictori represent state grid minut 1 2 3 return number color cell end n minut exampl 1 input n 1 output 1 explan 1 minut 1 blue cell return 1 exampl 2 input n 2 output 5 explan 2 minut 4 color cell boundari 1 center return 5 constraint 1 n 105 counttotalnumberofcoloredcel
given integ array cost costi cost ith step staircas pay cost either climb one two step either start step index 0 step index 1 return minimum cost reach top floor exampl 1 input cost 101520 output 15 explan start index 1 pay 15 climb two step reach top total cost 15 exampl 2 input cost 1100111100111001 output 6 explan start index 0 pay 1 climb two step reach index 2 pay 1 climb two step reach index 4 pay 1 climb two step reach index 6 pay 1 climb one step reach index 7 pay 1 climb two step reach index 9 pay 1 climb one step reach top total cost 6 constraint 2 costlength 1000 0 costi 999 mincostclimbingstair
nqueen puzzl problem place n queen n x n chessboard two queen attack given integ n return number distinct solut nqueen puzzl exampl 1 input n 4 output 2 explan two distinct solut 4queen puzzl shown exampl 2 input n 1 output 1 constraint 1 n 9 nqueensii
sql schema pandan schema tabl user column name type userid int name varchar mail varchar sql userid primari key tabl tabl contain inform user sign websit email invalid find user valid email valid email prefix name domain prefix name string may contain letter upper lower case digit underscor period andor dash prefix name must start letter domain leetcodecom return result tabl order result format follow exampl exampl 1 input user tabl userid name mail 1 winston winstonleetcodecom 2 jonathan jonathanisgreat 3 annabel bellaleetcodecom 4 salli sallycomeleetcodecom 5 marwan quarz2020leetcodecom 6 david david69gmailcom 7 shapiro shapoleetcodecom output userid name mail 1 winston winstonleetcodecom 3 annabel bellaleetcodecom 4 salli sallycomeleetcodecom explan mail user 2 domain mail user 5 sign allow mail user 6 leetcod domain mail user 7 start period finduserswithvalidemail
given two 0index integ array nums1 nums2 return list answer size 2 answer0 list distinct integ nums1 present nums2 answer1 list distinct integ nums2 present nums1 note integ list may return order exampl 1 input nums1 123 nums2 246 output 1346 explan nums1 nums11 2 present index 0 nums2 wherea nums10 1 nums12 3 present nums2 therefor answer0 13 nums2 nums20 2 present index 1 nums1 wherea nums21 4 nums22 6 present nums2 therefor answer1 46 exampl 2 input nums1 1233 nums2 1122 output 3 explan nums1 nums12 nums13 present nums2 sinc nums12 nums13 valu includ answer0 3 everi integ nums2 present nums1 therefor answer1 constraint 1 nums1length nums2length 1000 1000 nums1i nums2i 1000 findthedifferenceoftwoarray
parenthes string nonempti string consist valid follow condit true written ab concaten b b valid parenthes string written valid parenthes string given x n matrix parenthes grid valid parenthes string path grid path satisfi follow condit path start upper left cell 0 0 path end bottomright cell 1 n 1 path ever move right result parenthes string form path valid return true exist valid parenthes string path grid otherwis return fals exampl 1 input grid output true explan diagram show two possibl path form valid parenthes string first path shown result valid parenthes string second path shown result valid parenthes string note may valid parenthes string path exampl 2 input grid output fals explan two possibl path form parenthes string sinc neither valid parenthes string return fals constraint gridlength n gridilength 1 n 100 gridij either checkifthereisavalidparenthesesstringpath
given integ array num integ k may partit num one subsequ element num appear exactli one subsequ return minimum number subsequ need differ maximum minimum valu subsequ k subsequ sequenc deriv anoth sequenc delet element without chang order remain element exampl 1 input num 36125 k 2 output 2 explan partit num two subsequ 312 65 differ maximum minimum valu first subsequ 3 1 2 differ maximum minimum valu second subsequ 6 5 1 sinc two subsequ creat return 2 shown 2 minimum number subsequ need exampl 2 input num 123 k 1 output 2 explan partit num two subsequ 12 3 differ maximum minimum valu first subsequ 2 1 1 differ maximum minimum valu second subsequ 3 3 0 sinc two subsequ creat return 2 note anoth optim solut partit num two subsequ 1 23 exampl 3 input num 2245 k 0 output 3 explan partit num three subsequ 22 4 5 differ maximum minimum valu first subsequ 2 2 0 differ maximum minimum valu second subsequ 4 4 0 differ maximum minimum valu third subsequ 5 5 0 sinc three subsequ creat return 3 shown 3 minimum number subsequ need constraint 1 numslength 105 0 numsi 105 0 k 105 partitionarraysuchthatmaximumdifferenceisk
given posit integ n return punish number n punish number n defin sum squar integ 1 n decim represent partit contigu substr sum integ valu substr equal exampl 1 input n 10 output 182 explan exactli 3 integ satisfi condit statement 1 sinc 1 1 1 9 sinc 9 9 81 81 partit 8 1 10 sinc 10 10 100 100 partit 10 0 henc punish number 10 1 81 100 182 exampl 2 input n 37 output 1478 explan exactli 4 integ satisfi condit statement 1 sinc 1 1 1 9 sinc 9 9 81 81 partit 8 1 10 sinc 10 10 100 100 partit 10 0 36 sinc 36 36 1296 1296 partit 1 29 6 henc punish number 37 1 81 100 1296 1478 constraint 1 n 1000 findthepunishmentnumberofaninteg
given n x n grid place 1 x 1 x 1 cube valu v gridij repres tower v cube place top cell j place cube decid glue directli adjac cube form sever irregular 3d shape return total surfac area result shape note bottom face shape count toward surfac area exampl 1 input grid 1234 output 34 exampl 2 input grid 111101111 output 32 exampl 3 input grid 222212222 output 46 constraint n gridlength gridilength 1 n 50 0 gridij 50 surfaceareaof3dshap
given integ array num integ k ask distribut array k subset equal size two equal element subset subset incompat differ maximum minimum element array return minimum possibl sum incompat k subset distribut array optim return 1 possibl subset group integ appear array particular order exampl 1 input num 1214 k 2 output 4 explan optim distribut subset 12 14 incompat 21 41 4 note 11 24 would result smaller sum first subset contain 2 equal element exampl 2 input num 63813122 k 4 output 6 explan optim distribut subset 12 23 68 13 incompat 21 32 86 31 6 exampl 3 input num 533633 k 3 output 1 explan imposs distribut num 3 subset two element equal subset constraint 1 k numslength 16 numslength divis k 1 numsi numslength minimumincompat
given integ array num one oper replac element num integ num consid continu follow condit fulfil element num uniqu differ maximum element minimum element num equal numslength 1 exampl num 4 2 5 3 continu num 1 2 3 5 6 continu return minimum number oper make num continu exampl 1 input num 4253 output 0 explan num alreadi continu exampl 2 input num 12356 output 1 explan one possibl solut chang last element 4 result array 12354 continu exampl 3 input num 1101001000 output 3 explan one possibl solut chang second element 2 chang third element 3 chang fourth element 4 result array 1234 continu constraint 1 numslength 105 1 numsi 109 minimumnumberofoperationstomakearraycontinu
given 0index string dictionari word dictionari break one nonoverlap substr substr present dictionari may extra charact present substr return minimum number extra charact left break optim exampl 1 input leetscod dictionari leetcodeleetcod output 1 explan break two substr leet index 0 3 code index 5 8 1 unus charact index 4 return 1 exampl 2 input sayhelloworld dictionari helloworld output 3 explan break two substr hello index 3 7 world index 8 12 charact indic 0 1 2 use substr thu consid extra charact henc return 3 constraint 1 slength 50 1 dictionarylength 50 1 dictionaryilength 50 dictionaryi consist lowercas english letter dictionari contain distinct word extracharactersinastr
given nari tree find maximum depth maximum depth number node along longest path root node farthest leaf node narytre input serial repres level order travers group children separ null valu see exampl exampl 1 input root 1null324null56 output 3 exampl 2 input root 1null2345nullnull67null8null910nullnull11null12null13nullnull14 output 5 constraint total number node rang 0 104 depth nari tree less equal 1000 maximumdepthofnarytre
given array integ num also given integ origin first number need search num follow step origin found num multipli two ie set origin 2 origin otherwis stop process repeat process new number long keep find number return final valu origin exampl 1 input num 536112 origin 3 output 24 explan 3 found num 3 multipli 2 obtain 6 6 found num 6 multipli 2 obtain 12 12 found num 12 multipli 2 obtain 24 24 found num thu 24 return exampl 2 input num 279 origin 4 output 4 explan 4 found num thu 4 return constraint 1 numslength 1000 1 numsi origin 1000 keepmultiplyingfoundvaluesbytwo
given array pair pairsi xi yi duplic xi yi let way number root tree satisfi follow condit tree consist node whose valu appear pair pair xi yi exist pair xi ancestor yi yi ancestor xi note tree binari tree two way consid differ least one node differ parent way return 0 way 0 1 way 1 2 way 1 root tree tree singl root node edg orient outgo root ancestor node node path root node exclud node root ancestor exampl 1 input pair 1223 output 1 explan exactli one valid root tree shown figur exampl 2 input pair 122313 output 2 explan multipl valid root tree three shown figur exampl 3 input pair 12232415 output 0 explan valid root tree constraint 1 pairslength 105 1 xi yi 500 element pair uniqu numberofwaystoreconstructatre
given three posit integ n index maxsum want construct array num 0index satisfi follow condit numslength n numsi posit integ 0 n absnumsi numsi1 1 0 n1 sum element num exceed maxsum numsindex maxim return numsindex construct array note absx equal x x 0 x otherwis exampl 1 input n 4 index 2 maxsum 6 output 2 explan num 1221 one array satisfi condit array satisfi condit nums2 3 2 maximum nums2 exampl 2 input n 6 index 1 maxsum 10 output 3 constraint 1 n maxsum 109 0 index n maximumvalueatagivenindexinaboundedarray
given integ array num integ k return number good subarray num good array array number differ integ array exactli k exampl 12312 3 differ integ 1 2 3 subarray contigu part array exampl 1 input num 12123 k 2 output 7 explan subarray form exactli 2 differ integ 12 21 12 23 121 212 1212 exampl 2 input num 12134 k 3 output 3 explan subarray form exactli 3 differ integ 1213 213 134 constraint 1 numslength 2 104 1 numsi k numslength subarrayswithkdifferentinteg
integ array num sort nondecreas order necessarili distinct valu pass function num rotat unknown pivot index k 0 k numslength result array numsk numsk1 numsn1 nums0 nums1 numsk1 0index exampl 0124445667 might rotat pivot index 5 becom 4566701244 given array num rotat integ target return true target num fals num must decreas overal oper step much possibl exampl 1 input num 2560012 target 0 output true exampl 2 input num 2560012 target 3 output fals constraint 1 numslength 5000 104 numsi 104 num guarante rotat pivot 104 target 104 follow problem similar search rotat sort array num may contain duplic would affect runtim complex searchinrotatedsortedarrayii
given 0index array integ num length n initi posit nums0 element numsi repres maximum length forward jump index word numsi jump numsi j 0 j numsi j n return minimum number jump reach numsn 1 test case gener reach numsn 1 exampl 1 input num 23114 output 2 explan minimum number jump reach last index 2 jump 1 step index 0 1 3 step last index exampl 2 input num 23014 output 2 constraint 1 numslength 104 0 numsi 1000 guarante reach numsn 1 jumpgameii
given array num n integ task check could becom nondecreas modifi one element defin array nondecreas numsi numsi 1 hold everi 0base 0 n 2 exampl 1 input num 423 output true explan could modifi first 4 1 get nondecreas array exampl 2 input num 421 output fals explan get nondecreas array modifi one element constraint n numslength 1 n 104 105 numsi 105 nondecreasingarray
given integ array num integ k return true possibl divid array k nonempti subset whose sum equal exampl 1 input num 4323521 k 4 output true explan possibl divid 4 subset 5 1 4 23 23 equal sum exampl 2 input num 1234 k 3 output fals constraint 1 k numslength 16 1 numsi 104 frequenc element rang 1 4 partitiontokequalsumsubset
plan train travel one year advanc day year travel given integ array day day integ 1 365 train ticket sold three differ way 1day pass sold costs0 dollar 7day pass sold costs1 dollar 30day pass sold costs2 dollar pass allow mani day consecut travel exampl get 7day pass day 2 travel 7 day 2 3 4 5 6 7 8 return minimum number dollar need travel everi day given list day exampl 1 input day 1467820 cost 2715 output 11 explan exampl one way buy pass let travel travel plan day 1 bought 1day pass costs0 2 cover day 1 day 3 bought 7day pass costs1 7 cover day 3 4 9 day 20 bought 1day pass costs0 2 cover day 20 total spent 11 cover day travel exampl 2 input day 123456789103031 cost 2715 output 17 explan exampl one way buy pass let travel travel plan day 1 bought 30day pass costs2 15 cover day 1 2 30 day 31 bought 1day pass costs0 2 cover day 31 total spent 17 cover day travel constraint 1 dayslength 365 1 daysi 365 day strictli increas order costslength 3 1 costsi 1000 minimumcostforticket
given array arr integ check exist two indic j j 0 j arrlength arri 2 arrj exampl 1 input arr 10253 output true explan 0 j 2 arri 10 2 5 2 arrj exampl 2 input arr 31711 output fals explan j satisfi condit constraint 2 arrlength 500 103 arri 103 checkifnanditsdoubleexist
given string consist charact 0 1 one oper chang 0 1 vice versa string call altern two adjac charact equal exampl string 010 altern string 0100 return minimum number oper need make altern exampl 1 input 0100 output 1 explan chang last charact 1 0101 altern exampl 2 input 10 output 0 explan alreadi altern exampl 3 input 1111 output 2 explan need two oper reach 0101 1010 constraint 1 slength 104 si either 0 1 minimumchangestomakealternatingbinarystr
given root binari tree return duplic subtre kind duplic subtre need return root node one two tree duplic structur node valu exampl 1 input root 1234null24nullnull4 output 244 exampl 2 input root 211 output 1 exampl 3 input root 2223null3nul output 233 constraint number node tree rang 1 5000 200 nodev 200 findduplicatesubtre
sql schema pandan schema tabl account column name type accountid int incom int sql accountid primari key tabl row contain inform monthli incom one bank account calcul number bank account salari categori salari categori low salari salari strictli less 20000 averag salari salari inclus rang 20000 50000 high salari salari strictli greater 50000 result tabl must contain three categori account categori return 0 return result tabl order result format follow exampl exampl 1 input account tabl accountid incom 3 108939 2 12747 8 87709 6 91796 output categori accountscount low salari 1 averag salari 0 high salari 3 explan low salari account 2 averag salari account high salari account 3 6 8 countsalarycategori
given two string b return length longest uncommon subsequ b longest uncommon subsequ exist return 1 uncommon subsequ two string string subsequ one subsequ string string obtain delet number charact exampl abc subsequ aebdc delet underlin charact aebdc get abc subsequ aebdc includ aebdc aeb empti string exampl 1 input aba b cdc output 3 explan one longest uncommon subsequ aba aba subsequ aba cdc note cdc also longest uncommon subsequ exampl 2 input aaa b bbb output 3 explan longest uncommon subsequ aaa bbb exampl 3 input aaa b aaa output 1 explan everi subsequ string also subsequ string b similarli everi subsequ string b also subsequ string constraint 1 alength blength 100 b consist lowercas english letter longestuncommonsubsequencei
given posit integ array num partit num two array nums1 nums2 element array num belong either array nums1 array nums2 array nonempti valu partit minim valu partit maxnums1 minnums2 maxnums1 denot maximum element array nums1 minnums2 denot minimum element array nums2 return integ denot valu partit exampl 1 input num 1324 output 1 explan partit array num nums1 12 nums2 34 maximum element array nums1 equal 2 minimum element array nums2 equal 3 valu partit 2 3 1 proven 1 minimum valu partit exampl 2 input num 100110 output 9 explan partit array num nums1 10 nums2 1001 maximum element array nums1 equal 10 minimum element array nums2 equal 1 valu partit 10 1 9 proven 9 minimum valu partit constraint 2 numslength 105 1 numsi 109 findthevalueofthepartit
n x n matrix valid everi row everi column contain integ 1 n inclus given n x n integ matrix matrix return true matrix valid otherwis return fals exampl 1 input matrix 123312231 output true explan case n 3 everi row column contain number 1 2 3 henc return true exampl 2 input matrix 111123123 output fals explan case n 3 first row first column contain number 2 3 henc return fals constraint n matrixlength matrixilength 1 n 100 1 matrixij n checkifeveryrowandcolumncontainsallnumb
given circular integ array num ie next element numsnumslength 1 nums0 return next greater number everi element num next greater number number x first greater number traversingord next array mean could search circularli find next greater number doesnt exist return 1 number exampl 1 input num 121 output 212 explan first 1s next greater number 2 number 2 cant find next greater number second 1s next greater number need search circularli also 2 exampl 2 input num 12343 output 23414 constraint 1 numslength 104 109 numsi 109 nextgreaterelementii
given string return length longest substr two equal charact exclud two charact substr return 1 substr contigu sequenc charact within string exampl 1 input aa output 0 explan optim substr empti substr two exampl 2 input abca output 2 explan optim substr bc exampl 3 input cbzxi output 1 explan charact appear twice constraint 1 slength 300 contain lowercas english letter largestsubstringbetweentwoequalcharact
given two array string repres two inclus event happen day event1 event2 event1 starttime1 endtime1 event2 starttime2 endtime2 event time valid 24 hour format form hhmm conflict happen two event nonempti intersect ie moment common event return true conflict two event otherwis return fals exampl 1 input event1 01150200 event2 02000300 output true explan two event intersect time 200 exampl 2 input event1 01000200 event2 01200300 output true explan two event intersect start 0120 0200 exampl 3 input event1 10001100 event2 14001500 output fals explan two event intersect constraint evnet1length event2length 2 event1ilength event2ilength 5 starttime1 endtime1 starttime2 endtime2 event time follow hhmm format determineiftwoeventshaveconflict
given array integ num posit integ k check whether possibl divid array set k consecut number return true possibl otherwis return fals exampl 1 input num 12334456 k 4 output true explan array divid 1234 3456 exampl 2 input num 32123434591011 k 3 output true explan array divid 123 234 345 91011 exampl 3 input num 1234 k 3 output fals explan array divid subarray size 3 constraint 1 k numslength 105 1 numsi 109 note question 846 httpsleetcodecomproblemshandofstraight dividearrayinsetsofkconsecutivenumb
given two integ array nums1 nums2 return maximum length subarray appear array exampl 1 input nums1 12321 nums2 32147 output 3 explan repeat subarray maximum length 321 exampl 2 input nums1 00000 nums2 00000 output 5 explan repeat subarray maximum length 00000 constraint 1 nums1length nums2length 1000 0 nums1i nums2i 100 maximumlengthofrepeatedsubarray
given two string needl haystack return index first occurr needl haystack 1 needl part haystack exampl 1 input haystack sadbutsad needl sad output 0 explan sad occur index 0 6 first occurr index 0 return 0 exampl 2 input haystack leetcod needl leeto output 1 explan leeto occur leetcod return 1 constraint 1 haystacklength needlelength 104 haystack needl consist lowercas english charact findtheindexofthefirstoccurrenceinastr
given integ array num absolut sum subarray numsl numsl1 numsr1 numsr absnumsl numsl1 numsr1 numsr return maximum absolut sum possibl empti subarray num note absx defin follow x neg integ absx x x nonneg integ absx x exampl 1 input num 13234 output 5 explan subarray 23 absolut sum abs23 abs5 5 exampl 2 input num 251432 output 8 explan subarray 514 absolut sum abs514 abs8 8 constraint 1 numslength 105 104 numsi 104 maximumabsolutesumofanysubarray
safe protect password password sequenc n digit digit rang 0 k 1 safe peculiar way check password enter sequenc check recent n digit enter time type digit exampl correct password 345 enter 012345 type 0 recent 3 digit 0 incorrect type 1 recent 3 digit 01 incorrect type 2 recent 3 digit 012 incorrect type 3 recent 3 digit 123 incorrect type 4 recent 3 digit 234 incorrect type 5 recent 3 digit 345 correct safe unlock return string minimum length unlock safe point enter exampl 1 input n 1 k 2 output 10 explan password singl digit enter digit 01 would also unlock safe exampl 2 input n 2 k 2 output 01100 explan possibl password 00 type start 4th digit 01 type start 1st digit 10 type start 3rd digit 11 type start 2nd digit thu 01100 unlock safe 10011 11001 would also unlock safe constraint 1 n 4 1 k 10 1 kn 4096 crackingthesaf
given array posit integ num posit integ target return minim length subarray whose sum greater equal target subarray return 0 instead exampl 1 input target 7 num 231243 output 2 explan subarray 43 minim length problem constraint exampl 2 input target 4 num 144 output 1 exampl 3 input target 11 num 11111111 output 0 constraint 1 target 109 1 numslength 105 1 numsi 104 follow figur solut tri code anoth solut time complex logn minimumsizesubarraysum
given head link list node link list sequenti assign nonempti group whose length form sequenc natur number 1 2 3 4 length group number node assign word 1st node assign first group 2nd 3rd node assign second group 4th 5th 6th node assign third group note length last group may less equal 1 length second last group revers node group even length return head modifi link list exampl 1 input head 5263917384 output 5623914837 explan length first group 1 odd henc revers occur length second group 2 even henc node revers length third group 3 odd henc revers occur length last group 4 even henc node revers exampl 2 input head 1106 output 1016 explan length first group 1 revers occur length second group 2 node revers length last group 1 revers occur exampl 3 input head 11065 output 10156 explan length first group 1 revers occur length second group 2 node revers length last group 2 node revers constraint number node list rang 1 105 0 nodev 105 reversenodesinevenlengthgroup
given two integ n maxvalu use describ ideal array 0index integ array arr length n consid ideal follow condit hold everi arri valu 1 maxvalu 0 n everi arri divis arri 1 0 n return number distinct ideal array length n sinc answer may larg return modulo 109 7 exampl 1 input n 2 maxvalu 5 output 10 explan follow possibl ideal array array start valu 1 5 array 11 12 13 14 15 array start valu 2 2 array 22 24 array start valu 3 1 array 33 array start valu 4 1 array 44 array start valu 5 1 array 55 total 5 2 1 1 1 10 distinct ideal array exampl 2 input n 5 maxvalu 3 output 11 explan follow possibl ideal array array start valu 1 9 array distinct valu 1 array 11111 2nd distinct valu 2 4 array 11112 11122 11222 12222 2nd distinct valu 3 4 array 11113 11133 11333 13333 array start valu 2 1 array 22222 array start valu 3 1 array 33333 total 9 1 1 11 distinct ideal array constraint 2 n 104 1 maxvalu 104 countthenumberofidealarray
given integ n consist exactli 3 digit call number n fascin follow modif result number contain digit 1 9 exactli contain 0s concaten n number 2 n 3 n return true n fascin fals otherwis concaten two number mean join togeth exampl concaten 121 371 121371 exampl 1 input n 192 output true explan concaten number n 192 2 n 384 3 n 576 result number 192384576 number contain digit 1 9 exactli exampl 2 input n 100 output fals explan concaten number n 100 2 n 200 3 n 300 result number 100200300 number satisfi condit constraint 100 n 999 checkifthenumberisfascin
maximum tree tree everi node valu greater valu subtre given root maximum binari tree integ val previou problem given tree construct list root constructa recurs follow constructa routin empti return null otherwis let ai largest element creat root node valu ai left child root constructa0 a1 ai 1 right child root constructai 1 ai 2 aalength 1 return root note given directli root node root constructa suppos b copi valu val append guarante b uniqu valu return constructb exampl 1 input root 413nullnull2 val 5 output 54null13nullnull2 explan 1423 b 14235 exampl 2 input root 524null1 val 3 output 524null1null3 explan 2154 b 21543 exampl 3 input root 523null1 val 4 output 524null13 explan 2153 b 21534 constraint number node tree rang 1 100 1 nodev 100 valu tree uniqu 1 val 100 maximumbinarytreeii
given array integ arr return true partit array three nonempti part equal sum formal partit array find index 1 j arr0 arr1 arri arri 1 arri 2 arrj 1 arrj arrj 1 arrarrlength 1 exampl 1 input arr 02166791201 output true explan 0 2 1 6 6 7 9 1 2 0 1 exampl 2 input arr 02166791201 output fals exampl 3 input arr 3365225194 output true explan 3 3 6 5 2 2 5 1 9 4 constraint 3 arrlength 5 104 104 arri 104 partitionarrayintothreepartswithequalsum
given integ n return array contain n uniqu integ add 0 exampl 1 input n 5 output 71134 explan array also accept 51123 31224 exampl 2 input n 3 output 101 exampl 3 input n 1 output 0 constraint 1 n 1000 findnuniqueintegerssumuptozero
given array charact char compress use follow algorithm begin empti string group consecut repeat charact char group length 1 append charact otherwis append charact follow group length compress string return separ instead store input charact array char note group length 10 longer split multipl charact char done modifi input array return new length array must write algorithm use constant extra space exampl 1 input char aabbccc output return 6 first 6 charact input array a2b2c3 explan group aa bb ccc compress a2b2c3 exampl 2 input char output return 1 first charact input array explan group remain uncompress sinc singl charact exampl 3 input char abbbbbbbbbbbb output return 4 first 4 charact input array ab12 explan group bbbbbbbbbbbb compress ab12 constraint 1 charslength 2000 charsi lowercas english letter uppercas english letter digit symbol stringcompress
given string formula repres chemic formula return count atom atom element alway start uppercas charact zero lowercas letter repres name one digit repres element count may follow count greater 1 count 1 digit follow exampl h2o h2o2 possibl h1o2 imposs two formula concaten togeth produc anoth formula exampl h2o2he3mg4 also formula formula place parenthes count option ad also formula exampl h2o2 h2o23 formula return count element string follow form first name sort order follow count count 1 follow second name sort order follow count count 1 test case gener valu output fit 32bit integ exampl 1 input formula h2o output h2o explan count element h 2 1 exampl 2 input formula mgoh2 output h2mgo2 explan count element h 2 mg 1 2 exampl 3 input formula k4onso322 output k4n2o14s4 explan count element k 4 n 2 14 4 constraint 1 formulalength 1000 formula consist english letter digit formula alway valid numberofatom
given integ n base 10 base k return sum digit n convert n base 10 base k convert digit interpret base 10 number sum return base 10 exampl 1 input n 34 k 6 output 9 explan 34 base 10 express base 6 54 5 4 9 exampl 2 input n 10 k 10 output 1 explan n alreadi base 10 1 0 1 constraint 1 n 100 2 k 10 sumofdigitsinbasek
given array string arr string form concaten subsequ arr uniqu charact return maximum possibl length subsequ array deriv anoth array delet element without chang order remain element exampl 1 input arr uniqu output 4 explan valid concaten un iq ue uniq un iq iqu iq ue maximum length 4 exampl 2 input arr charact output 6 explan possibl longest valid concaten chaer cha er acter act er exampl 3 input arr abcdefghijklmnopqrstuvwxyz output 26 explan string arr 26 charact constraint 1 arrlength 16 1 arrilength 26 arri contain lowercas english letter maximumlengthofaconcatenatedstringwithuniquecharact
given array num consist n posit integ comput sum nonempti continu subarray array sort nondecreas order creat new array n n 1 2 number return sum number index left index right index 1 inclus new array sinc answer huge number return modulo 109 7 exampl 1 input num 1234 n 4 left 1 right 5 output 13 explan subarray sum 1 3 6 10 2 5 9 3 7 4 sort nondecreas order new array 1 2 3 3 4 5 6 7 9 10 sum number index le 1 ri 5 1 2 3 3 4 13 exampl 2 input num 1234 n 4 left 3 right 4 output 6 explan given array exampl 1 new array 1 2 3 3 4 5 6 7 9 10 sum number index le 3 ri 4 3 3 6 exampl 3 input num 1234 n 4 left 1 right 10 output 50 constraint n numslength 1 numslength 1000 1 numsi 100 1 left right n n 1 2 rangesumofsortedsubarraysum
given posit integ num may swap two digit num pariti ie odd digit even digit return largest possibl valu num number swap exampl 1 input num 1234 output 3412 explan swap digit 3 digit 1 result number 3214 swap digit 2 digit 4 result number 3412 note may sequenc swap shown 3412 largest possibl number also note may swap digit 4 digit 1 sinc differ pariti exampl 2 input num 65875 output 87655 explan swap digit 8 digit 6 result number 85675 swap first digit 5 digit 7 result number 87655 note may sequenc swap shown 87655 largest possibl number constraint 1 num 109 largestnumberafterdigitswapsbypar
sql schema tabl user column name type id int name varchar id primari key tabl name name user tabl ride column name type id int userid int distanc int id primari key tabl userid id user travel distanc distanc write sql queri report distanc travel user return result tabl order travelleddist descend order two user travel distanc order name ascend order queri result format follow exampl exampl 1 input user tabl id name 1 alic 2 bob 3 alex 4 donald 7 lee 13 jonathan 19 elvi ride tabl id userid distanc 1 1 120 2 2 317 3 3 222 4 7 100 5 13 312 6 19 50 7 7 120 8 19 400 9 7 230 output name travelleddist elvi 450 lee 450 bob 317 jonathan 312 alex 222 alic 120 donald 0 explan elvi lee travel 450 mile elvi top travel name alphabet smaller lee bob jonathan alex alic one ride order total distanc ride donald ride distanc travel 0 toptravel
given zerobas permut num 0index build array an length ansi numsnumsi 0 numslength return zerobas permut num array distinct integ 0 numslength 1 inclus exampl 1 input num 021534 output 012453 explan array an built follow an numsnums0 numsnums1 numsnums2 numsnums3 numsnums4 numsnums5 nums0 nums2 nums1 nums5 nums3 nums4 012453 exampl 2 input num 501234 output 450123 explan array an built follow an numsnums0 numsnums1 numsnums2 numsnums3 numsnums4 numsnums5 nums5 nums0 nums1 nums2 nums3 nums4 450123 constraint 1 numslength 1000 0 numsi numslength element num distinct followup solv without use extra space ie o1 memori buildarrayfrompermut
given string even length consist digit 0 9 two integ b appli either follow two oper number time order add odd indic 0index digit post 9 cycl back 0 exampl 3456 5 becom 3951 rotat right b posit exampl 3456 b 1 becom 6345 return lexicograph smallest string obtain appli oper number time string lexicograph smaller string b length first posit b differ string letter appear earlier alphabet correspond letter b exampl 0158 lexicograph smaller 0190 first posit differ third letter 5 come 9 exampl 1 input 5525 9 b 2 output 2050 explan appli follow oper start 5525 rotat 2555 add 2454 add 2353 rotat 5323 add 5222 add 5121 rotat 2151 add 2050 way obtain string lexicograph smaller 2050 exampl 2 input 74 5 b 1 output 24 explan appli follow oper start 74 rotat 47 add 42 rotat 24 way obtain string lexicograph smaller 24 exampl 3 input 0011 4 b 2 output 0011 explan sequenc oper give us lexicograph smaller string 0011 constraint 2 slength 100 slength even consist digit 0 9 1 9 1 b slength 1 lexicographicallysmalleststringafterapplyingoper
given two string length n respect return minimum window substr everi charact includ duplic includ window substr return empti string testcas gener answer uniqu exampl 1 input adobecodebanc abc output banc explan minimum window substr banc includ b c string exampl 2 input output explan entir string minimum window exampl 3 input aa output explan must includ window sinc largest window one return empti string constraint slength n tlength 1 n 105 consist uppercas lowercas english letter follow could find algorithm run om n time minimumwindowsubstr
given integ n return nth digit infinit integ sequenc 1 2 3 4 5 6 7 8 9 10 11 exampl 1 input n 3 output 3 exampl 2 input n 11 output 0 explan 11th digit sequenc 1 2 3 4 5 6 7 8 9 10 11 0 part number 10 constraint 1 n 231 1 nthdigit
given integ n return decim valu binari string form concaten binari represent 1 n order modulo 109 7 exampl 1 input n 1 output 1 explan 1 binari correspond decim valu 1 exampl 2 input n 3 output 27 explan binari 1 2 3 correspond 1 10 11 concaten 11011 correspond decim valu 27 exampl 3 input n 12 output 505379714 explan concaten result 1101110010111011110001001101010111100 decim valu 118505380540 modulo 109 7 result 505379714 constraint 1 n 105 concatenationofconsecutivebinarynumb
given integ n array uniqu integ blacklist design algorithm pick random integ rang 0 n 1 blacklist integ mention rang blacklist equal like return optim algorithm minim number call builtin random function languag implement solut class solutionint n int blacklist initi object integ n blacklist integ blacklist int pick return random integ rang 0 n 1 blacklist exampl 1 input solut pick pick pick pick pick pick pick 7 2 3 5 output null 0 4 1 6 1 0 4 explan solut solut new solution7 2 3 5 solutionpick return 0 integ 0146 ok note everi call pick 0 1 4 6 must equal like return ie probabl 14 solutionpick return 4 solutionpick return 1 solutionpick return 6 solutionpick return 1 solutionpick return 0 solutionpick return 4 constraint 1 n 109 0 blacklistlength min105 n 1 0 blacklisti n valu blacklist uniqu 2 104 call made pick randompickwithblacklist
given string english letter return greatest english letter occur lowercas uppercas letter return letter uppercas letter exist return empti string english letter b greater anoth letter b appear english alphabet exampl 1 input leetcod output e explan letter e letter appear lower upper case exampl 2 input arrazfif output r explan letter r greatest letter appear lower upper case note f also appear lower upper case r greater f exampl 3 input abcdefghijk output explan letter appear lower upper case constraint 1 slength 1000 consist lowercas uppercas english letter greatestenglishletterinupperandlowercas
parenthes string valid empti string written ab concaten b b valid string written valid string given parenthes string one move insert parenthesi posit string exampl insert open parenthesi close parenthesi return minimum number move requir make valid exampl 1 input output 1 exampl 2 input output 3 constraint 1 slength 1000 si either minimumaddtomakeparenthesesvalid
given root binari tree level root 1 level children 2 return smallest level x sum valu node level x maxim exampl 1 input root 17078nullnul output 2 explan level 1 sum 1 level 2 sum 7 0 7 level 3 sum 7 8 1 return level maximum sum level 2 exampl 2 input root 989null102509869389388nullnullnull32127 output 2 constraint number node tree rang 1 104 105 nodev 105 maximumlevelsumofabinarytre
enhanc function callpolyfil method method accept object obj first paramet number addit argument obj becom context function addit argument pass function callpolyfil method belong exampl function function taxpric taxrat const totalcost price 1 taxrat consolelogth cost thisitem totalcost call function like tax10 01 log cost undefin 11 context defin howev call function like taxcallpolyfillitem salad 10 01 log cost salad 11 context appropri set function log appropri output pleas solv without use builtin functioncal method exampl 1 input fn function addb return thisa b arg 5 7 output 12 explan fncallpolyfilla 5 7 12 callpolyfil set context 5 7 pass argument exampl 2 input fn function taxpric taxrat return cost thisitem price taxrat arg item burger 10 11 output cost burger 11 explan callpolyfil set context item burger 10 11 pass addit argument constraint typeof args0 object args0 null 1 argslength 100 2 jsonstringifyargs0length 105 callfunctionwithcustomcontext
given integ array arr return true three consecut odd number array otherwis return fals exampl 1 input arr 2641 output fals explan three consecut odd exampl 2 input arr 123434572312 output true explan 5723 three consecut odd constraint 1 arrlength 1000 1 arri 1000 threeconsecutiveodd
given undirect graph origin graph n node label 0 n 1 decid subdivid edg graph chain node number new node vari edg graph given 2d array edg edgesi ui vi cnti indic edg node ui vi origin graph cnti total number new node subdivid edg note cnti 0 mean subdivid edg subdivid edg ui vi replac cnti 1 new edg cnti new node new node x1 x2 xcnti new edg ui x1 x1 x2 x2 x3 xcnti1 xcnti xcnti vi new graph want know mani node reachabl node 0 node reachabl distanc maxmov less given origin graph maxmov return number node reachabl node 0 new graph exampl 1 input edg 0110021122 maxmov 6 n 3 output 13 explan edg subdivis shown imag node reachabl highlight yellow exampl 2 input edg 014126028131 maxmov 10 n 4 output 23 exampl 3 input edg 124145131234345 maxmov 17 n 5 output 1 explan node 0 disconnect rest graph node 0 reachabl constraint 0 edgeslength minn n 1 2 104 edgesilength 3 0 ui vi n multipl edg graph 0 cnti 104 0 maxmov 109 1 n 3000 reachablenodesinsubdividedgraph
school cafeteria offer circular squar sandwich lunch break refer number 0 1 respect student stand queue student either prefer squar circular sandwich number sandwich cafeteria equal number student sandwich place stack step student front queue prefer sandwich top stack take leav queue otherwis leav go queue end continu none queue student want take top sandwich thu unabl eat given two integ array student sandwich sandwichesi type ith sandwich stack 0 top stack studentsj prefer jth student initi queue j 0 front queue return number student unabl eat exampl 1 input student 1100 sandwich 0101 output 0 explan front student leav top sandwich return end line make student 1001 front student leav top sandwich return end line make student 0011 front student take top sandwich leav line make student 011 sandwich 101 front student leav top sandwich return end line make student 110 front student take top sandwich leav line make student 10 sandwich 01 front student leav top sandwich return end line make student 01 front student take top sandwich leav line make student 1 sandwich 1 front student take top sandwich leav line make student sandwich henc student abl eat exampl 2 input student 111001 sandwich 100011 output 3 constraint 1 studentslength sandwicheslength 100 studentslength sandwicheslength sandwichesi 0 1 studentsi 0 1 numberofstudentsunabletoeatlunch
given integ array valu valuesi repres valu ith sightse spot two sightse spot j distanc j score pair j sightse spot valuesi valuesj j sum valu sightse spot minu distanc return maximum score pair sightse spot exampl 1 input valu 81526 output 11 explan 0 j 2 valuesi valuesj j 8 5 0 2 11 exampl 2 input valu 12 output 2 constraint 2 valueslength 5 104 1 valuesi 1000 bestsightseeingpair
given array arr 4 digit find latest 24hour time made use digit exactli 24hour time format hhmm hh 00 23 mm 00 59 earliest 24hour time 0000 latest 2359 return latest 24hour time hhmm format valid time made return empti string exampl 1 input arr 1234 output 2341 explan valid 24hour time 1234 1243 1324 1342 1423 1432 2134 2143 2314 2341 time 2341 latest exampl 2 input arr 5555 output explan valid 24hour time 5555 valid constraint arrlength 4 0 arri 9 largesttimeforgivendigit
given 0index array string word string consist lowercas english letter letter occur string word two string s1 s2 said connect set letter s2 obtain set letter s1 one follow oper ad exactli one letter set letter s1 delet exactli one letter set letter s1 replac exactli one letter set letter s1 letter includ array word divid one nonintersect group string belong group one follow true connect least one string group string present group note string word group manner string belong group connect string present group prove arrang alway uniqu return array an size 2 ans0 maximum number group word divid ans1 size largest group exampl 1 input word ababcd output 23 explan words0 use obtain words1 replac b words2 ad b words0 connect words1 words2 words1 use obtain words0 replac b words2 ad words1 connect words0 words2 words2 use obtain words0 delet b words1 delet words2 connect words0 words1 words3 connect string word thu word divid 2 group abab cde size largest group 3 exampl 2 input word aababc output 13 explan words0 connect words1 words1 connect words0 words2 words2 connect words1 sinc string connect group togeth thu size largest group 3 constraint 1 wordslength 2 104 1 wordsilength 26 wordsi consist lowercas english letter letter occur wordsi groupsofstr
given 0index integ array arr x n integ matrix mat arr mat contain integ rang 1 n go index arr start index 0 paint cell mat contain integ arri return smallest index either row column complet paint mat exampl 1 input arr 1342 mat 1423 output 2 explan move shown order first row second column matrix becom fulli paint arr2 exampl 2 input arr 287413569 mat 325146879 output 3 explan second column becom fulli paint arr3 constraint matlength n matilength arrlength n 1 n 105 1 n 105 1 arri matrc n integ arr uniqu integ mat uniqu firstcompletelypaintedroworcolumn
given posit integ num return true num perfect squar fals otherwis perfect squar integ squar integ word product integ must use builtin librari function sqrt exampl 1 input num 16 output true explan return true 4 4 16 4 integ exampl 2 input num 14 output fals explan return fals 3742 3742 14 3742 integ constraint 1 num 231 1 validperfectsquar
everi valid email consist local name domain name separ sign besid lowercas letter email may contain one exampl aliceleetcodecom alic local name leetcodecom domain name add period charact local name part email address mail sent forward address without dot local name note rule appli domain name exampl alicezleetcodecom alicezleetcodecom forward email address add plu local name everyth first plu sign ignor allow certain email filter note rule appli domain name exampl mynameemailcom forward myemailcom possibl use rule time given array string email send one email emailsi return number differ address actual receiv mail exampl 1 input email testemailalexleetcodecomtestemailbobcathyleetcodecomtestemaildavidleetcodecom output 2 explan testemailleetcodecom testemailleetcodecom actual receiv mail exampl 2 input email aleetcodecombleetcodecomcleetcodecom output 3 constraint 1 emailslength 100 1 emailsilength 100 emailsi consist lowercas english letter emailsi contain exactli one charact local domain name nonempti local name start charact domain name end com suffix uniqueemailaddress
triplet array three integ given 2d integ array triplet tripletsi ai bi ci describ ith triplet also given integ array target x z describ triplet want obtain obtain target may appli follow oper triplet number time possibl zero choos two indic 0index j j updat tripletsj becom maxai aj maxbi bj maxci cj exampl tripletsi 2 5 3 tripletsj 1 7 5 tripletsj updat max2 1 max5 7 max3 5 2 7 5 return true possibl obtain target triplet x z element triplet fals otherwis exampl 1 input triplet 253184175 target 275 output true explan perform follow oper choos first last triplet 253184175 updat last triplet max21 max57 max35 275 triplet 253184275 target triplet 275 element triplet exampl 2 input triplet 345456 target 325 output fals explan imposs 325 element 2 triplet exampl 3 input triplet 253234125523 target 555 output true explan perform follow oper choos first third triplet 253234125523 updat third triplet max21 max52 max35 255 triplet 253234255523 choos third fourth triplet 253234255523 updat fourth triplet max25 max52 max53 555 triplet 253234255555 target triplet 555 element triplet constraint 1 tripletslength 105 tripletsilength targetlength 3 1 ai bi ci x z 1000 mergetripletstoformtargettriplet
given integ array arr return length maximum size turbul subarray arr subarray turbul comparison sign flip adjac pair element subarray formal subarray arri arri 1 arrj arr said turbul k j arrk arrk 1 k odd arrk arrk 1 k even k j arrk arrk 1 k even arrk arrk 1 k odd exampl 1 input arr 9421078819 output 5 explan arr1 arr2 arr3 arr4 arr5 exampl 2 input arr 481216 output 2 exampl 3 input arr 100 output 1 constraint 1 arrlength 4 104 0 arri 109 longestturbulentsubarray
hotel n room room repres 2d integ array room roomsi roomidi sizei denot room room number roomidi size equal sizei roomidi guarante uniqu also given k queri 2d array queri queriesj preferredj minsizej answer jth queri room number id room room size least minsizej absid preferredj minim absx absolut valu x tie absolut differ use room smallest id room answer 1 return array answer length k answerj contain answer jth queri exampl 1 input room 221232 queri 313352 output 313 explan answer queri follow queri 31 room number 3 closest abs3 3 0 size 2 least 1 answer 3 queri 33 room size least 3 answer 1 queri 52 room number 3 closest abs3 5 2 size 2 least 2 answer 3 exampl 2 input room 1423354152 queri 232425 output 213 explan answer queri follow queri 23 room number 2 closest abs2 2 0 size 3 least 3 answer 2 queri 24 room number 1 3 size least 4 answer 1 sinc smaller queri 25 room number 3 room size least 5 answer 3 constraint n roomslength 1 n 105 k querieslength 1 k 104 1 roomidi preferredj 107 1 sizei minsizej 107 closestroom
goal parser interpret string command command consist alphabet g andor al order goal parser interpret g string g string al string al interpret string concaten origin order given string command return goal parser interpret command exampl 1 input command gal output goal explan goal parser interpret command follow g g al al final concaten result goal exampl 2 input command gal output gooooal exampl 3 input command algalg output algaloog constraint 1 commandlength 100 command consist g andor al order goalparserinterpret
undirect connect tree n node label 0 n 1 n 1 edg given 0index integ array num length n numsi repres valu ith node also given 2d integ array edg length n 1 edgesi ai bi indic edg node ai bi tree remov two distinct edg tree form three connect compon pair remov edg follow step defin get xor valu node three compon respect differ largest xor valu smallest xor valu score pair exampl say three compon node valu 457 19 333 three xor valu 4 5 7 6 1 9 8 3 3 3 3 largest xor valu 8 smallest xor valu 3 score 8 3 5 return minimum score possibl pair edg remov given tree exampl 1 input num 155411 edg 01121334 output 9 explan diagram show way make pair remov 1st compon node 134 valu 5411 xor valu 5 4 11 10 2nd compon node 0 valu 1 xor valu 1 1 3rd compon node 2 valu 5 xor valu 5 5 score differ largest smallest xor valu 10 1 9 shown pair remov obtain smaller score 9 exampl 2 input num 552442 edg 0112524313 output 0 explan diagram show way make pair remov 1st compon node 34 valu 44 xor valu 4 4 0 2nd compon node 10 valu 55 xor valu 5 5 0 3rd compon node 25 valu 22 xor valu 2 2 0 score differ largest smallest xor valu 0 0 0 obtain smaller score 0 constraint n numslength 3 n 1000 1 numsi 108 edgeslength n 1 edgesilength 2 0 ai bi n ai bi edg repres valid tree minimumscoreafterremovalsonatre
given array integ arr integ k find least number uniqu integ remov exactli k element exampl 1 input arr 554 k 1 output 1 explan remov singl 4 5 left exampl 2 input arr 4311332 k 3 output 2 explan remov 4 2 either one two 1s three 3s 1 3 left constraint 1 arrlength 105 1 arri 109 0 k arrlength leastnumberofuniqueintegersafterkremov
given two binari string b return sum binari string exampl 1 input 11 b 1 output 100 exampl 2 input 1010 b 1011 output 10101 constraint 1 alength blength 104 b consist 0 1 charact string contain lead zero except zero addbinari
given 0index array word contain n string let defin join oper joinx two string x concaten xy howev last charact x equal first charact one delet exampl joinab ba aba joinab cde abcd perform n 1 join oper let str0 words0 start 1 n 1 ith oper one follow make stri joinstri 1 wordsi make stri joinwordsi stri 1 task minim length strn 1 return integ denot minimum possibl length strn 1 exampl 1 input word aaabbc output 4 explan exampl perform join oper follow order minim length str2 str0 aa str1 joinstr0 ab aab str2 joinstr1 bc aabc shown minimum possibl length str2 4 exampl 2 input word abb output 2 explan exampl str0 ab two way get str1 joinstr0 b ab joinb str0 bab first string ab minimum length henc answer 2 exampl 3 input word aaacaba output 6 explan exampl perform join oper follow order minim length str2 str0 aaa str1 joinstr0 c aaac str2 joinaba str1 abaaac shown minimum possibl length str2 6 constraint 1 wordslength 1000 1 wordsilength 50 charact wordsi english lowercas letter decrementalstringconcaten
given string return longest palindrom substr exampl 1 input babad output bab explan aba also valid answer exampl 2 input cbbd output bb constraint 1 slength 1000 consist digit english letter longestpalindromicsubstr
given two jug capac jug1capac jug2capac liter infinit amount water suppli avail determin whether possibl measur exactli targetcapac liter use two jug targetcapac liter water measur must targetcapac liter water contain within one bucket end oper allow fill jug water empti jug pour water one jug anoth till jug complet full first jug empti exampl 1 input jug1capac 3 jug2capac 5 targetcapac 4 output true explan famou die hard exampl exampl 2 input jug1capac 2 jug2capac 6 targetcapac 5 output fals exampl 3 input jug1capac 1 jug2capac 2 targetcapac 3 output true constraint 1 jug1capac jug2capac targetcapac 106 waterandjugproblem
given string contain bracket pair pair contain nonempti key exampl string nameisageyearsold two bracket pair contain key name age know valu wide rang key repres 2d string array knowledg knowledgei keyi valuei indic key keyi valu valuei task evalu bracket pair evalu bracket pair contain key keyi replac keyi bracket pair key correspond valuei know valu key replac keyi bracket pair question mark without quotat mark key appear knowledg nest bracket return result string evalu bracket pair exampl 1 input nameisageyearsold knowledg namebobagetwo output bobistwoyearsold explan key name valu bob replac name bob key age valu two replac age two exampl 2 input hinam knowledg ab output hi explan know valu key name replac name exampl 3 input aaaaaa knowledg aye output yesyesyesaaa explan key appear multipl time key valu ye replac occurr ye notic bracket pair evalu constraint 1 slength 105 0 knowledgelength 105 knowledgeilength 2 1 keyilength valueilength 10 consist lowercas english letter round bracket everi open bracket correspond close bracket key bracket pair nonempti nest bracket pair keyi valuei consist lowercas english letter keyi knowledg uniqu evaluatethebracketpairsofastr
given binari array num return maximum length contigu subarray equal number 0 1 exampl 1 input num 01 output 2 explan 0 1 longest contigu subarray equal number 0 1 exampl 2 input num 010 output 2 explan 0 1 1 0 longest contigu subarray equal number 0 1 constraint 1 numslength 105 numsi either 0 1 contiguousarray
given x n board charact list string word return word board word must construct letter sequenti adjac cell adjac cell horizont vertic neighbor letter cell may use word exampl 1 input board oaanetaeihkriflv word oathpeaeatrain output eatoath exampl 2 input board abcd word abcb output constraint boardlength n boardilength 1 n 12 boardij lowercas english letter 1 wordslength 3 104 1 wordsilength 10 wordsi consist lowercas english letter string word uniqu wordsearchii
given integ array score size n scorei score ith athlet competit score guarante uniqu athlet place base score 1st place athlet highest score 2nd place athlet 2nd highest score placement athlet determin rank 1st place athlet rank gold medal 2nd place athlet rank silver medal 3rd place athlet rank bronz medal 4th place nth place athlet rank placement number ie xth place athlet rank x return array answer size n answeri rank ith athlet exampl 1 input score 54321 output gold medalsilv medalbronz medal45 explan placement 1st 2nd 3rd 4th 5th exampl 2 input score 103894 output gold medal5bronz medalsilv medal4 explan placement 1st 5th 3rd 2nd 4th constraint n scorelength 1 n 104 0 scorei 106 valu score uniqu relativerank
sql schema tabl activ column name type playerid int deviceid int eventd date gamesplay int playerid eventd primari key tabl tabl show activ player game row record player log play number game possibl 0 log someday use devic write sql queri report fraction player log day day first log round 2 decim place word need count number player log least two consecut day start first login date divid number total number player queri result format follow exampl exampl 1 input activ tabl playerid deviceid eventd gamesplay 1 2 20160301 5 1 2 20160302 6 2 3 20170625 1 3 1 20160302 0 3 4 20180703 5 output fraction 033 explan player id 1 log back first day log answer 13 033 gameplayanalysisiv
given 0index x n binari matrix land 0 repres hectar forest land 1 repres hectar farmland keep land organ design rectangular area hectar consist entir farmland rectangular area call group two group adjac mean farmland one group fourdirect adjac anoth farmland differ group land repres coordin system top left corner land 0 0 bottom right corner land m1 n1 find coordin top left bottom right corner group farmland group farmland top left corner r1 c1 bottom right corner r2 c2 repres 4length array r1 c1 r2 c2 return 2d array contain 4length array describ group farmland land group farmland return empti array may return answer order exampl 1 input land 100011011 output 00001122 explan first group top left corner land00 bottom right corner land00 second group top left corner land11 bottom right corner land22 exampl 2 input land 1111 output 0011 explan first group top left corner land00 bottom right corner land11 exampl 3 input land 0 output explan group farmland constraint landlength n landilength 1 n 300 land consist 0s 1s group farmland rectangular shape findallgroupsoffarmland
given two integ x repres current locat cartesian grid x also given array point pointsi ai bi repres point exist ai bi point valid share xcoordin ycoordin locat return index 0index valid point smallest manhattan distanc current locat multipl return valid point smallest index valid point return 1 manhattan distanc two point x1 y1 x2 y2 absx1 x2 absy1 y2 exampl 1 input x 3 4 point 1231242344 output 2 explan point 31 24 44 valid valid point 24 44 smallest manhattan distanc current locat distanc 1 24 smallest index return 2 exampl 2 input x 3 4 point 34 output 0 explan answer allow locat current locat exampl 3 input x 3 4 point 23 output 1 explan valid point constraint 1 pointslength 104 pointsilength 2 1 x ai bi 104 findnearestpointthathasthesamexorycoordin
given integ array num reduc function fn initi valu init return reduc array reduc array creat appli follow oper val fninit nums0 val fnval nums1 val fnval nums2 everi element array process final valu val return length array 0 return init pleas solv without use builtin arrayreduc method exampl 1 input num 1234 fn function sumaccum curr return accum curr init 0 output 10 explan initi valu init0 0 nums0 1 1 nums1 3 3 nums2 6 6 nums3 10 final answer 10 exampl 2 input num 1234 fn function sumaccum curr return accum curr curr init 100 output 130 explan initi valu init100 100 nums02 101 101 nums12 105 105 nums22 114 114 nums32 130 final answer 130 exampl 3 input num fn function sumaccum curr return 0 init 25 output 25 explan empti array answer alway init constraint 0 numslength 1000 0 numsi 1000 0 init 1000 arrayreducetransform
given list word list singl letter might repeat score everi charact return maximum score valid set word form use given letter wordsi use two time necessari use charact letter letter use score letter b c z given score0 score1 score25 respect exampl 1 input word dogcatdadgood letter aacdddgoo score 10950030000000200000000000 output 23 explan score a1 c9 d5 g3 o2 given letter form word dad 515 good 3225 score 23 word dad dog get score 21 exampl 2 input word xxxzaxbxcx letter zabcxxx score 444000000000000000000005010 output 27 explan score a4 b4 c4 x5 z10 given letter form word ax 45 bx 45 cx 45 score 27 word xxxz get score 25 exampl 3 input word leetcod letter letcod score 00111000000100100001000000 output 0 explan letter e use constraint 1 wordslength 14 1 wordsilength 15 1 letterslength 100 lettersilength 1 scorelength 26 0 scorei 10 wordsi lettersi contain lower case english letter maximumscorewordsformedbylett
given n order order consist pickup deliveri servic count valid pickupdeliveri possibl sequenc deliveryi alway pickupi sinc answer may larg return modulo 109 7 exampl 1 input n 1 output 1 explan uniqu order p1 d1 deliveri 1 alway pickup 1 exampl 2 input n 2 output 6 explan possibl order p1p2d1d2 p1p2d2d1 p1d1p2d2 p2p1d1d2 p2p1d2d1 p2d2p1d1 invalid order p1d2p2d1 pickup 2 deliveri 2 exampl 3 input n 3 output 90 constraint 1 n 500 countallvalidpickupanddeliveryopt
given integ array num integ k one oper pick two number array whose sum equal k remov array return maximum number oper perform array exampl 1 input num 1234 k 5 output 2 explan start num 1234 remov number 1 4 num 23 remov number 2 3 num pair sum 5 henc total 2 oper exampl 2 input num 31343 k 6 output 1 explan start num 31343 remov first two 3s num 143 pair sum 6 henc total 1 oper constraint 1 numslength 105 1 numsi 109 1 k 109 maxnumberofksumpair
given two integ n repres dimens matrix also given head link list integ gener x n matrix contain integ link list present spiral order clockwis start topleft matrix remain empti space fill 1 return gener matrix exampl 1 input 3 n 5 head 3026817942550 output 302685011152497 explan diagram show valu print matrix note remain space matrix fill 1 exampl 2 input 1 n 4 head 012 output 0121 explan diagram show valu print left right matrix last space matrix set 1 constraint 1 n 105 1 n 105 number node list rang 1 n 0 nodev 1000 spiralmatrixiv
ask cut tree forest golf event forest repres x n matrix matrix 0 mean cell walk 1 repres empti cell walk number greater 1 repres tree cell walk number tree height one step walk four direct north east south west stand cell tree choos whether cut must cut tree order shortest tallest cut tree valu cell becom 1 empti cell start point 0 0 return minimum step need walk cut tree cut tree return 1 note input gener two tree height least one tree need cut exampl 1 input forest 123004765 output 6 explan follow path allow cut tree shortest tallest 6 step exampl 2 input forest 123000765 output 1 explan tree bottom row access middl row block exampl 3 input forest 234005876 output 6 explan follow path exampl 1 cut tree note cut first tree 0 0 make step constraint forestlength n forestilength 1 n 50 0 forestij 109 height tree distinct cutofftreesforgolfev
undirect graph n node defin edgelist edgelisti ui vi disi denot edg node ui vi distanc disi note may multipl edg two node given array queri queriesj pj qj limitj task determin queriesj whether path pj qj edg path distanc strictli less limitj return boolean array answer answerlength querieslength jth valu answer true path queriesj true fals otherwis exampl 1 input n 3 edgelist 0121242081016 queri 012025 output falsetru explan figur show given graph note two overlap edg 0 1 distanc 2 16 first queri 0 1 path distanc less 2 thu return fals queri second queri path 0 1 2 two edg distanc less 5 thu return true queri exampl 2 input n 5 edgelist 01101252393413 queri 04141413 output truefals explan figur show given graph constraint 2 n 105 1 edgelistlength querieslength 105 edgelistilength 3 queriesjlength 3 0 ui vi pj qj n 1 ui vi pj qj 1 disi limitj 109 may multipl edg two node checkingexistenceofedgelengthlimitedpath
given root binari search tree return balanc binari search tree node valu one answer return binari search tree balanc depth two subtre everi node never differ 1 exampl 1 input root 1null2null3null4nullnul output 213nullnullnull4 explan correct answer 314null2 also correct exampl 2 input root 213 output 213 constraint number node tree rang 1 104 1 nodev 105 balanceabinarysearchtre
given 0index 2d integ array flower flowersi starti endi mean ith flower full bloom starti endi inclus also given 0index integ array peopl size n poeplei time ith person arriv see flower return integ array answer size n answeri number flower full bloom ith person arriv exampl 1 input flower 1637912413 poepl 23711 output 1222 explan figur show time flower full bloom peopl arriv person return number flower full bloom arriv exampl 2 input flower 11033 poepl 332 output 221 explan figur show time flower full bloom peopl arriv person return number flower full bloom arriv constraint 1 flowerslength 5 104 flowersilength 2 1 starti endi 109 1 peoplelength 5 104 1 peoplei 109 numberofflowersinfullbloom
given two array uniqu digit nums1 nums2 return smallest number contain least one digit array exampl 1 input nums1 413 nums2 57 output 15 explan number 15 contain digit 1 nums1 digit 5 nums2 proven 15 smallest number exampl 2 input nums1 3526 nums2 317 output 3 explan number 3 contain digit 3 exist array constraint 1 nums1length nums2length 9 1 nums1i nums2i 9 digit array uniqu formsmallestnumberfromtwodigitarray
given x n matrix initi 0s array oper op opsi ai bi mean mxi increment one 0 x ai 0 bi count return number maximum integ matrix perform oper exampl 1 input 3 n 3 op 2233 output 4 explan maximum integ 2 four return 4 exampl 2 input 3 n 3 op 223333332233333322333333 output 4 exampl 3 input 3 n 3 op output 9 constraint 1 n 4 104 0 opslength 104 opsilength 2 1 ai 1 bi n rangeadditionii
write effici algorithm search valu target x n integ matrix matrix matrix follow properti integ row sort ascend left right integ column sort ascend top bottom exampl 1 input matrix 14711152581219369162210131417241821232630 target 5 output true exampl 2 input matrix 14711152581219369162210131417241821232630 target 20 output fals constraint matrixlength n matrixilength 1 n 300 109 matrixij 109 integ row sort ascend order integ column sort ascend order 109 target 109 searcha2dmatrixii
given function fn array argument arg timeout millisecond return cancel function cancelfn delay fn call arg pass paramet unless cancelfn call first case fn never call exampl 1 input fn x x 5 arg 2 20 output time 20 return 10 explan const canceltim 50 const cancel cancellablex x 5 2 20 fn2 call t20m settimeoutcancel canceltim cancel schedul occur delay canceltim 50m happen execut fn2 20m exampl 2 input fn x x2 arg 2 100 output explan const canceltim 50 const cancel cancellablex x2 2 100 fn2 call settimeoutcancel canceltim cancel schedul occur delay canceltim 50m happen execut fn2 100m result fn2 never call exampl 3 input fn x1 x2 x1 x2 arg 24 30 output time 30 return 8 explan const canceltim 100 const cancel cancellablex1 x2 x1 x2 24 30 fn24 call t30m settimeoutcancel canceltim cancel schedul occur delay canceltim 100m happen execut fn24 30m constraint fn function arg valid json array 1 argslength 10 20 1000 10 cancelt 1000 executecancellablefunctionwithdelay
recentcount class count number recent request within certain time frame implement recentcount class recentcount initi counter zero recent request int pingint add new request time repres time millisecond return number request happen past 3000 millisecond includ new request specif return number request happen inclus rang 3000 guarante everi call ping use strictli larger valu previou call exampl 1 input recentcount ping ping ping ping 1 100 3001 3002 output null 1 2 3 3 explan recentcount recentcount new recentcount recentcounterping1 request 1 rang 29991 return 1 recentcounterping100 request 1 100 rang 2900100 return 2 recentcounterping3001 request 1 100 3001 rang 13001 return 3 recentcounterping3002 request 1 100 3001 3002 rang 23002 return 3 constraint 1 109 test case call ping strictli increas valu 104 call made ping numberofrecentcal
given string partit string one substr charact substr uniqu letter appear singl substr return minimum number substr partit note charact belong exactli one substr partit exampl 1 input abacaba output 4 explan two possibl partit abacaba abacaba shown 4 minimum number substr need exampl 2 input ssssss output 6 explan valid partit ssssss constraint 1 slength 105 consist english lowercas letter optimalpartitionofstr
given two integ n repres 0index x n grid also given two 2d integ array guard wall guardsi rowi coli wallsj rowj colj repres posit ith guard jth wall respect guard see everi cell four cardin direct north east south west start posit unless obstruct wall anoth guard cell guard least one guard see return number unoccupi cell guard exampl 1 input 4 n 6 guard 001123 wall 012214 output 7 explan guard unguard cell shown red green respect diagram total 7 unguard cell return 7 exampl 2 input 3 n 3 guard 11 wall 01102112 output 4 explan unguard cell shown green diagram total 4 unguard cell return 4 constraint 1 n 105 2 n 105 1 guardslength wallslength 5 104 2 guardslength wallslength n guardsilength wallsjlength 2 0 rowi rowj 0 coli colj n posit guard wall uniqu countunguardedcellsinthegrid
given integ array num integ k index 0 numslength chang numsi either numsi k numsi k score num differ maximum minimum element num return minimum score num chang valu index exampl 1 input num 1 k 0 output 0 explan score maxnum minnum 1 1 0 exampl 2 input num 010 k 2 output 6 explan chang num 2 8 score maxnum minnum 8 2 6 exampl 3 input num 136 k 3 output 3 explan chang num 4 6 3 score maxnum minnum 6 3 3 constraint 1 numslength 104 0 numsi 104 0 k 104 smallestrangeii
n chip posit ith chip positioni need move chip posit one step chang posit ith chip positioni positioni 2 positioni 2 cost 0 positioni 1 positioni 1 cost 1 return minimum cost need move chip posit exampl 1 input posit 123 output 1 explan first step move chip posit 3 posit 1 cost 0 second step move chip posit 2 posit 1 cost 1 total cost 1 exampl 2 input posit 22233 output 2 explan move two chip posit 3 posit 2 move cost 1 total cost 2 exampl 3 input posit 11000000000 output 1 constraint 1 positionlength 100 1 positioni 109 minimumcosttomovechipstothesameposit
given integ array num goal make element num equal complet one oper follow step find largest valu num let index 0index valu largest multipl element largest valu pick smallest find next largest valu num strictli smaller largest let valu nextlargest reduc numsi nextlargest return number oper make element num equal exampl 1 input num 513 output 3 explan take 3 oper make element num equal 1 largest 5 index 0 nextlargest 3 reduc nums0 3 num 313 2 largest 3 index 0 nextlargest 1 reduc nums0 1 num 113 3 largest 3 index 2 nextlargest 1 reduc nums2 1 num 111 exampl 2 input num 111 output 0 explan element num alreadi equal exampl 3 input num 11223 output 4 explan take 4 oper make element num equal 1 largest 3 index 4 nextlargest 2 reduc nums4 2 num 11222 2 largest 2 index 2 nextlargest 1 reduc nums2 1 num 11122 3 largest 2 index 3 nextlargest 1 reduc nums3 1 num 11112 4 largest 2 index 4 nextlargest 1 reduc nums4 1 num 11111 constraint 1 numslength 5 104 1 numsi 5 104 reductionoperationstomakethearrayelementsequ
revers integ mean revers digit exampl revers 2021 give 1202 revers 12300 give 321 lead zero retain given integ num revers num get reversed1 revers reversed1 get reversed2 return true reversed2 equal num otherwis return fals exampl 1 input num 526 output true explan revers num get 625 revers 625 get 526 equal num exampl 2 input num 1800 output fals explan revers num get 81 revers 81 get 18 equal num exampl 3 input num 0 output true explan revers num get 0 revers 0 get 0 equal num constraint 0 num 106 anumberafteradoublerevers
given integ array num find subarray largest sum return sum exampl 1 input num 213412154 output 6 explan subarray 4121 largest sum 6 exampl 2 input num 1 output 1 explan subarray 1 largest sum 1 exampl 3 input num 54178 output 23 explan subarray 54178 largest sum 23 constraint 1 numslength 105 104 numsi 104 follow figur solut tri code anoth solut use divid conquer approach subtl maximumsubarray
given head sort link list delet node duplic number leav distinct number origin list return link list sort well exampl 1 input head 1233445 output 125 exampl 2 input head 11123 output 23 constraint number node list rang 0 300 100 nodev 100 list guarante sort ascend order removeduplicatesfromsortedlistii
given string length n si either mean decreas mean increas permut perm n 1 integ integ rang 0 n call valid permut valid si permi permi 1 si permi permi 1 return number valid permut perm sinc answer may larg return modulo 109 7 exampl 1 input output 5 explan 5 valid permut 0 1 2 3 1 0 3 2 2 0 3 1 2 1 3 0 3 0 2 1 3 1 2 0 exampl 2 input output 1 constraint n slength 1 n 200 si either validpermutationsfordisequ
given integ array card length 4 four card contain number rang 1 9 arrang number card mathemat express use oper parenthes get valu 24 restrict follow rule divis oper repres real divis integ divis exampl 4 1 2 3 4 1 3 12 everi oper done two number particular use unari oper exampl card 1 1 1 1 express 1 1 1 1 allow concaten number togeth exampl card 1 2 1 2 express 12 12 valid return true get express evalu 24 fals otherwis exampl 1 input card 4187 output true explan 84 71 24 exampl 2 input card 1212 output fals constraint cardslength 4 1 cardsi 9 24game
given string consist charact b c ask appli follow algorithm string number time pick nonempti prefix string charact prefix equal pick nonempti suffix string charact suffix equal prefix suffix intersect index charact prefix suffix must delet prefix suffix return minimum length perform oper number time possibl zero time exampl 1 input ca output 2 explan cant remov charact string stay exampl 2 input cabaabac output 0 explan optim sequenc oper take prefix c suffix c remov abaaba take prefix suffix remov baab take prefix b suffix b remov aa take prefix suffix remov exampl 3 input aabccabba output 3 explan optim sequenc oper take prefix aa suffix remov bccabb take prefix b suffix bb remov cca constraint 1 slength 105 consist charact b c minimumlengthofstringafterdeletingsimilarend
given string integ k k duplic remov consist choos k adjac equal letter remov caus left right side delet substr concaten togeth repeatedli make k duplic remov longer return final string duplic remov made guarante answer uniqu exampl 1 input abcd k 2 output abcd explan there noth delet exampl 2 input deeedbbcccbdaa k 3 output aa explan first delet eee ccc get ddbbbdaa delet bbb get dddaa final delet ddd get aa exampl 3 input pbbcggttciiippooaai k 2 output ps constraint 1 slength 105 2 k 104 contain lowercas english letter removealladjacentduplicatesinstringii
given array num posit integ task select subset num multipli element integ add number array said good obtain sum 1 array possibl subset multiplicand return true array good otherwis return fals exampl 1 input num 125723 output true explan pick number 5 7 53 72 1 exampl 2 input num 29610 output true explan pick number 29 6 10 291 63 101 1 exampl 3 input num 36 output fals constraint 1 numslength 105 1 numsi 109 checkifitisagoodarray
good meal meal contain exactli two differ food item sum delici equal power two pick two differ food make good meal given array integ delici deliciousnessi delici ith item food return number differ good meal make list modulo 109 7 note item differ indic consid differ even delici valu exampl 1 input delici 13579 output 4 explan good meal 13 17 35 79 respect sum 4 8 8 16 power 2 exampl 2 input delici 1113337 output 15 explan good meal 11 3 way 13 9 way 17 3 way constraint 1 deliciousnesslength 105 0 deliciousnessi 220 countgoodm
given array string word element word consist two lowercas english letter creat longest possibl palindrom select element word concaten order element select return length longest palindrom creat imposs creat palindrom return 0 palindrom string read forward backward exampl 1 input word lcclgg output 6 explan one longest palindrom lc gg cl lcggcl length 6 note clgglc anoth longest palindrom creat exampl 2 input word abtyytlcclab output 8 explan one longest palindrom ty lc cl yt tylcclyt length 8 note lcyttycl anoth longest palindrom creat exampl 3 input word ccllxx output 2 explan one longest palindrom cc length 2 note anoth longest palindrom creat xx constraint 1 wordslength 105 wordsilength 2 wordsi consist lowercas english letter longestpalindromebyconcatenatingtwoletterword
given two string array words1 words2 string b subset string everi letter b occur includ multipl exampl wrr subset warrior subset world string words1 univers everi string b words2 b subset return array univers string words1 may return answer order exampl 1 input words1 amazonapplefacebookgoogleleetcod words2 eo output facebookgoogleleetcod exampl 2 input words1 amazonapplefacebookgoogleleetcod words2 le output applegoogleleetcod constraint 1 words1length words2length 104 1 words1ilength words2ilength 10 words1i words2i consist lowercas english letter string words1 uniqu wordsubset
given string n repres integ return closest integ includ palindrom tie return smaller one closest defin absolut differ minim two integ exampl 1 input n 123 output 121 exampl 2 input n 1 output 0 explan 0 2 closest palindrom return smallest 0 constraint 1 nlength 18 n consist digit n lead zero n repres integ rang 1 1018 1 findtheclosestpalindrom
given head link list integ val remov node link list nodev val return new head exampl 1 input head 1263456 val 6 output 12345 exampl 2 input head val 1 output exampl 3 input head 7777 val 7 output constraint number node list rang 0 104 1 nodev 50 0 val 50 removelinkedlistel
given array string word string char string good form charact char charact use return sum length good string word exampl 1 input word catbthattre char atach output 6 explan string form cat hat answer 3 3 6 exampl 2 input word helloworldleetcod char welldonehoneyr output 10 explan string form hello world answer 5 5 10 constraint 1 wordslength 1000 1 wordsilength charslength 100 wordsi char consist lowercas english letter findwordsthatcanbeformedbycharact
let fx number zero end x recal x 1 2 3 x convent 0 1 exampl f3 0 3 6 zero end f11 2 11 39916800 two zero end given integ k return number nonneg integ x properti fx k exampl 1 input k 0 output 5 explan 0 1 2 3 4 end k 0 zero exampl 2 input k 5 output 0 explan x x end k 5 zero exampl 3 input k 3 output 5 constraint 0 k 109 preimagesizeoffactorialzeroesfunct
given posit integ num consist exactli four digit split num two new integ new1 new2 use digit found num lead zero allow new1 new2 digit found num must use exampl given num 2932 follow digit two 2s one 9 one 3 possibl pair new1 new2 22 93 23 92 223 9 2 329 return minimum possibl sum new1 new2 exampl 1 input num 2932 output 52 explan possibl pair new1 new2 29 23 223 9 etc minimum sum obtain pair 29 23 29 23 52 exampl 2 input num 4009 output 13 explan possibl pair new1 new2 0 49 490 0 etc minimum sum obtain pair 4 9 4 9 13 constraint 1000 num 9999 minimumsumoffourdigitnumberaftersplittingdigit
sql schema tabl insur column name type pid int tiv2015 float tiv2016 float lat float lon float pid primari key column tabl row tabl contain inform one polici pid policyhold polici id tiv2015 total invest valu 2015 tiv2016 total invest valu 2016 lat latitud polici holder citi guarante lat null lon longitud polici holder citi guarante lon null write sql queri report sum total invest valu 2016 tiv2016 policyhold tiv2015 valu one policyhold locat citi like policyhold ie lat lon attribut pair must uniqu round tiv2016 two decim place queri result format follow exampl exampl 1 input insur tabl pid tiv2015 tiv2016 lat lon 1 10 5 10 10 2 20 20 20 20 3 10 30 20 20 4 10 40 40 40 output tiv2016 4500 explan first record tabl like last record meet two criteria tiv2015 valu 10 third fourth record locat uniqu second record meet two criteria tiv2015 like policyhold locat third record make third record fail result sum tiv2016 first last record 45 investmentsin2016
given 0index integ array num low score num minimum valu numsi numsj 0 j numslength high score num maximum valu numsi numsj 0 j numslength score num sum high low score num minim score num chang valu two element num return minimum possibl score chang valu two element num note x denot absolut valu x exampl 1 input num 143 output 0 explan chang valu nums1 nums2 1 num becom 111 valu numsi numsj alway equal 0 return 0 0 0 exampl 2 input num 14785 output 3 explan chang nums0 nums1 6 num becom 66785 low score achiev 0 j 1 case numsi numsj 6 6 0 high score achiev 3 j 4 case numsi numsj 8 5 3 sum high low score 3 prove minim constraint 3 numslength 105 1 numsi 109 minimumscorebychangingtwoel
given 0index array string detail element detail provid inform given passeng compress string length 15 system first ten charact consist phone number passeng next charact denot gender person follow two charact use indic age person last two charact determin seat allot person return number passeng strictli 60 year old exampl 1 input detail 7868190130m75225303914400f92119273338290f4010 output 2 explan passeng indic 0 1 2 age 75 92 40 thu 2 peopl 60 year old exampl 2 input detail 1313579440f20362921522980m5644 output 0 explan none passeng older 60 constraint 1 detailslength 100 detailsilength 15 detailsi consist digit 0 9 detailsi10 either f phone number seat number passeng distinct numberofseniorcitizen
array monoton either monoton increas monoton decreas array num monoton increas j numsi numsj array num monoton decreas j numsi numsj given integ array num return true given array monoton fals otherwis exampl 1 input num 1223 output true exampl 2 input num 6544 output true exampl 3 input num 132 output fals constraint 1 numslength 105 105 numsi 105 monotonicarray
given two 0index integ array num removequeri length n ith queri element num index removequeriesi remov split num differ segment segment contigu sequenc posit integ num segment sum sum everi element segment return integ array answer length n answeri maximum segment sum appli ith remov note index remov exampl 1 input num 12561 removequeri 03241 output 147220 explan use 0 indic remov element answer follow queri 1 remov 0th element num becom 02561 maximum segment sum 14 segment 2561 queri 2 remov 3rd element num becom 02501 maximum segment sum 7 segment 25 queri 3 remov 2nd element num becom 02001 maximum segment sum 2 segment 2 queri 4 remov 4th element num becom 02000 maximum segment sum 2 segment 2 queri 5 remov 1st element num becom 00000 maximum segment sum 0 sinc segment final return 147220 exampl 2 input num 32111 removequeri 3210 output 16530 explan use 0 indic remov element answer follow queri 1 remov 3rd element num becom 32110 maximum segment sum 16 segment 3211 queri 2 remov 2nd element num becom 3200 maximum segment sum 5 segment 32 queri 3 remov 1st element num becom 3000 maximum segment sum 3 segment 3 queri 4 remov 0th element num becom 0000 maximum segment sum 0 sinc segment final return 16530 constraint n numslength removequerieslength 1 n 105 1 numsi 109 0 removequeriesi n valu removequeri uniqu maximumsegmentsumafterremov
given integ array bloomday integ integ k want make bouquet make bouquet need use k adjac flower garden garden consist n flower ith flower bloom bloomdayi use exactli one bouquet return minimum number day need wait abl make bouquet garden imposs make bouquet return 1 exampl 1 input bloomday 1103102 3 k 1 output 3 explan let us see happen first three day x mean flower bloom mean flower bloom garden need 3 bouquet contain 1 flower day 1 x make one bouquet day 2 x x make two bouquet day 3 x x x make 3 bouquet answer 3 exampl 2 input bloomday 1103102 3 k 2 output 1 explan need 3 bouquet 2 flower mean need 6 flower 5 flower imposs get need bouquet return 1 exampl 3 input bloomday 77771277 2 k 3 output 12 explan need 2 bouquet 3 flower garden 7 12 day day 7 x x x x x x make one bouquet first three flower bloom make anoth bouquet last three flower bloom adjac day 12 x x x x x x x obviou make two bouquet differ way constraint bloomdaylength n 1 n 105 1 bloomdayi 109 1 106 1 k n minimumnumberofdaystomakembouquet
given string path pathi n e w repres move one unit north south east west respect start origin 0 0 2d plane walk path specifi path return true path cross point time locat previous visit return fals otherwis exampl 1 input path ne output fals explan notic path doesnt cross point exampl 2 input path nesww output true explan notic path visit origin twice constraint 1 pathlength 104 pathi either n e w pathcross
sql schema tabl salari column name type id int name varchar sex enum salari int id primari key tabl sex column enum valu type f tabl contain inform employe write sql queri swap f valu ie chang f valu vice versa singl updat statement intermedi temporari tabl note must write singl updat statement write select statement problem queri result format follow exampl exampl 1 input salari tabl id name sex salari 1 2500 2 b f 1500 3 c 5500 4 f 500 output id name sex salari 1 f 2500 2 b 1500 3 c f 5500 4 500 explan 1 3 c chang f 2 b 4 chang f swapsalari
given string partit everi substr partit palindrom return possibl palindrom partit exampl 1 input aab output aabaab exampl 2 input output constraint 1 slength 16 contain lowercas english letter palindromepartit
wooden plank length n unit ant walk plank ant move speed 1 unit per second ant move left move right two ant move two differ direct meet point chang direct continu move assum chang direct take addit time ant reach one end plank time fall plank immedi given integ n two integ array left right posit ant move left right return moment last ant fall plank exampl 1 input n 4 left 43 right 01 output 4 explan imag ant index 0 name go right ant index 1 name b go right ant index 3 name c go left ant index 4 name go left last moment ant plank 4 second fall immedi plank ie say 40000000001 ant plank exampl 2 input n 7 left right 01234567 output 7 explan ant go right ant index 0 need 7 second fall exampl 3 input n 7 left 01234567 right output 7 explan ant go left ant index 7 need 7 second fall constraint 1 n 104 0 leftlength n 1 0 lefti n 0 rightlength n 1 0 righti n 1 leftlength rightlength n 1 valu left right uniqu valu appear one two array lastmomentbeforeallantsfalloutofaplank
given string num repres larg integ also given 0index integ array chang length 10 map digit 09 anoth digit formal digit map digit chang may choos mutat singl substr num mutat substr replac digit numi digit map chang ie replac numi changenumi return string repres largest possibl integ mutat choos singl substr num substr contigu sequenc charact within string exampl 1 input num 132 chang 9850364268 output 832 explan replac substr 1 1 map change1 8 thu 132 becom 832 832 largest number creat return exampl 2 input num 021 chang 9435721906 output 934 explan replac substr 021 0 map change0 9 2 map change2 3 1 map change1 4 thu 021 becom 934 934 largest number creat return exampl 3 input num 5 chang 1475325694 output 5 explan 5 alreadi largest number creat return constraint 1 numlength 105 num consist digit 09 changelength 10 0 chang 9 largestnumberaftermutatingsubstr
given string word consist digit lowercas english letter replac everi nondigit charact space exampl a123bc34d8ef34 becom 123 34 8 34 notic left integ separ least one space 123 34 8 34 return number differ integ perform replac oper word two integ consid differ decim represent without lead zero differ exampl 1 input word a123bc34d8ef34 output 3 explan three differ integ 123 34 8 notic 34 count exampl 2 input word leet1234code234 output 2 exampl 3 input word a1b01c001 output 1 explan three integ 1 01 001 repres integ lead zero ignor compar decim valu constraint 1 wordlength 1000 word consist digit lowercas english letter numberofdifferentintegersinastr
given integ array price repres price variou chocol store also given singl integ money repres initi amount money must buy exactli two chocol way still nonneg leftov money would like minim sum price two chocol buy return amount money leftov buy two chocol way buy two chocol without end debt return money note leftov must nonneg exampl 1 input price 122 money 3 output 0 explan purchas chocol price 1 2 unit respect 3 3 0 unit money afterward thu return 0 exampl 2 input price 323 money 3 output 3 explan buy 2 chocol without go debt return 3 constraint 2 priceslength 50 1 pricesi 100 1 money 100 buytwochocol
given wooden stick length n unit stick label 0 n exampl stick length 6 label follow given integ array cut cutsi denot posit perform cut perform cut order chang order cut wish cost one cut length stick cut total cost sum cost cut cut stick split two smaller stick ie sum length length stick cut pleas refer first exampl better explan return minimum total cost cut exampl 1 input n 7 cut 1345 output 16 explan use cut order 1 3 4 5 input lead follow scenario first cut done rod length 7 cost 7 second cut done rod length 6 ie second part first cut third done rod length 4 last cut rod length 3 total cost 7 6 4 3 20 rearrang cut 3 5 1 4 exampl lead scenario total cost 16 shown exampl photo 7 4 3 2 16 exampl 2 input n 9 cut 56142 output 22 explan tri given cut order cost 25 much order total cost 25 exampl order 4 6 5 2 1 total cost 22 minimum possibl constraint 2 n 106 1 cutslength minn 1 100 1 cutsi n 1 integ cut array distinct minimumcosttocutastick
transact possibl invalid amount exce 1000 occur within includ 60 minut anoth transact name differ citi given array string transact transactionsi consist commasepar valu repres name time minut amount citi transact return list transact possibl invalid may return answer order exampl 1 input transact alice20800mtvalice50100beij output alice20800mtvalice50100beij explan first transact invalid second transact occur within differ 60 minut name differ citi similarli second one invalid exampl 2 input transact alice20800mtvalice501200mtv output alice501200mtv exampl 3 input transact alice20800mtvbob501200mtv output bob501200mtv constraint transactionslength 1000 transactionsi take form nametimeamountc name citi consist lowercas english letter length 1 10 time consist digit repres integ 0 1000 amount consist digit repres integ 0 2000 invalidtransact
given integ array arr partit array contigu subarray length k partit subarray valu chang becom maximum valu subarray return largest sum given array partit test case gener answer fit 32bit integ exampl 1 input arr 115792510 k 3 output 84 explan arr becom 1515159101010 exampl 2 input arr 14157361993 k 4 output 83 exampl 3 input arr 1 k 1 output 1 constraint 1 arrlength 500 0 arri 109 1 k arrlength partitionarrayformaximumsum
let say posit integ superpalindrom palindrom also squar palindrom given two posit integ left right repres string return number superpalindrom integ inclus rang left right exampl 1 input left 4 right 1000 output 4 explan 4 9 121 484 superpalindrom note 676 superpalindrom 26 26 676 26 palindrom exampl 2 input left 1 right 2 output 1 constraint 1 leftlength rightlength 18 left right consist digit left right lead zero left right repres integ rang 1 1018 1 left less equal right superpalindrom
given two version number version1 version2 compar version number consist one revis join dot revis consist digit may contain lead zero everi revis contain least one charact revis 0index left right leftmost revis revis 0 next revis revis 1 exampl 2533 01 valid version number compar version number compar revis lefttoright order revis compar use integ valu ignor lead zero mean revis 1 001 consid equal version number specifi revis index treat revis 0 exampl version 10 less version 11 revis 0s revis 1s 0 1 respect 0 1 return follow version1 version2 return 1 version1 version2 return 1 otherwis return 0 exampl 1 input version1 101 version2 1001 output 0 explan ignor lead zero 01 001 repres integ 1 exampl 2 input version1 10 version2 100 output 0 explan version1 specifi revis 2 mean treat 0 exampl 3 input version1 01 version2 11 output 1 explan version1 revis 0 0 version2 revis 0 1 0 1 version1 version2 constraint 1 version1length version2length 500 version1 version2 contain digit version1 version2 valid version number given revis version1 version2 store 32bit integ compareversionnumb
given binari array num integ k return maximum number consecut 1s array flip k 0s exampl 1 input num 11100011110 k 2 output 6 explan 11100111111 bold number flip 0 1 longest subarray underlin exampl 2 input num 0011001110110001111 k 3 output 10 explan 0011111111110001111 bold number flip 0 1 longest subarray underlin constraint 1 numslength 105 numsi either 0 1 0 k numslength maxconsecutiveonesiii
given integ array num rotat array right k step k nonneg exampl 1 input num 1234567 k 3 output 5671234 explan rotat 1 step right 7123456 rotat 2 step right 6712345 rotat 3 step right 5671234 exampl 2 input num 1100399 k 2 output 3991100 explan rotat 1 step right 9911003 rotat 2 step right 3991100 constraint 1 numslength 105 231 numsi 231 1 0 k 105 follow tri come mani solut least three differ way solv problem could inplac o1 extra space rotatearray
given 2d matrix size x n consist nonneg integ also given integ k valu coordin b matrix xor matrixij 0 0 j b n 0index find kth largest valu 1index coordin matrix exampl 1 input matrix 5216 k 1 output 7 explan valu coordin 01 5 xor 2 7 largest valu exampl 2 input matrix 5216 k 2 output 5 explan valu coordin 00 5 5 2nd largest valu exampl 3 input matrix 5216 k 3 output 4 explan valu coordin 10 5 xor 1 4 3rd largest valu constraint matrixlength n matrixilength 1 n 1000 0 matrixij 106 1 k n findkthlargestxorcoordinatevalu
given integ array num length n assum arrk array obtain rotat num k posit clockwis defin rotat function f num follow fk 0 arrk0 1 arrk1 n 1 arrkn 1 return maximum valu f0 f1 fn1 test case gener answer fit 32bit integ exampl 1 input num 4326 output 26 explan f0 0 4 1 3 2 2 3 6 0 3 4 18 25 f1 0 6 1 4 2 3 3 2 0 4 6 6 16 f2 0 2 1 6 2 4 3 3 0 6 8 9 23 f3 0 3 1 2 2 6 3 4 0 2 12 12 26 maximum valu f0 f1 f2 f3 f3 26 exampl 2 input num 100 output 0 constraint n numslength 1 n 105 100 numsi 100 rotatefunct
given posit integ n repres n citi number 1 n also given 2d array road roadsi ai bi distancei indic bidirect road citi ai bi distanc equal distancei citi graph necessarili connect score path two citi defin minimum distanc road path return minimum possibl score path citi 1 n note path sequenc road two citi allow path contain road multipl time visit citi 1 n multipl time along path test case gener least one path 1 n exampl 1 input n 4 road 129236245147 output 5 explan path citi 1 4 minimum score 1 2 4 score path min95 5 shown path less score exampl 2 input n 4 road 122134347 output 2 explan path citi 1 4 minimum score 1 2 1 3 4 score path min2247 2 constraint 2 n 105 1 roadslength 105 roadsilength 3 1 ai bi n ai bi 1 distancei 104 repeat edg least one path 1 n minimumscoreofapathbetweentwoc
given array num n object color red white blue sort inplac object color adjac color order red white blue use integ 0 1 2 repres color red white blue respect must solv problem without use librari sort function exampl 1 input num 202110 output 001122 exampl 2 input num 201 output 012 constraint n numslength 1 n 300 numsi either 0 1 2 follow could come onepass algorithm use constant extra space sortcolor
given array integ return maximum sum nonempti subarray contigu element one element delet word want choos subarray option delet one element still least one element left sum remain element maximum possibl note subarray need nonempti delet one element exampl 1 input arr 1203 output 4 explan choos 1 2 0 3 drop 2 thu subarray 1 0 3 becom maximum valu exampl 2 input arr 1223 output 3 explan choos 3 maximum sum exampl 3 input arr 1111 output 1 explan final subarray need nonempti cant choos 1 delet 1 get empti subarray make sum equal 0 constraint 1 arrlength 105 104 arri 104 maximumsubarraysumwithonedelet
given root binari search tree bst return minimum absolut differ valu two differ node tree exampl 1 input root 42613 output 1 exampl 2 input root 1048nullnull1249 output 1 constraint number node tree rang 2 104 0 nodev 105 note question 783 httpsleetcodecomproblemsminimumdistancebetweenbstnod minimumabsolutedifferenceinbst
given integ array num two integ left right return number contigu nonempti subarray valu maximum array element subarray rang left right test case gener answer fit 32bit integ exampl 1 input num 2143 left 2 right 3 output 3 explan three subarray meet requir 2 2 1 3 exampl 2 input num 29256 left 2 right 8 output 7 constraint 1 numslength 105 0 numsi 109 0 left right 109 numberofsubarrayswithboundedmaximum
given array num integ target return maximum number nonempti nonoverlap subarray sum valu subarray equal target exampl 1 input num 11111 target 2 output 2 explan 2 nonoverlap subarray 11111 sum equal target2 exampl 2 input num 1351429 target 6 output 2 explan 3 subarray sum equal 6 51 42 351429 first 2 nonoverlap constraint 1 numslength 105 104 numsi 104 0 target 106 maximumnumberofnonoverlappingsubarrayswithsumequalstarget
given x n grid grid empti cell wall start point lowercas letter repres key uppercas letter repres lock start start point one move consist walk one space one four cardin direct walk outsid grid walk wall walk key pick walk lock unless correspond key 1 k 6 exactli one lowercas one uppercas letter first k letter english alphabet grid mean exactli one key lock one lock key also letter use repres key lock chosen order english alphabet return lowest number move acquir key imposs return 1 exampl 1 input grid abab output 8 explan note goal obtain key open lock exampl 2 input grid aabb output 6 exampl 3 input grid aa output 1 constraint gridlength n gridilength 1 n 30 gridij either english letter exactli one grid number key grid rang 1 6 key grid uniqu key grid match lock shortestpathtogetallkey
given larg integ repres integ array digit digitsi ith digit integ digit order signific least signific lefttoright order larg integ contain lead 0s increment larg integ one return result array digit exampl 1 input digit 123 output 124 explan array repres integ 123 increment one give 123 1 124 thu result 124 exampl 2 input digit 4321 output 4322 explan array repres integ 4321 increment one give 4321 1 4322 thu result 4322 exampl 3 input digit 9 output 10 explan array repres integ 9 increment one give 9 1 10 thu result 10 constraint 1 digitslength 100 0 digitsi 9 digit contain lead 0s pluson
given string array string word determin whether prefix string word string prefix string word made concaten first k string word posit k larger wordslength return true prefix string word fals otherwis exampl 1 input iloveleetcod word iloveleetcodeappl output true explan made concaten love leetcod togeth exampl 2 input iloveleetcod word applesiloveleetcod output fals explan imposs make use prefix arr constraint 1 wordslength 100 1 wordsilength 20 1 slength 1000 wordsi consist lowercas english letter checkifstringisaprefixofarray
given 0index array num consist posit integ repres target number line also given integ space machin destroy target seed machin numsi allow destroy target valu repres numsi c space c nonneg integ want destroy maximum number target num return minimum valu numsi seed machin destroy maximum number target exampl 1 input num 378115 space 2 output 1 explan seed machin nums3 destroy target equal 13579 case would destroy 5 total target except nums2 imposs destroy 5 target return nums3 exampl 2 input num 135246 space 2 output 1 explan seed machin nums0 nums3 destroy 3 target possibl destroy 3 target sinc nums0 minim integ destroy 3 target return 1 exampl 3 input num 625 space 100 output 2 explan whatev initi seed select destroy 1 target minim seed nums1 constraint 1 numslength 105 1 numsi 109 1 space 109 destroysequentialtarget
given two integ array nums1 nums2 sort nondecreas order two integ n repres number element nums1 nums2 respect merg nums1 nums2 singl array sort nondecreas order final sort array return function instead store insid array nums1 accommod nums1 length n first element denot element merg last n element set 0 ignor nums2 length n exampl 1 input nums1 123000 3 nums2 256 n 3 output 122356 explan array merg 123 256 result merg 122356 underlin element come nums1 exampl 2 input nums1 1 1 nums2 n 0 output 1 explan array merg 1 result merg 1 exampl 3 input nums1 0 0 nums2 1 n 1 output 1 explan array merg 1 result merg 1 note 0 element nums1 0 ensur merg result fit nums1 constraint nums1length n nums2length n 0 n 200 1 n 200 109 nums1i nums2j 109 follow come algorithm run om n time mergesortedarray
given encod string return decod string encod rule kencodedstr encodedstr insid squar bracket repeat exactli k time note k guarante posit integ may assum input string alway valid extra white space squar bracket wellform etc furthermor may assum origin data contain digit digit repeat number k exampl input like 3a 24 test case gener length output never exceed 105 exampl 1 input 3a2bc output aaabcbc exampl 2 input 3a2c output accaccacc exampl 3 input 2abc3cdef output abcabccdcdcdef constraint 1 slength 30 consist lowercas english letter digit squar bracket guarante valid input integ rang 1 300 decodestr
given two string determin isomorph two string isomorph charact replac get occurr charact must replac anoth charact preserv order charact two charact may map charact charact may map exampl 1 input egg add output true exampl 2 input foo bar output fals exampl 3 input paper titl output true constraint 1 slength 5 104 tlength slength consist valid ascii charact isomorphicstr
valid number split compon order decim number integ option e e follow integ decim number split compon order option sign charact either one follow format one digit follow dot one digit follow dot follow one digit dot follow one digit integ split compon order option sign charact either one digit exampl follow valid number 2 0089 01 314 4 9 2e10 90e3 3e7 6e1 535e93 123456e789 follow valid number abc 1a 1e e3 99e25 6 3 95a54e53 given string return true valid number exampl 1 input 0 output true exampl 2 input e output fals exampl 3 input output fals constraint 1 slength 20 consist english letter uppercas lowercas digit 09 plu minu dot validnumb
given string consist lowercas uppercas letter return length longest palindrom built letter letter case sensit exampl aa consid palindrom exampl 1 input abccccdd output 7 explan one longest palindrom built dccaccd whose length 7 exampl 2 input output 1 explan longest palindrom built whose length 1 constraint 1 slength 2000 consist lowercas andor uppercas english letter longestpalindrom
given integ n return true power four otherwis return fals integ n power four exist integ x n 4x exampl 1 input n 16 output true exampl 2 input n 5 output fals exampl 3 input n 1 output true constraint 231 n 231 1 follow could solv without loopsrecurs poweroffour
k x k magic squar k x k grid fill integ everi row sum everi column sum diagon sum equal integ magic squar distinct everi 1 x 1 grid trivial magic squar given x n integ grid return size ie side length k largest magic squar found within grid exampl 1 input grid 71456251641543212734 output 3 explan largest magic squar size 3 everi row sum column sum diagon sum magic squar equal 12 row sum 516 543 273 12 column sum 552 147 633 12 diagon sum 543 642 12 exampl 2 input grid 513193311338 output 2 constraint gridlength n gridilength 1 n 50 1 gridij 106 largestmagicsquar
given 0index integ array num integ valu one oper add subtract valu element num exampl num 123 valu 2 choos subtract valu nums0 make num 123 mex minimum exclud array smallest miss nonneg integ exampl mex 123 0 mex 103 2 return maximum mex num appli mention oper number time exampl 1 input num 11071368 valu 5 output 4 explan one achiev result appli follow oper add valu nums1 twice make num 1071368 subtract valu nums2 make num 1021368 subtract valu nums3 twice make num 102368 mex num 4 shown 4 maximum mex achiev exampl 2 input num 11071368 valu 7 output 2 explan one achiev result appli follow oper subtract valu nums2 make num 11001368 mex num 2 shown 2 maximum mex achiev constraint 1 numslength valu 105 109 numsi 109 smallestmissingnonnegativeintegerafteroper
